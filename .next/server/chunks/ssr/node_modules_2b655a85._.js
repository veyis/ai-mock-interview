module.exports = {

"[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)").vendored['react-ssr'].ReactJsxDevRuntime; //# sourceMappingURL=react-jsx-dev-runtime.js.map
}}),
"[project]/node_modules/next/dist/shared/lib/image-external.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getImageProps: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getImageProps: function() {
        return getImageProps;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-ssr] (ecmascript)");
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-ssr] (ecmascript)");
const _imagecomponent = __turbopack_context__.r("[project]/node_modules/next/dist/client/image-component.js [app-ssr] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-ssr] (ecmascript)"));
function getImageProps(imgProps) {
    const { props } = (0, _getimgprops.getImgProps)(imgProps, {
        defaultLoader: _imageloader.default,
        // This is replaced by webpack define plugin
        imgConf: ("TURBOPACK compile-time value", JSON.parse('{"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/_next/image","loader":"default","dangerouslyAllowSVG":false,"unoptimized":false,"domains":[],"remotePatterns":[]}'))
    });
    // Normally we don't care about undefined props because we pass to JSX,
    // but this exported function could be used by the end user for anything
    // so we delete undefined props to clean it up a little.
    for (const [key, value] of Object.entries(props)){
        if (value === undefined) {
            delete props[key];
        }
    }
    return {
        props
    };
}
const _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map
}}),
"[project]/node_modules/next/image.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-external.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/next/navigation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/client/components/navigation.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/zod/lib/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BRAND": (()=>BRAND),
    "DIRTY": (()=>DIRTY),
    "EMPTY_PATH": (()=>EMPTY_PATH),
    "INVALID": (()=>INVALID),
    "NEVER": (()=>NEVER),
    "OK": (()=>OK),
    "ParseStatus": (()=>ParseStatus),
    "Schema": (()=>ZodType),
    "ZodAny": (()=>ZodAny),
    "ZodArray": (()=>ZodArray),
    "ZodBigInt": (()=>ZodBigInt),
    "ZodBoolean": (()=>ZodBoolean),
    "ZodBranded": (()=>ZodBranded),
    "ZodCatch": (()=>ZodCatch),
    "ZodDate": (()=>ZodDate),
    "ZodDefault": (()=>ZodDefault),
    "ZodDiscriminatedUnion": (()=>ZodDiscriminatedUnion),
    "ZodEffects": (()=>ZodEffects),
    "ZodEnum": (()=>ZodEnum),
    "ZodError": (()=>ZodError),
    "ZodFirstPartyTypeKind": (()=>ZodFirstPartyTypeKind),
    "ZodFunction": (()=>ZodFunction),
    "ZodIntersection": (()=>ZodIntersection),
    "ZodIssueCode": (()=>ZodIssueCode),
    "ZodLazy": (()=>ZodLazy),
    "ZodLiteral": (()=>ZodLiteral),
    "ZodMap": (()=>ZodMap),
    "ZodNaN": (()=>ZodNaN),
    "ZodNativeEnum": (()=>ZodNativeEnum),
    "ZodNever": (()=>ZodNever),
    "ZodNull": (()=>ZodNull),
    "ZodNullable": (()=>ZodNullable),
    "ZodNumber": (()=>ZodNumber),
    "ZodObject": (()=>ZodObject),
    "ZodOptional": (()=>ZodOptional),
    "ZodParsedType": (()=>ZodParsedType),
    "ZodPipeline": (()=>ZodPipeline),
    "ZodPromise": (()=>ZodPromise),
    "ZodReadonly": (()=>ZodReadonly),
    "ZodRecord": (()=>ZodRecord),
    "ZodSchema": (()=>ZodType),
    "ZodSet": (()=>ZodSet),
    "ZodString": (()=>ZodString),
    "ZodSymbol": (()=>ZodSymbol),
    "ZodTransformer": (()=>ZodEffects),
    "ZodTuple": (()=>ZodTuple),
    "ZodType": (()=>ZodType),
    "ZodUndefined": (()=>ZodUndefined),
    "ZodUnion": (()=>ZodUnion),
    "ZodUnknown": (()=>ZodUnknown),
    "ZodVoid": (()=>ZodVoid),
    "addIssueToContext": (()=>addIssueToContext),
    "any": (()=>anyType),
    "array": (()=>arrayType),
    "bigint": (()=>bigIntType),
    "boolean": (()=>booleanType),
    "coerce": (()=>coerce),
    "custom": (()=>custom),
    "date": (()=>dateType),
    "datetimeRegex": (()=>datetimeRegex),
    "default": (()=>z),
    "defaultErrorMap": (()=>errorMap),
    "discriminatedUnion": (()=>discriminatedUnionType),
    "effect": (()=>effectsType),
    "enum": (()=>enumType),
    "function": (()=>functionType),
    "getErrorMap": (()=>getErrorMap),
    "getParsedType": (()=>getParsedType),
    "instanceof": (()=>instanceOfType),
    "intersection": (()=>intersectionType),
    "isAborted": (()=>isAborted),
    "isAsync": (()=>isAsync),
    "isDirty": (()=>isDirty),
    "isValid": (()=>isValid),
    "late": (()=>late),
    "lazy": (()=>lazyType),
    "literal": (()=>literalType),
    "makeIssue": (()=>makeIssue),
    "map": (()=>mapType),
    "nan": (()=>nanType),
    "nativeEnum": (()=>nativeEnumType),
    "never": (()=>neverType),
    "null": (()=>nullType),
    "nullable": (()=>nullableType),
    "number": (()=>numberType),
    "object": (()=>objectType),
    "objectUtil": (()=>objectUtil),
    "oboolean": (()=>oboolean),
    "onumber": (()=>onumber),
    "optional": (()=>optionalType),
    "ostring": (()=>ostring),
    "pipeline": (()=>pipelineType),
    "preprocess": (()=>preprocessType),
    "promise": (()=>promiseType),
    "quotelessJson": (()=>quotelessJson),
    "record": (()=>recordType),
    "set": (()=>setType),
    "setErrorMap": (()=>setErrorMap),
    "strictObject": (()=>strictObjectType),
    "string": (()=>stringType),
    "symbol": (()=>symbolType),
    "transformer": (()=>effectsType),
    "tuple": (()=>tupleType),
    "undefined": (()=>undefinedType),
    "union": (()=>unionType),
    "unknown": (()=>unknownType),
    "util": (()=>util),
    "void": (()=>voidType),
    "z": (()=>z)
});
var util;
(function(util) {
    util.assertEqual = (val)=>val;
    function assertIs(_arg) {}
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items)=>{
        const obj = {};
        for (const item of items){
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj)=>{
        const validKeys = util.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys){
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj)=>{
        return util.objectKeys(obj).map(function(e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
     ? (obj)=>Object.keys(obj) // eslint-disable-line ban/ban
     : (object)=>{
        const keys = [];
        for(const key in object){
            if (Object.prototype.hasOwnProperty.call(object, key)) {
                keys.push(key);
            }
        }
        return keys;
    };
    util.find = (arr, checker)=>{
        for (const item of arr){
            if (checker(item)) return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function" ? (val)=>Number.isInteger(val) // eslint-disable-line ban/ban
     : (val)=>typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array.map((val)=>typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value)=>{
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util || (util = {}));
var objectUtil;
(function(objectUtil) {
    objectUtil.mergeShapes = (first, second)=>{
        return {
            ...first,
            ...second
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]);
const getParsedType = (data)=>{
    const t = typeof data;
    switch(t){
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};
const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]);
const quotelessJson = (obj)=>{
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues){
        super();
        this.issues = [];
        this.addIssue = (sub)=>{
            this.issues = [
                ...this.issues,
                sub
            ];
        };
        this.addIssues = (subs = [])=>{
            this.issues = [
                ...this.issues,
                ...subs
            ];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        } else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper || function(issue) {
            return issue.message;
        };
        const fieldErrors = {
            _errors: []
        };
        const processError = (error)=>{
            for (const issue of error.issues){
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                } else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                } else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                } else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                } else {
                    let curr = fieldErrors;
                    let i = 0;
                    while(i < issue.path.length){
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                        // if (typeof el === "string") {
                        //   curr[el] = curr[el] || { _errors: [] };
                        // } else if (typeof el === "number") {
                        //   const errorArray: any = [];
                        //   errorArray._errors = [];
                        //   curr[el] = curr[el] || errorArray;
                        // }
                        } else {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue)=>issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues){
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            } else {
                formErrors.push(mapper(sub));
            }
        }
        return {
            formErrors,
            fieldErrors
        };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues)=>{
    const error = new ZodError(issues);
    return error;
};
const errorMap = (issue, _ctx)=>{
    let message;
    switch(issue.code){
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            } else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                } else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                } else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                } else {
                    util.assertNever(issue.validation);
                }
            } else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            } else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return {
        message
    };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}
const makeIssue = (params)=>{
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [
        ...path,
        ...issueData.path || []
    ];
    const fullIssue = {
        ...issueData,
        path: fullPath
    };
    if (issueData.message !== undefined) {
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message
        };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m)=>!!m).slice().reverse();
    for (const map of maps){
        errorMessage = map(fullIssue, {
            data,
            defaultError: errorMessage
        }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            overrideMap,
            overrideMap === errorMap ? undefined : errorMap
        ].filter((x)=>!!x)
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid") this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted") this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results){
            if (s.status === "aborted") return INVALID;
            if (s.status === "dirty") status.dirty();
            arrayValue.push(s.value);
        }
        return {
            status: status.value,
            value: arrayValue
        };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs){
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs){
            const { key, value } = pair;
            if (key.status === "aborted") return INVALID;
            if (value.status === "aborted") return INVALID;
            if (key.status === "dirty") status.dirty();
            if (value.status === "dirty") status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return {
            status: status.value,
            value: finalObject
        };
    }
}
const INVALID = Object.freeze({
    status: "aborted"
});
const DIRTY = (value)=>({
        status: "dirty",
        value
    });
const OK = (value)=>({
        status: "valid",
        value
    });
const isAborted = (x)=>x.status === "aborted";
const isDirty = (x)=>x.status === "dirty";
const isValid = (x)=>x.status === "valid";
const isAsync = (x)=>typeof Promise !== "undefined" && x instanceof Promise;
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var errorUtil;
(function(errorUtil) {
    errorUtil.errToObj = (message)=>typeof message === "string" ? {
            message
        } : message || {};
    errorUtil.toString = (message)=>typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
    constructor(parent, value, path, key){
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            } else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result)=>{
    if (isValid(result)) {
        return {
            success: true,
            data: result.value
        };
    } else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error () {
                if (this._error) return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            }
        };
    }
};
function processCreateParams(params) {
    if (!params) return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap) return {
        errorMap: errorMap,
        description
    };
    const customMap = (iss, ctx)=>{
        var _a, _b;
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
            return {
                message: message !== null && message !== void 0 ? message : ctx.defaultError
            };
        }
        if (typeof ctx.data === "undefined") {
            return {
                message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError
            };
        }
        if (iss.code !== "invalid_type") return {
            message: ctx.defaultError
        };
        return {
            message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError
        };
    };
    return {
        errorMap: customMap,
        description
    };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
        };
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent
            }
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
        };
        const result = this._parseSync({
            data,
            path: ctx.path,
            parent: ctx
        });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        var _a, _b;
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
            try {
                const result = this._parseSync({
                    data,
                    path: [],
                    parent: ctx
                });
                return isValid(result) ? {
                    value: result.value
                } : {
                    issues: ctx.common.issues
                };
            } catch (err) {
                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
                    this["~standard"].async = true;
                }
                ctx.common = {
                    issues: [],
                    async: true
                };
            }
        }
        return this._parseAsync({
            data,
            path: [],
            parent: ctx
        }).then((result)=>isValid(result) ? {
                value: result.value
            } : {
                issues: ctx.common.issues
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val)=>{
            if (typeof message === "string" || typeof message === "undefined") {
                return {
                    message
                };
            } else if (typeof message === "function") {
                return message(val);
            } else {
                return message;
            }
        };
        return this._refinement((val, ctx)=>{
            const result = check(val);
            const setError = ()=>ctx.addIssue({
                    code: ZodIssueCode.custom,
                    ...getIssueProperties(val)
                });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data)=>{
                    if (!data) {
                        setError();
                        return false;
                    } else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            } else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx)=>{
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
                return false;
            } else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "refinement",
                refinement
            }
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def){
        /** Alias of safeParseAsync */ this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data)=>this["~validate"](data)
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([
            this,
            option
        ], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "transform",
                transform
            }
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def)
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&â€™*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    // let regex = `\\d{2}:\\d{2}:\\d{2}`;
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
        regex = `${regex}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
        regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt)) return false;
    try {
        const [header] = jwt.split(".");
        // Convert base64url to base64
        const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null) return false;
        if (!decoded.typ || !decoded.alg) return false;
        if (alg && decoded.alg !== alg) return false;
        return true;
    } catch (_a) {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                    } else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message
                        });
                    }
                    status.dirty();
                }
            } else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "nanoid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "url") {
                try {
                    new URL(input.data);
                } catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "trim") {
                input.data = input.data.trim();
            } else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: {
                            includes: check.value,
                            position: check.position
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            } else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            } else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: {
                            startsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: {
                            endsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "duration",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "jwt",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cidr",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _regex(regex, validation, message) {
        return this.refinement((data)=>regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message)
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    email(message) {
        return this._addCheck({
            kind: "email",
            ...errorUtil.errToObj(message)
        });
    }
    url(message) {
        return this._addCheck({
            kind: "url",
            ...errorUtil.errToObj(message)
        });
    }
    emoji(message) {
        return this._addCheck({
            kind: "emoji",
            ...errorUtil.errToObj(message)
        });
    }
    uuid(message) {
        return this._addCheck({
            kind: "uuid",
            ...errorUtil.errToObj(message)
        });
    }
    nanoid(message) {
        return this._addCheck({
            kind: "nanoid",
            ...errorUtil.errToObj(message)
        });
    }
    cuid(message) {
        return this._addCheck({
            kind: "cuid",
            ...errorUtil.errToObj(message)
        });
    }
    cuid2(message) {
        return this._addCheck({
            kind: "cuid2",
            ...errorUtil.errToObj(message)
        });
    }
    ulid(message) {
        return this._addCheck({
            kind: "ulid",
            ...errorUtil.errToObj(message)
        });
    }
    base64(message) {
        return this._addCheck({
            kind: "base64",
            ...errorUtil.errToObj(message)
        });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...errorUtil.errToObj(message)
        });
    }
    jwt(options) {
        return this._addCheck({
            kind: "jwt",
            ...errorUtil.errToObj(options)
        });
    }
    ip(options) {
        return this._addCheck({
            kind: "ip",
            ...errorUtil.errToObj(options)
        });
    }
    cidr(options) {
        return this._addCheck({
            kind: "cidr",
            ...errorUtil.errToObj(options)
        });
    }
    datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
    }
    date(message) {
        return this._addCheck({
            kind: "date",
            message
        });
    }
    time(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "time",
                precision: null,
                message: options
            });
        }
        return this._addCheck({
            kind: "time",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
    }
    duration(message) {
        return this._addCheck({
            kind: "duration",
            ...errorUtil.errToObj(message)
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message)
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil.errToObj(message)
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil.errToObj(message)
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message)
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message)
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message)
        });
    }
    /**
     * Equivalent to `.min(1)`
     */ nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "trim"
                }
            ]
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toLowerCase"
                }
            ]
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toUpperCase"
                }
            ]
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch)=>ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch)=>ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch)=>ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch)=>ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch)=>ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch)=>ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch)=>ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch)=>ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch)=>ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch)=>ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch)=>ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch)=>ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch)=>ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params)=>{
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor(){
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks){
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message)
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message)
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message)
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message)
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message)
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch)=>ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
                return true;
            } else if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            } else if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params)=>{
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
    });
};
class ZodBigInt extends ZodType {
    constructor(){
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            try {
                input.data = BigInt(input.data);
            } catch (_a) {
                return this._getInvalidInput(input);
            }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            return this._getInvalidInput(input);
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks){
            if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx.parsedType
        });
        return INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message)
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params)=>{
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params)=>{
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime())
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message)
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message)
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params)=>{
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params)=>{
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params)=>{
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params)=>{
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
    });
};
class ZodAny extends ZodType {
    constructor(){
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params)=>{
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
    });
};
class ZodUnknown extends ZodType {
    constructor(){
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params)=>{
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType
        });
        return INVALID;
    }
}
ZodNever.create = (params)=>{
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params)=>{
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: tooSmall ? def.exactLength.value : undefined,
                    maximum: tooBig ? def.exactLength.value : undefined,
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([
                ...ctx.data
            ].map((item, i)=>{
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result)=>{
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [
            ...ctx.data
        ].map((item, i)=>{
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: {
                value: minLength,
                message: errorUtil.toString(message)
            }
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: {
                value: maxLength,
                message: errorUtil.toString(message)
            }
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: {
                value: len,
                message: errorUtil.toString(message)
            }
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params)=>{
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for(const key in schema.shape){
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: ()=>newShape
        });
    } else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element)
        });
    } else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
    } else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor(){
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */ this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */ this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = {
            shape,
            keys
        };
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for(const key in ctx.data){
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys){
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: {
                    status: "valid",
                    value: key
                },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys){
                    pairs.push({
                        key: {
                            status: "valid",
                            value: key
                        },
                        value: {
                            status: "valid",
                            value: ctx.data[key]
                        }
                    });
                }
            } else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys
                    });
                    status.dirty();
                }
            } else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        } else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys){
                const value = ctx.data[key];
                pairs.push({
                    key: {
                        status: "valid",
                        value: key
                    },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve().then(async ()=>{
                const syncPairs = [];
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet
                    });
                }
                return syncPairs;
            }).then((syncPairs)=>{
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        } else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...message !== undefined ? {
                errorMap: (issue, ctx)=>{
                    var _a, _b, _c, _d;
                    const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                    if (issue.code === "unrecognized_keys") return {
                        message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                    };
                    return {
                        message: defaultError
                    };
                }
            } : {}
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...augmentation
                })
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */ merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...merging._def.shape()
                }),
            typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({
            [key]: schema
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index
        });
    }
    pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key)=>{
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key)=>{
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    /**
     * @deprecated
     */ deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key)=>{
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            } else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key)=>{
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            } else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while(newField instanceof ZodOptional){
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    keyof() {
        return createZodEnum(util.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params)=>{
    return new ZodObject({
        shape: ()=>shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
ZodObject.strictCreate = (shape, params)=>{
    return new ZodObject({
        shape: ()=>shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
ZodObject.lazycreate = (shape, params)=>{
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results){
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results){
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option)=>{
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx
                    }),
                    ctx: childCtx
                };
            })).then(handleResults);
        } else {
            let dirty = undefined;
            const issues = [];
            for (const option of options){
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    },
                    parent: null
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx
                });
                if (result.status === "valid") {
                    return result;
                } else if (result.status === "dirty" && !dirty) {
                    dirty = {
                        result,
                        ctx: childCtx
                    };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues)=>new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params)=>{
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type)=>{
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
        return [
            type.value
        ];
    } else if (type instanceof ZodEnum) {
        return type.options;
    } else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
        return [
            undefined
        ];
    } else if (type instanceof ZodNull) {
        return [
            null
        ];
    } else if (type instanceof ZodOptional) {
        return [
            undefined,
            ...getDiscriminator(type.unwrap())
        ];
    } else if (type instanceof ZodNullable) {
        return [
            null,
            ...getDiscriminator(type.unwrap())
        ];
    } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
    } else {
        return [];
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [
                    discriminator
                ]
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
        } else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */ static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options){
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues){
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params)
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return {
            valid: true,
            data: a
        };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util.objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);
        const newObj = {
            ...a,
            ...b
        };
        for (const key of sharedKeys){
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return {
                    valid: false
                };
            }
            newObj[key] = sharedValue.data;
        }
        return {
            valid: true,
            data: newObj
        };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return {
                valid: false
            };
        }
        const newArray = [];
        for(let index = 0; index < a.length; index++){
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return {
                    valid: false
                };
            }
            newArray.push(sharedValue.data);
        }
        return {
            valid: true,
            data: newArray
        };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
        return {
            valid: true,
            data: a
        };
    } else {
        return {
            valid: false
        };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight)=>{
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return {
                status: status.value,
                value: merged.data
            };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                })
            ]).then(([left, right])=>handleParsed(left, right));
        } else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }));
        }
    }
}
ZodIntersection.create = (left, right, params)=>{
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            status.dirty();
        }
        const items = [
            ...ctx.data
        ].map((item, itemIndex)=>{
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema) return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x)=>!!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results)=>{
                return ParseStatus.mergeArray(status, results);
            });
        } else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest
        });
    }
}
ZodTuple.create = (schemas, params)=>{
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for(const key in ctx.data){
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third)
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second)
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [
            ...ctx.data.entries()
        ].map(([key, value], index)=>{
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                    index,
                    "key"
                ])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
                    index,
                    "value"
                ]))
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async ()=>{
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return {
                    status: status.value,
                    value: finalMap
                };
            });
        } else {
            const finalMap = new Map();
            for (const pair of pairs){
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return {
                status: status.value,
                value: finalMap
            };
        }
    }
}
ZodMap.create = (keyType, valueType, params)=>{
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements){
                if (element.status === "aborted") return INVALID;
                if (element.status === "dirty") status.dirty();
                parsedSet.add(element.value);
            }
            return {
                status: status.value,
                value: parsedSet
            };
        }
        const elements = [
            ...ctx.data.values()
        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements)=>finalizeSet(elements));
        } else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: {
                value: minSize,
                message: errorUtil.toString(message)
            }
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: {
                value: maxSize,
                message: errorUtil.toString(message)
            }
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params)=>{
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
    });
};
class ZodFunction extends ZodType {
    constructor(){
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap
                ].filter((x)=>!!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error
                }
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap
                ].filter((x)=>!!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error
                }
            });
        }
        const params = {
            errorMap: ctx.common.contextualErrorMap
        };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(async function(...args) {
                const error = new ZodError([]);
                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        } else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(function(...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([
                        makeArgsIssue(args, parsedArgs.error)
                    ]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([
                        makeReturnsIssue(result, parsedReturns.error)
                    ]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params)
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
    }
}
ZodLazy.create = (getter, params)=>{
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value
            });
            return INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params)=>{
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
    });
}
class ZodEnum extends ZodType {
    constructor(){
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type
            });
            return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values){
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values){
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values){
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {
            ...this._def,
            ...newDef
        });
    }
}
_ZodEnum_cache = new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    constructor(){
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type
            });
            return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
_ZodNativeEnum_cache = new WeakMap();
ZodNativeEnum.create = (values, params)=>{
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data)=>{
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap
            });
        }));
    }
}
ZodPromise.create = (schema, params)=>{
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg)=>{
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                } else {
                    status.dirty();
                }
            },
            get path () {
                return ctx.path;
            }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
                return Promise.resolve(processed).then(async (processed)=>{
                    if (status.value === "aborted") return INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx
                    });
                    if (result.status === "aborted") return INVALID;
                    if (result.status === "dirty") return DIRTY(result.value);
                    if (status.value === "dirty") return DIRTY(result.value);
                    return result;
                });
            } else {
                if (status.value === "aborted") return INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx
                });
                if (result.status === "aborted") return INVALID;
                if (result.status === "dirty") return DIRTY(result.value);
                if (status.value === "dirty") return DIRTY(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc)=>{
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inner.status === "aborted") return INVALID;
                if (inner.status === "dirty") status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return {
                    status: status.value,
                    value: inner.value
                };
            } else {
                return this._def.schema._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }).then((inner)=>{
                    if (inner.status === "aborted") return INVALID;
                    if (inner.status === "dirty") status.dirty();
                    return executeRefinement(inner.value).then(()=>{
                        return {
                            status: status.value,
                            value: inner.value
                        };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (!isValid(base)) return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return {
                    status: status.value,
                    value: result
                };
            } else {
                return this._def.schema._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                }).then((base)=>{
                    if (!isValid(base)) return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                            status: status.value,
                            value: result
                        }));
                });
            }
        }
        util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params)=>{
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params)=>{
    return new ZodEffects({
        schema,
        effect: {
            type: "preprocess",
            transform: preprocess
        },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params)=>{
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params)=>{
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params)=>{
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : ()=>params.default,
        ...processCreateParams(params)
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: []
            }
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx
            }
        });
        if (isAsync(result)) {
            return result.then((result)=>{
                return {
                    status: "valid",
                    value: result.status === "valid" ? result.value : this._def.catchValue({
                        get error () {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data
                    })
                };
            });
        } else {
            return {
                status: "valid",
                value: result.status === "valid" ? result.value : this._def.catchValue({
                    get error () {
                        return new ZodError(newCtx.common.issues);
                    },
                    input: newCtx.data
                })
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params)=>{
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : ()=>params.catch,
        ...processCreateParams(params)
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType
            });
            return INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
}
ZodNaN.create = (params)=>{
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async ()=>{
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inResult.status === "aborted") return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                } else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx
                    });
                }
            };
            return handleAsync();
        } else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
            if (inResult.status === "aborted") return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value
                };
            } else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data)=>{
            if (isValid(data)) {
                data.value = Object.freeze(data.value);
            }
            return data;
        };
        return isAsync(result) ? result.then((data)=>freeze(data)) : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params)=>{
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
    });
};
////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      z.custom      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? {
        message: params
    } : params;
    const p2 = typeof p === "string" ? {
        message: p
    } : p;
    return p2;
}
function custom(check, _params = {}, /**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */ fatal) {
    if (check) return ZodAny.create().superRefine((data, ctx)=>{
        var _a, _b;
        const r = check(data);
        if (r instanceof Promise) {
            return r.then((r)=>{
                var _a, _b;
                if (!r) {
                    const params = cleanParams(_params, data);
                    const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                    ctx.addIssue({
                        code: "custom",
                        ...params,
                        fatal: _fatal
                    });
                }
            });
        }
        if (!r) {
            const params = cleanParams(_params, data);
            const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            ctx.addIssue({
                code: "custom",
                ...params,
                fatal: _fatal
            });
        }
        return;
    });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`
})=>custom((data)=>data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = ()=>stringType().optional();
const onumber = ()=>numberType().optional();
const oboolean = ()=>booleanType().optional();
const coerce = {
    string: (arg)=>ZodString.create({
            ...arg,
            coerce: true
        }),
    number: (arg)=>ZodNumber.create({
            ...arg,
            coerce: true
        }),
    boolean: (arg)=>ZodBoolean.create({
            ...arg,
            coerce: true
        }),
    bigint: (arg)=>ZodBigInt.create({
            ...arg,
            coerce: true
        }),
    date: (arg)=>ZodDate.create({
            ...arg,
            coerce: true
        })
};
const NEVER = INVALID;
var z = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap: setErrorMap,
    getErrorMap: getErrorMap,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    get util () {
        return util;
    },
    get objectUtil () {
        return objectUtil;
    },
    ZodParsedType: ZodParsedType,
    getParsedType: getParsedType,
    ZodType: ZodType,
    datetimeRegex: datetimeRegex,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodSymbol: ZodSymbol,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodCatch: ZodCatch,
    ZodNaN: ZodNaN,
    BRAND: BRAND,
    ZodBranded: ZodBranded,
    ZodPipeline: ZodPipeline,
    ZodReadonly: ZodReadonly,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () {
        return ZodFirstPartyTypeKind;
    },
    coerce: coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    NEVER: NEVER,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError
});
;
}}),
"[project]/node_modules/clsx/dist/clsx.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "clsx": (()=>clsx),
    "default": (()=>__TURBOPACK__default__export__)
});
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}}),
"[project]/node_modules/tailwind-merge/dist/bundle-mjs.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createTailwindMerge": (()=>createTailwindMerge),
    "extendTailwindMerge": (()=>extendTailwindMerge),
    "fromTheme": (()=>fromTheme),
    "getDefaultConfig": (()=>getDefaultConfig),
    "mergeConfigs": (()=>mergeConfigs),
    "twJoin": (()=>twJoin),
    "twMerge": (()=>twMerge),
    "validators": (()=>validators)
});
const CLASS_PART_SEPARATOR = '-';
const createClassGroupUtils = (config)=>{
    const classMap = createClassMap(config);
    const { conflictingClassGroups, conflictingClassGroupModifiers } = config;
    const getClassGroupId = (className)=>{
        const classParts = className.split(CLASS_PART_SEPARATOR);
        // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
        if (classParts[0] === '' && classParts.length !== 1) {
            classParts.shift();
        }
        return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
    };
    const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier)=>{
        const conflicts = conflictingClassGroups[classGroupId] || [];
        if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
            return [
                ...conflicts,
                ...conflictingClassGroupModifiers[classGroupId]
            ];
        }
        return conflicts;
    };
    return {
        getClassGroupId,
        getConflictingClassGroupIds
    };
};
const getGroupRecursive = (classParts, classPartObject)=>{
    if (classParts.length === 0) {
        return classPartObject.classGroupId;
    }
    const currentClassPart = classParts[0];
    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
    const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;
    if (classGroupFromNextClassPart) {
        return classGroupFromNextClassPart;
    }
    if (classPartObject.validators.length === 0) {
        return undefined;
    }
    const classRest = classParts.join(CLASS_PART_SEPARATOR);
    return classPartObject.validators.find(({ validator })=>validator(classRest))?.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className)=>{
    if (arbitraryPropertyRegex.test(className)) {
        const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
        const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(':'));
        if (property) {
            // I use two dots here because one dot is used as prefix for class groups in plugins
            return 'arbitrary..' + property;
        }
    }
};
/**
 * Exported for testing only
 */ const createClassMap = (config)=>{
    const { theme, classGroups } = config;
    const classMap = {
        nextPart: new Map(),
        validators: []
    };
    for(const classGroupId in classGroups){
        processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
    }
    return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme)=>{
    classGroup.forEach((classDefinition)=>{
        if (typeof classDefinition === 'string') {
            const classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);
            classPartObjectToEdit.classGroupId = classGroupId;
            return;
        }
        if (typeof classDefinition === 'function') {
            if (isThemeGetter(classDefinition)) {
                processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
                return;
            }
            classPartObject.validators.push({
                validator: classDefinition,
                classGroupId
            });
            return;
        }
        Object.entries(classDefinition).forEach(([key, classGroup])=>{
            processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);
        });
    });
};
const getPart = (classPartObject, path)=>{
    let currentClassPartObject = classPartObject;
    path.split(CLASS_PART_SEPARATOR).forEach((pathPart)=>{
        if (!currentClassPartObject.nextPart.has(pathPart)) {
            currentClassPartObject.nextPart.set(pathPart, {
                nextPart: new Map(),
                validators: []
            });
        }
        currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
    });
    return currentClassPartObject;
};
const isThemeGetter = (func)=>func.isThemeGetter;
// LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance
const createLruCache = (maxCacheSize)=>{
    if (maxCacheSize < 1) {
        return {
            get: ()=>undefined,
            set: ()=>{}
        };
    }
    let cacheSize = 0;
    let cache = new Map();
    let previousCache = new Map();
    const update = (key, value)=>{
        cache.set(key, value);
        cacheSize++;
        if (cacheSize > maxCacheSize) {
            cacheSize = 0;
            previousCache = cache;
            cache = new Map();
        }
    };
    return {
        get (key) {
            let value = cache.get(key);
            if (value !== undefined) {
                return value;
            }
            if ((value = previousCache.get(key)) !== undefined) {
                update(key, value);
                return value;
            }
        },
        set (key, value) {
            if (cache.has(key)) {
                cache.set(key, value);
            } else {
                update(key, value);
            }
        }
    };
};
const IMPORTANT_MODIFIER = '!';
const MODIFIER_SEPARATOR = ':';
const MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
const createParseClassName = (config)=>{
    const { prefix, experimentalParseClassName } = config;
    /**
   * Parse class name into parts.
   *
   * Inspired by `splitAtTopLevelOnly` used in Tailwind CSS
   * @see https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
   */ let parseClassName = (className)=>{
        const modifiers = [];
        let bracketDepth = 0;
        let parenDepth = 0;
        let modifierStart = 0;
        let postfixModifierPosition;
        for(let index = 0; index < className.length; index++){
            let currentCharacter = className[index];
            if (bracketDepth === 0 && parenDepth === 0) {
                if (currentCharacter === MODIFIER_SEPARATOR) {
                    modifiers.push(className.slice(modifierStart, index));
                    modifierStart = index + MODIFIER_SEPARATOR_LENGTH;
                    continue;
                }
                if (currentCharacter === '/') {
                    postfixModifierPosition = index;
                    continue;
                }
            }
            if (currentCharacter === '[') {
                bracketDepth++;
            } else if (currentCharacter === ']') {
                bracketDepth--;
            } else if (currentCharacter === '(') {
                parenDepth++;
            } else if (currentCharacter === ')') {
                parenDepth--;
            }
        }
        const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
        const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
        const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
        const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : undefined;
        return {
            modifiers,
            hasImportantModifier,
            baseClassName,
            maybePostfixModifierPosition
        };
    };
    if (prefix) {
        const fullPrefix = prefix + MODIFIER_SEPARATOR;
        const parseClassNameOriginal = parseClassName;
        parseClassName = (className)=>className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {
                isExternal: true,
                modifiers: [],
                hasImportantModifier: false,
                baseClassName: className,
                maybePostfixModifierPosition: undefined
            };
    }
    if (experimentalParseClassName) {
        const parseClassNameOriginal = parseClassName;
        parseClassName = (className)=>experimentalParseClassName({
                className,
                parseClassName: parseClassNameOriginal
            });
    }
    return parseClassName;
};
const stripImportantModifier = (baseClassName)=>{
    if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
        return baseClassName.substring(0, baseClassName.length - 1);
    }
    /**
   * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
   * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
   */ if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
        return baseClassName.substring(1);
    }
    return baseClassName;
};
/**
 * Sorts modifiers according to following schema:
 * - Predefined modifiers are sorted alphabetically
 * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it
 */ const createSortModifiers = (config)=>{
    const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier)=>[
            modifier,
            true
        ]));
    const sortModifiers = (modifiers)=>{
        if (modifiers.length <= 1) {
            return modifiers;
        }
        const sortedModifiers = [];
        let unsortedModifiers = [];
        modifiers.forEach((modifier)=>{
            const isPositionSensitive = modifier[0] === '[' || orderSensitiveModifiers[modifier];
            if (isPositionSensitive) {
                sortedModifiers.push(...unsortedModifiers.sort(), modifier);
                unsortedModifiers = [];
            } else {
                unsortedModifiers.push(modifier);
            }
        });
        sortedModifiers.push(...unsortedModifiers.sort());
        return sortedModifiers;
    };
    return sortModifiers;
};
const createConfigUtils = (config)=>({
        cache: createLruCache(config.cacheSize),
        parseClassName: createParseClassName(config),
        sortModifiers: createSortModifiers(config),
        ...createClassGroupUtils(config)
    });
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils)=>{
    const { parseClassName, getClassGroupId, getConflictingClassGroupIds, sortModifiers } = configUtils;
    /**
   * Set of classGroupIds in following format:
   * `{importantModifier}{variantModifiers}{classGroupId}`
   * @example 'float'
   * @example 'hover:focus:bg-color'
   * @example 'md:!pr'
   */ const classGroupsInConflict = [];
    const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
    let result = '';
    for(let index = classNames.length - 1; index >= 0; index -= 1){
        const originalClassName = classNames[index];
        const { isExternal, modifiers, hasImportantModifier, baseClassName, maybePostfixModifierPosition } = parseClassName(originalClassName);
        if (isExternal) {
            result = originalClassName + (result.length > 0 ? ' ' + result : result);
            continue;
        }
        let hasPostfixModifier = !!maybePostfixModifierPosition;
        let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
        if (!classGroupId) {
            if (!hasPostfixModifier) {
                // Not a Tailwind class
                result = originalClassName + (result.length > 0 ? ' ' + result : result);
                continue;
            }
            classGroupId = getClassGroupId(baseClassName);
            if (!classGroupId) {
                // Not a Tailwind class
                result = originalClassName + (result.length > 0 ? ' ' + result : result);
                continue;
            }
            hasPostfixModifier = false;
        }
        const variantModifier = sortModifiers(modifiers).join(':');
        const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
        const classId = modifierId + classGroupId;
        if (classGroupsInConflict.includes(classId)) {
            continue;
        }
        classGroupsInConflict.push(classId);
        const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
        for(let i = 0; i < conflictGroups.length; ++i){
            const group = conflictGroups[i];
            classGroupsInConflict.push(modifierId + group);
        }
        // Tailwind class not in conflict
        result = originalClassName + (result.length > 0 ? ' ' + result : result);
    }
    return result;
};
/**
 * The code in this file is copied from https://github.com/lukeed/clsx and modified to suit the needs of tailwind-merge better.
 *
 * Specifically:
 * - Runtime code from https://github.com/lukeed/clsx/blob/v1.2.1/src/index.js
 * - TypeScript types from https://github.com/lukeed/clsx/blob/v1.2.1/clsx.d.ts
 *
 * Original code has MIT license: Copyright (c) Luke Edwards <luke.edwards05@gmail.com> (lukeed.com)
 */ function twJoin() {
    let index = 0;
    let argument;
    let resolvedValue;
    let string = '';
    while(index < arguments.length){
        if (argument = arguments[index++]) {
            if (resolvedValue = toValue(argument)) {
                string && (string += ' ');
                string += resolvedValue;
            }
        }
    }
    return string;
}
const toValue = (mix)=>{
    if (typeof mix === 'string') {
        return mix;
    }
    let resolvedValue;
    let string = '';
    for(let k = 0; k < mix.length; k++){
        if (mix[k]) {
            if (resolvedValue = toValue(mix[k])) {
                string && (string += ' ');
                string += resolvedValue;
            }
        }
    }
    return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
    let configUtils;
    let cacheGet;
    let cacheSet;
    let functionToCall = initTailwindMerge;
    function initTailwindMerge(classList) {
        const config = createConfigRest.reduce((previousConfig, createConfigCurrent)=>createConfigCurrent(previousConfig), createConfigFirst());
        configUtils = createConfigUtils(config);
        cacheGet = configUtils.cache.get;
        cacheSet = configUtils.cache.set;
        functionToCall = tailwindMerge;
        return tailwindMerge(classList);
    }
    function tailwindMerge(classList) {
        const cachedResult = cacheGet(classList);
        if (cachedResult) {
            return cachedResult;
        }
        const result = mergeClassList(classList, configUtils);
        cacheSet(classList, result);
        return result;
    }
    return function callTailwindMerge() {
        return functionToCall(twJoin.apply(null, arguments));
    };
}
const fromTheme = (key)=>{
    const themeGetter = (theme)=>theme[key] || [];
    themeGetter.isThemeGetter = true;
    return themeGetter;
};
const arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
const arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
const fractionRegex = /^\d+\/\d+$/;
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
// Shadow always begins with x and y offset separated by underscore optionally prepended by inset
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isFraction = (value)=>fractionRegex.test(value);
const isNumber = (value)=>Boolean(value) && !Number.isNaN(Number(value));
const isInteger = (value)=>Boolean(value) && Number.isInteger(Number(value));
const isPercent = (value)=>value.endsWith('%') && isNumber(value.slice(0, -1));
const isTshirtSize = (value)=>tshirtUnitRegex.test(value);
const isAny = ()=>true;
const isLengthOnly = (value)=>// `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
    // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
    // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
    lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
const isNever = ()=>false;
const isShadow = (value)=>shadowRegex.test(value);
const isImage = (value)=>imageRegex.test(value);
const isAnyNonArbitrary = (value)=>!isArbitraryValue(value) && !isArbitraryVariable(value);
const isArbitrarySize = (value)=>getIsArbitraryValue(value, isLabelSize, isNever);
const isArbitraryValue = (value)=>arbitraryValueRegex.test(value);
const isArbitraryLength = (value)=>getIsArbitraryValue(value, isLabelLength, isLengthOnly);
const isArbitraryNumber = (value)=>getIsArbitraryValue(value, isLabelNumber, isNumber);
const isArbitraryPosition = (value)=>getIsArbitraryValue(value, isLabelPosition, isNever);
const isArbitraryImage = (value)=>getIsArbitraryValue(value, isLabelImage, isImage);
const isArbitraryShadow = (value)=>getIsArbitraryValue(value, isNever, isShadow);
const isArbitraryVariable = (value)=>arbitraryVariableRegex.test(value);
const isArbitraryVariableLength = (value)=>getIsArbitraryVariable(value, isLabelLength);
const isArbitraryVariableFamilyName = (value)=>getIsArbitraryVariable(value, isLabelFamilyName);
const isArbitraryVariablePosition = (value)=>getIsArbitraryVariable(value, isLabelPosition);
const isArbitraryVariableSize = (value)=>getIsArbitraryVariable(value, isLabelSize);
const isArbitraryVariableImage = (value)=>getIsArbitraryVariable(value, isLabelImage);
const isArbitraryVariableShadow = (value)=>getIsArbitraryVariable(value, isLabelShadow, true);
// Helpers
const getIsArbitraryValue = (value, testLabel, testValue)=>{
    const result = arbitraryValueRegex.exec(value);
    if (result) {
        if (result[1]) {
            return testLabel(result[1]);
        }
        return testValue(result[2]);
    }
    return false;
};
const getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false)=>{
    const result = arbitraryVariableRegex.exec(value);
    if (result) {
        if (result[1]) {
            return testLabel(result[1]);
        }
        return shouldMatchNoLabel;
    }
    return false;
};
// Labels
const isLabelPosition = (label)=>label === 'position';
const imageLabels = /*#__PURE__*/ new Set([
    'image',
    'url'
]);
const isLabelImage = (label)=>imageLabels.has(label);
const sizeLabels = /*#__PURE__*/ new Set([
    'length',
    'size',
    'percentage'
]);
const isLabelSize = (label)=>sizeLabels.has(label);
const isLabelLength = (label)=>label === 'length';
const isLabelNumber = (label)=>label === 'number';
const isLabelFamilyName = (label)=>label === 'family-name';
const isLabelShadow = (label)=>label === 'shadow';
const validators = /*#__PURE__*/ Object.defineProperty({
    __proto__: null,
    isAny,
    isAnyNonArbitrary,
    isArbitraryImage,
    isArbitraryLength,
    isArbitraryNumber,
    isArbitraryPosition,
    isArbitraryShadow,
    isArbitrarySize,
    isArbitraryValue,
    isArbitraryVariable,
    isArbitraryVariableFamilyName,
    isArbitraryVariableImage,
    isArbitraryVariableLength,
    isArbitraryVariablePosition,
    isArbitraryVariableShadow,
    isArbitraryVariableSize,
    isFraction,
    isInteger,
    isNumber,
    isPercent,
    isTshirtSize
}, Symbol.toStringTag, {
    value: 'Module'
});
const getDefaultConfig = ()=>{
    /**
   * Theme getters for theme variable namespaces
   * @see https://tailwindcss.com/docs/theme#theme-variable-namespaces
   */ /***/ const themeColor = fromTheme('color');
    const themeFont = fromTheme('font');
    const themeText = fromTheme('text');
    const themeFontWeight = fromTheme('font-weight');
    const themeTracking = fromTheme('tracking');
    const themeLeading = fromTheme('leading');
    const themeBreakpoint = fromTheme('breakpoint');
    const themeContainer = fromTheme('container');
    const themeSpacing = fromTheme('spacing');
    const themeRadius = fromTheme('radius');
    const themeShadow = fromTheme('shadow');
    const themeInsetShadow = fromTheme('inset-shadow');
    const themeDropShadow = fromTheme('drop-shadow');
    const themeBlur = fromTheme('blur');
    const themePerspective = fromTheme('perspective');
    const themeAspect = fromTheme('aspect');
    const themeEase = fromTheme('ease');
    const themeAnimate = fromTheme('animate');
    /**
   * Helpers to avoid repeating the same scales
   *
   * We use functions that create a new array every time they're called instead of static arrays.
   * This ensures that users who modify any scale by mutating the array (e.g. with `array.push(element)`) don't accidentally mutate arrays in other parts of the config.
   */ /***/ const scaleBreak = ()=>[
            'auto',
            'avoid',
            'all',
            'avoid-page',
            'page',
            'left',
            'right',
            'column'
        ];
    const scalePosition = ()=>[
            'bottom',
            'center',
            'left',
            'left-bottom',
            'left-top',
            'right',
            'right-bottom',
            'right-top',
            'top'
        ];
    const scaleOverflow = ()=>[
            'auto',
            'hidden',
            'clip',
            'visible',
            'scroll'
        ];
    const scaleOverscroll = ()=>[
            'auto',
            'contain',
            'none'
        ];
    const scaleUnambiguousSpacing = ()=>[
            isArbitraryVariable,
            isArbitraryValue,
            themeSpacing
        ];
    const scaleInset = ()=>[
            isFraction,
            'full',
            'auto',
            ...scaleUnambiguousSpacing()
        ];
    const scaleGridTemplateColsRows = ()=>[
            isInteger,
            'none',
            'subgrid',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGridColRowStartAndEnd = ()=>[
            'auto',
            {
                span: [
                    'full',
                    isInteger,
                    isArbitraryVariable,
                    isArbitraryValue
                ]
            },
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGridColRowStartOrEnd = ()=>[
            isInteger,
            'auto',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGridAutoColsRows = ()=>[
            'auto',
            'min',
            'max',
            'fr',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleAlignPrimaryAxis = ()=>[
            'start',
            'end',
            'center',
            'between',
            'around',
            'evenly',
            'stretch',
            'baseline'
        ];
    const scaleAlignSecondaryAxis = ()=>[
            'start',
            'end',
            'center',
            'stretch'
        ];
    const scaleMargin = ()=>[
            'auto',
            ...scaleUnambiguousSpacing()
        ];
    const scaleSizing = ()=>[
            isFraction,
            'auto',
            'full',
            'dvw',
            'dvh',
            'lvw',
            'lvh',
            'svw',
            'svh',
            'min',
            'max',
            'fit',
            ...scaleUnambiguousSpacing()
        ];
    const scaleColor = ()=>[
            themeColor,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleGradientStopPosition = ()=>[
            isPercent,
            isArbitraryLength
        ];
    const scaleRadius = ()=>[
            // Deprecated since Tailwind CSS v4.0.0
            '',
            'none',
            'full',
            themeRadius,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleBorderWidth = ()=>[
            '',
            isNumber,
            isArbitraryVariableLength,
            isArbitraryLength
        ];
    const scaleLineStyle = ()=>[
            'solid',
            'dashed',
            'dotted',
            'double'
        ];
    const scaleBlendMode = ()=>[
            'normal',
            'multiply',
            'screen',
            'overlay',
            'darken',
            'lighten',
            'color-dodge',
            'color-burn',
            'hard-light',
            'soft-light',
            'difference',
            'exclusion',
            'hue',
            'saturation',
            'color',
            'luminosity'
        ];
    const scaleBlur = ()=>[
            // Deprecated since Tailwind CSS v4.0.0
            '',
            'none',
            themeBlur,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleOrigin = ()=>[
            'center',
            'top',
            'top-right',
            'right',
            'bottom-right',
            'bottom',
            'bottom-left',
            'left',
            'top-left',
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleRotate = ()=>[
            'none',
            isNumber,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleScale = ()=>[
            'none',
            isNumber,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleSkew = ()=>[
            isNumber,
            isArbitraryVariable,
            isArbitraryValue
        ];
    const scaleTranslate = ()=>[
            isFraction,
            'full',
            ...scaleUnambiguousSpacing()
        ];
    return {
        cacheSize: 500,
        theme: {
            animate: [
                'spin',
                'ping',
                'pulse',
                'bounce'
            ],
            aspect: [
                'video'
            ],
            blur: [
                isTshirtSize
            ],
            breakpoint: [
                isTshirtSize
            ],
            color: [
                isAny
            ],
            container: [
                isTshirtSize
            ],
            'drop-shadow': [
                isTshirtSize
            ],
            ease: [
                'in',
                'out',
                'in-out'
            ],
            font: [
                isAnyNonArbitrary
            ],
            'font-weight': [
                'thin',
                'extralight',
                'light',
                'normal',
                'medium',
                'semibold',
                'bold',
                'extrabold',
                'black'
            ],
            'inset-shadow': [
                isTshirtSize
            ],
            leading: [
                'none',
                'tight',
                'snug',
                'normal',
                'relaxed',
                'loose'
            ],
            perspective: [
                'dramatic',
                'near',
                'normal',
                'midrange',
                'distant',
                'none'
            ],
            radius: [
                isTshirtSize
            ],
            shadow: [
                isTshirtSize
            ],
            spacing: [
                'px',
                isNumber
            ],
            text: [
                isTshirtSize
            ],
            tracking: [
                'tighter',
                'tight',
                'normal',
                'wide',
                'wider',
                'widest'
            ]
        },
        classGroups: {
            // --------------
            // --- Layout ---
            // --------------
            /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */ aspect: [
                {
                    aspect: [
                        'auto',
                        'square',
                        isFraction,
                        isArbitraryValue,
                        isArbitraryVariable,
                        themeAspect
                    ]
                }
            ],
            /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */ container: [
                'container'
            ],
            /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */ columns: [
                {
                    columns: [
                        isNumber,
                        isArbitraryValue,
                        isArbitraryVariable,
                        themeContainer
                    ]
                }
            ],
            /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */ 'break-after': [
                {
                    'break-after': scaleBreak()
                }
            ],
            /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */ 'break-before': [
                {
                    'break-before': scaleBreak()
                }
            ],
            /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */ 'break-inside': [
                {
                    'break-inside': [
                        'auto',
                        'avoid',
                        'avoid-page',
                        'avoid-column'
                    ]
                }
            ],
            /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */ 'box-decoration': [
                {
                    'box-decoration': [
                        'slice',
                        'clone'
                    ]
                }
            ],
            /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */ box: [
                {
                    box: [
                        'border',
                        'content'
                    ]
                }
            ],
            /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */ display: [
                'block',
                'inline-block',
                'inline',
                'flex',
                'inline-flex',
                'table',
                'inline-table',
                'table-caption',
                'table-cell',
                'table-column',
                'table-column-group',
                'table-footer-group',
                'table-header-group',
                'table-row-group',
                'table-row',
                'flow-root',
                'grid',
                'inline-grid',
                'contents',
                'list-item',
                'hidden'
            ],
            /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */ sr: [
                'sr-only',
                'not-sr-only'
            ],
            /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */ float: [
                {
                    float: [
                        'right',
                        'left',
                        'none',
                        'start',
                        'end'
                    ]
                }
            ],
            /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */ clear: [
                {
                    clear: [
                        'left',
                        'right',
                        'both',
                        'none',
                        'start',
                        'end'
                    ]
                }
            ],
            /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */ isolation: [
                'isolate',
                'isolation-auto'
            ],
            /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */ 'object-fit': [
                {
                    object: [
                        'contain',
                        'cover',
                        'fill',
                        'none',
                        'scale-down'
                    ]
                }
            ],
            /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */ 'object-position': [
                {
                    object: [
                        ...scalePosition(),
                        isArbitraryValue,
                        isArbitraryVariable
                    ]
                }
            ],
            /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */ overflow: [
                {
                    overflow: scaleOverflow()
                }
            ],
            /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */ 'overflow-x': [
                {
                    'overflow-x': scaleOverflow()
                }
            ],
            /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */ 'overflow-y': [
                {
                    'overflow-y': scaleOverflow()
                }
            ],
            /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ overscroll: [
                {
                    overscroll: scaleOverscroll()
                }
            ],
            /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ 'overscroll-x': [
                {
                    'overscroll-x': scaleOverscroll()
                }
            ],
            /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */ 'overscroll-y': [
                {
                    'overscroll-y': scaleOverscroll()
                }
            ],
            /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */ position: [
                'static',
                'fixed',
                'absolute',
                'relative',
                'sticky'
            ],
            /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ inset: [
                {
                    inset: scaleInset()
                }
            ],
            /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ 'inset-x': [
                {
                    'inset-x': scaleInset()
                }
            ],
            /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ 'inset-y': [
                {
                    'inset-y': scaleInset()
                }
            ],
            /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ start: [
                {
                    start: scaleInset()
                }
            ],
            /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ end: [
                {
                    end: scaleInset()
                }
            ],
            /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ top: [
                {
                    top: scaleInset()
                }
            ],
            /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ right: [
                {
                    right: scaleInset()
                }
            ],
            /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ bottom: [
                {
                    bottom: scaleInset()
                }
            ],
            /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */ left: [
                {
                    left: scaleInset()
                }
            ],
            /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */ visibility: [
                'visible',
                'invisible',
                'collapse'
            ],
            /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */ z: [
                {
                    z: [
                        isInteger,
                        'auto',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // ------------------------
            // --- Flexbox and Grid ---
            // ------------------------
            /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */ basis: [
                {
                    basis: [
                        isFraction,
                        'full',
                        'auto',
                        themeContainer,
                        ...scaleUnambiguousSpacing()
                    ]
                }
            ],
            /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */ 'flex-direction': [
                {
                    flex: [
                        'row',
                        'row-reverse',
                        'col',
                        'col-reverse'
                    ]
                }
            ],
            /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */ 'flex-wrap': [
                {
                    flex: [
                        'nowrap',
                        'wrap',
                        'wrap-reverse'
                    ]
                }
            ],
            /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */ flex: [
                {
                    flex: [
                        isNumber,
                        isFraction,
                        'auto',
                        'initial',
                        'none',
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */ grow: [
                {
                    grow: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */ shrink: [
                {
                    shrink: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */ order: [
                {
                    order: [
                        isInteger,
                        'first',
                        'last',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */ 'grid-cols': [
                {
                    'grid-cols': scaleGridTemplateColsRows()
                }
            ],
            /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */ 'col-start-end': [
                {
                    col: scaleGridColRowStartAndEnd()
                }
            ],
            /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */ 'col-start': [
                {
                    'col-start': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */ 'col-end': [
                {
                    'col-end': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */ 'grid-rows': [
                {
                    'grid-rows': scaleGridTemplateColsRows()
                }
            ],
            /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */ 'row-start-end': [
                {
                    row: scaleGridColRowStartAndEnd()
                }
            ],
            /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */ 'row-start': [
                {
                    'row-start': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */ 'row-end': [
                {
                    'row-end': scaleGridColRowStartOrEnd()
                }
            ],
            /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */ 'grid-flow': [
                {
                    'grid-flow': [
                        'row',
                        'col',
                        'dense',
                        'row-dense',
                        'col-dense'
                    ]
                }
            ],
            /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */ 'auto-cols': [
                {
                    'auto-cols': scaleGridAutoColsRows()
                }
            ],
            /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */ 'auto-rows': [
                {
                    'auto-rows': scaleGridAutoColsRows()
                }
            ],
            /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */ gap: [
                {
                    gap: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */ 'gap-x': [
                {
                    'gap-x': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */ 'gap-y': [
                {
                    'gap-y': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */ 'justify-content': [
                {
                    justify: [
                        ...scaleAlignPrimaryAxis(),
                        'normal'
                    ]
                }
            ],
            /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */ 'justify-items': [
                {
                    'justify-items': [
                        ...scaleAlignSecondaryAxis(),
                        'normal'
                    ]
                }
            ],
            /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */ 'justify-self': [
                {
                    'justify-self': [
                        'auto',
                        ...scaleAlignSecondaryAxis()
                    ]
                }
            ],
            /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */ 'align-content': [
                {
                    content: [
                        'normal',
                        ...scaleAlignPrimaryAxis()
                    ]
                }
            ],
            /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */ 'align-items': [
                {
                    items: [
                        ...scaleAlignSecondaryAxis(),
                        'baseline'
                    ]
                }
            ],
            /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */ 'align-self': [
                {
                    self: [
                        'auto',
                        ...scaleAlignSecondaryAxis(),
                        'baseline'
                    ]
                }
            ],
            /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */ 'place-content': [
                {
                    'place-content': scaleAlignPrimaryAxis()
                }
            ],
            /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */ 'place-items': [
                {
                    'place-items': [
                        ...scaleAlignSecondaryAxis(),
                        'baseline'
                    ]
                }
            ],
            /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */ 'place-self': [
                {
                    'place-self': [
                        'auto',
                        ...scaleAlignSecondaryAxis()
                    ]
                }
            ],
            // Spacing
            /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */ p: [
                {
                    p: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */ px: [
                {
                    px: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */ py: [
                {
                    py: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */ ps: [
                {
                    ps: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */ pe: [
                {
                    pe: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */ pt: [
                {
                    pt: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */ pr: [
                {
                    pr: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */ pb: [
                {
                    pb: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */ pl: [
                {
                    pl: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */ m: [
                {
                    m: scaleMargin()
                }
            ],
            /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */ mx: [
                {
                    mx: scaleMargin()
                }
            ],
            /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */ my: [
                {
                    my: scaleMargin()
                }
            ],
            /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */ ms: [
                {
                    ms: scaleMargin()
                }
            ],
            /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */ me: [
                {
                    me: scaleMargin()
                }
            ],
            /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */ mt: [
                {
                    mt: scaleMargin()
                }
            ],
            /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */ mr: [
                {
                    mr: scaleMargin()
                }
            ],
            /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */ mb: [
                {
                    mb: scaleMargin()
                }
            ],
            /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */ ml: [
                {
                    ml: scaleMargin()
                }
            ],
            /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-x': [
                {
                    'space-x': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-x-reverse': [
                'space-x-reverse'
            ],
            /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-y': [
                {
                    'space-y': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */ 'space-y-reverse': [
                'space-y-reverse'
            ],
            // --------------
            // --- Sizing ---
            // --------------
            /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */ size: [
                {
                    size: scaleSizing()
                }
            ],
            /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */ w: [
                {
                    w: [
                        themeContainer,
                        'screen',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */ 'min-w': [
                {
                    'min-w': [
                        themeContainer,
                        'screen',
                        /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ 'none',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */ 'max-w': [
                {
                    'max-w': [
                        themeContainer,
                        'screen',
                        'none',
                        /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ 'prose',
                        /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ {
                            screen: [
                                themeBreakpoint
                            ]
                        },
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */ h: [
                {
                    h: [
                        'screen',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */ 'min-h': [
                {
                    'min-h': [
                        'screen',
                        'none',
                        ...scaleSizing()
                    ]
                }
            ],
            /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */ 'max-h': [
                {
                    'max-h': [
                        'screen',
                        ...scaleSizing()
                    ]
                }
            ],
            // ------------------
            // --- Typography ---
            // ------------------
            /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */ 'font-size': [
                {
                    text: [
                        'base',
                        themeText,
                        isArbitraryVariableLength,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */ 'font-smoothing': [
                'antialiased',
                'subpixel-antialiased'
            ],
            /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */ 'font-style': [
                'italic',
                'not-italic'
            ],
            /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */ 'font-weight': [
                {
                    font: [
                        themeFontWeight,
                        isArbitraryVariable,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */ 'font-stretch': [
                {
                    'font-stretch': [
                        'ultra-condensed',
                        'extra-condensed',
                        'condensed',
                        'semi-condensed',
                        'normal',
                        'semi-expanded',
                        'expanded',
                        'extra-expanded',
                        'ultra-expanded',
                        isPercent,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */ 'font-family': [
                {
                    font: [
                        isArbitraryVariableFamilyName,
                        isArbitraryValue,
                        themeFont
                    ]
                }
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-normal': [
                'normal-nums'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-ordinal': [
                'ordinal'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-slashed-zero': [
                'slashed-zero'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-figure': [
                'lining-nums',
                'oldstyle-nums'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-spacing': [
                'proportional-nums',
                'tabular-nums'
            ],
            /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */ 'fvn-fraction': [
                'diagonal-fractions',
                'stacked-fractions'
            ],
            /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */ tracking: [
                {
                    tracking: [
                        themeTracking,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */ 'line-clamp': [
                {
                    'line-clamp': [
                        isNumber,
                        'none',
                        isArbitraryVariable,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */ leading: [
                {
                    leading: [
                        /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */ themeLeading,
                        ...scaleUnambiguousSpacing()
                    ]
                }
            ],
            /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */ 'list-image': [
                {
                    'list-image': [
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */ 'list-style-position': [
                {
                    list: [
                        'inside',
                        'outside'
                    ]
                }
            ],
            /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */ 'list-style-type': [
                {
                    list: [
                        'disc',
                        'decimal',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */ 'text-alignment': [
                {
                    text: [
                        'left',
                        'center',
                        'right',
                        'justify',
                        'start',
                        'end'
                    ]
                }
            ],
            /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */ 'placeholder-color': [
                {
                    placeholder: scaleColor()
                }
            ],
            /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */ 'text-color': [
                {
                    text: scaleColor()
                }
            ],
            /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */ 'text-decoration': [
                'underline',
                'overline',
                'line-through',
                'no-underline'
            ],
            /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */ 'text-decoration-style': [
                {
                    decoration: [
                        ...scaleLineStyle(),
                        'wavy'
                    ]
                }
            ],
            /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */ 'text-decoration-thickness': [
                {
                    decoration: [
                        isNumber,
                        'from-font',
                        'auto',
                        isArbitraryVariable,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */ 'text-decoration-color': [
                {
                    decoration: scaleColor()
                }
            ],
            /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */ 'underline-offset': [
                {
                    'underline-offset': [
                        isNumber,
                        'auto',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */ 'text-transform': [
                'uppercase',
                'lowercase',
                'capitalize',
                'normal-case'
            ],
            /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */ 'text-overflow': [
                'truncate',
                'text-ellipsis',
                'text-clip'
            ],
            /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */ 'text-wrap': [
                {
                    text: [
                        'wrap',
                        'nowrap',
                        'balance',
                        'pretty'
                    ]
                }
            ],
            /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */ indent: [
                {
                    indent: scaleUnambiguousSpacing()
                }
            ],
            /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */ 'vertical-align': [
                {
                    align: [
                        'baseline',
                        'top',
                        'middle',
                        'bottom',
                        'text-top',
                        'text-bottom',
                        'sub',
                        'super',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */ whitespace: [
                {
                    whitespace: [
                        'normal',
                        'nowrap',
                        'pre',
                        'pre-line',
                        'pre-wrap',
                        'break-spaces'
                    ]
                }
            ],
            /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */ break: [
                {
                    break: [
                        'normal',
                        'words',
                        'all',
                        'keep'
                    ]
                }
            ],
            /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */ hyphens: [
                {
                    hyphens: [
                        'none',
                        'manual',
                        'auto'
                    ]
                }
            ],
            /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */ content: [
                {
                    content: [
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // -------------------
            // --- Backgrounds ---
            // -------------------
            /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */ 'bg-attachment': [
                {
                    bg: [
                        'fixed',
                        'local',
                        'scroll'
                    ]
                }
            ],
            /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */ 'bg-clip': [
                {
                    'bg-clip': [
                        'border',
                        'padding',
                        'content',
                        'text'
                    ]
                }
            ],
            /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */ 'bg-origin': [
                {
                    'bg-origin': [
                        'border',
                        'padding',
                        'content'
                    ]
                }
            ],
            /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */ 'bg-position': [
                {
                    bg: [
                        ...scalePosition(),
                        isArbitraryVariablePosition,
                        isArbitraryPosition
                    ]
                }
            ],
            /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */ 'bg-repeat': [
                {
                    bg: [
                        'no-repeat',
                        {
                            repeat: [
                                '',
                                'x',
                                'y',
                                'space',
                                'round'
                            ]
                        }
                    ]
                }
            ],
            /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */ 'bg-size': [
                {
                    bg: [
                        'auto',
                        'cover',
                        'contain',
                        isArbitraryVariableSize,
                        isArbitrarySize
                    ]
                }
            ],
            /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */ 'bg-image': [
                {
                    bg: [
                        'none',
                        {
                            linear: [
                                {
                                    to: [
                                        't',
                                        'tr',
                                        'r',
                                        'br',
                                        'b',
                                        'bl',
                                        'l',
                                        'tl'
                                    ]
                                },
                                isInteger,
                                isArbitraryVariable,
                                isArbitraryValue
                            ],
                            radial: [
                                '',
                                isArbitraryVariable,
                                isArbitraryValue
                            ],
                            conic: [
                                isInteger,
                                isArbitraryVariable,
                                isArbitraryValue
                            ]
                        },
                        isArbitraryVariableImage,
                        isArbitraryImage
                    ]
                }
            ],
            /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */ 'bg-color': [
                {
                    bg: scaleColor()
                }
            ],
            /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-from-pos': [
                {
                    from: scaleGradientStopPosition()
                }
            ],
            /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-via-pos': [
                {
                    via: scaleGradientStopPosition()
                }
            ],
            /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-to-pos': [
                {
                    to: scaleGradientStopPosition()
                }
            ],
            /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-from': [
                {
                    from: scaleColor()
                }
            ],
            /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-via': [
                {
                    via: scaleColor()
                }
            ],
            /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */ 'gradient-to': [
                {
                    to: scaleColor()
                }
            ],
            // ---------------
            // --- Borders ---
            // ---------------
            /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */ rounded: [
                {
                    rounded: scaleRadius()
                }
            ],
            /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-s': [
                {
                    'rounded-s': scaleRadius()
                }
            ],
            /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-e': [
                {
                    'rounded-e': scaleRadius()
                }
            ],
            /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-t': [
                {
                    'rounded-t': scaleRadius()
                }
            ],
            /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-r': [
                {
                    'rounded-r': scaleRadius()
                }
            ],
            /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-b': [
                {
                    'rounded-b': scaleRadius()
                }
            ],
            /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-l': [
                {
                    'rounded-l': scaleRadius()
                }
            ],
            /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-ss': [
                {
                    'rounded-ss': scaleRadius()
                }
            ],
            /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-se': [
                {
                    'rounded-se': scaleRadius()
                }
            ],
            /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-ee': [
                {
                    'rounded-ee': scaleRadius()
                }
            ],
            /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-es': [
                {
                    'rounded-es': scaleRadius()
                }
            ],
            /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-tl': [
                {
                    'rounded-tl': scaleRadius()
                }
            ],
            /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-tr': [
                {
                    'rounded-tr': scaleRadius()
                }
            ],
            /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-br': [
                {
                    'rounded-br': scaleRadius()
                }
            ],
            /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */ 'rounded-bl': [
                {
                    'rounded-bl': scaleRadius()
                }
            ],
            /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w': [
                {
                    border: scaleBorderWidth()
                }
            ],
            /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-x': [
                {
                    'border-x': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-y': [
                {
                    'border-y': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-s': [
                {
                    'border-s': scaleBorderWidth()
                }
            ],
            /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-e': [
                {
                    'border-e': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-t': [
                {
                    'border-t': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-r': [
                {
                    'border-r': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-b': [
                {
                    'border-b': scaleBorderWidth()
                }
            ],
            /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */ 'border-w-l': [
                {
                    'border-l': scaleBorderWidth()
                }
            ],
            /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-x': [
                {
                    'divide-x': scaleBorderWidth()
                }
            ],
            /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-x-reverse': [
                'divide-x-reverse'
            ],
            /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-y': [
                {
                    'divide-y': scaleBorderWidth()
                }
            ],
            /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */ 'divide-y-reverse': [
                'divide-y-reverse'
            ],
            /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */ 'border-style': [
                {
                    border: [
                        ...scaleLineStyle(),
                        'hidden',
                        'none'
                    ]
                }
            ],
            /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */ 'divide-style': [
                {
                    divide: [
                        ...scaleLineStyle(),
                        'hidden',
                        'none'
                    ]
                }
            ],
            /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color': [
                {
                    border: scaleColor()
                }
            ],
            /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-x': [
                {
                    'border-x': scaleColor()
                }
            ],
            /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-y': [
                {
                    'border-y': scaleColor()
                }
            ],
            /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-s': [
                {
                    'border-s': scaleColor()
                }
            ],
            /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-e': [
                {
                    'border-e': scaleColor()
                }
            ],
            /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-t': [
                {
                    'border-t': scaleColor()
                }
            ],
            /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-r': [
                {
                    'border-r': scaleColor()
                }
            ],
            /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-b': [
                {
                    'border-b': scaleColor()
                }
            ],
            /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */ 'border-color-l': [
                {
                    'border-l': scaleColor()
                }
            ],
            /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */ 'divide-color': [
                {
                    divide: scaleColor()
                }
            ],
            /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */ 'outline-style': [
                {
                    outline: [
                        ...scaleLineStyle(),
                        'none',
                        'hidden'
                    ]
                }
            ],
            /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */ 'outline-offset': [
                {
                    'outline-offset': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */ 'outline-w': [
                {
                    outline: [
                        '',
                        isNumber,
                        isArbitraryVariableLength,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */ 'outline-color': [
                {
                    outline: [
                        themeColor
                    ]
                }
            ],
            // ---------------
            // --- Effects ---
            // ---------------
            /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */ shadow: [
                {
                    shadow: [
                        // Deprecated since Tailwind CSS v4.0.0
                        '',
                        'none',
                        themeShadow,
                        isArbitraryVariableShadow,
                        isArbitraryShadow
                    ]
                }
            ],
            /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */ 'shadow-color': [
                {
                    shadow: scaleColor()
                }
            ],
            /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */ 'inset-shadow': [
                {
                    'inset-shadow': [
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue,
                        themeInsetShadow
                    ]
                }
            ],
            /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */ 'inset-shadow-color': [
                {
                    'inset-shadow': scaleColor()
                }
            ],
            /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */ 'ring-w': [
                {
                    ring: scaleBorderWidth()
                }
            ],
            /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */ 'ring-w-inset': [
                'ring-inset'
            ],
            /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */ 'ring-color': [
                {
                    ring: scaleColor()
                }
            ],
            /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */ 'ring-offset-w': [
                {
                    'ring-offset': [
                        isNumber,
                        isArbitraryLength
                    ]
                }
            ],
            /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */ 'ring-offset-color': [
                {
                    'ring-offset': scaleColor()
                }
            ],
            /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */ 'inset-ring-w': [
                {
                    'inset-ring': scaleBorderWidth()
                }
            ],
            /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */ 'inset-ring-color': [
                {
                    'inset-ring': scaleColor()
                }
            ],
            /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */ opacity: [
                {
                    opacity: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */ 'mix-blend': [
                {
                    'mix-blend': [
                        ...scaleBlendMode(),
                        'plus-darker',
                        'plus-lighter'
                    ]
                }
            ],
            /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */ 'bg-blend': [
                {
                    'bg-blend': scaleBlendMode()
                }
            ],
            // ---------------
            // --- Filters ---
            // ---------------
            /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */ filter: [
                {
                    filter: [
                        // Deprecated since Tailwind CSS v3.0.0
                        '',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */ blur: [
                {
                    blur: scaleBlur()
                }
            ],
            /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */ brightness: [
                {
                    brightness: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */ contrast: [
                {
                    contrast: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */ 'drop-shadow': [
                {
                    'drop-shadow': [
                        // Deprecated since Tailwind CSS v4.0.0
                        '',
                        'none',
                        themeDropShadow,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */ grayscale: [
                {
                    grayscale: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */ 'hue-rotate': [
                {
                    'hue-rotate': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */ invert: [
                {
                    invert: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */ saturate: [
                {
                    saturate: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */ sepia: [
                {
                    sepia: [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */ 'backdrop-filter': [
                {
                    'backdrop-filter': [
                        // Deprecated since Tailwind CSS v3.0.0
                        '',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */ 'backdrop-blur': [
                {
                    'backdrop-blur': scaleBlur()
                }
            ],
            /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */ 'backdrop-brightness': [
                {
                    'backdrop-brightness': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */ 'backdrop-contrast': [
                {
                    'backdrop-contrast': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */ 'backdrop-grayscale': [
                {
                    'backdrop-grayscale': [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */ 'backdrop-hue-rotate': [
                {
                    'backdrop-hue-rotate': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */ 'backdrop-invert': [
                {
                    'backdrop-invert': [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */ 'backdrop-opacity': [
                {
                    'backdrop-opacity': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */ 'backdrop-saturate': [
                {
                    'backdrop-saturate': [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */ 'backdrop-sepia': [
                {
                    'backdrop-sepia': [
                        '',
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // --------------
            // --- Tables ---
            // --------------
            /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */ 'border-collapse': [
                {
                    border: [
                        'collapse',
                        'separate'
                    ]
                }
            ],
            /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */ 'border-spacing': [
                {
                    'border-spacing': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */ 'border-spacing-x': [
                {
                    'border-spacing-x': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */ 'border-spacing-y': [
                {
                    'border-spacing-y': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */ 'table-layout': [
                {
                    table: [
                        'auto',
                        'fixed'
                    ]
                }
            ],
            /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */ caption: [
                {
                    caption: [
                        'top',
                        'bottom'
                    ]
                }
            ],
            // ---------------------------------
            // --- Transitions and Animation ---
            // ---------------------------------
            /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */ transition: [
                {
                    transition: [
                        '',
                        'all',
                        'colors',
                        'opacity',
                        'shadow',
                        'transform',
                        'none',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */ 'transition-behavior': [
                {
                    transition: [
                        'normal',
                        'discrete'
                    ]
                }
            ],
            /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */ duration: [
                {
                    duration: [
                        isNumber,
                        'initial',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */ ease: [
                {
                    ease: [
                        'linear',
                        'initial',
                        themeEase,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */ delay: [
                {
                    delay: [
                        isNumber,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */ animate: [
                {
                    animate: [
                        'none',
                        themeAnimate,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // ------------------
            // --- Transforms ---
            // ------------------
            /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */ backface: [
                {
                    backface: [
                        'hidden',
                        'visible'
                    ]
                }
            ],
            /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */ perspective: [
                {
                    perspective: [
                        themePerspective,
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */ 'perspective-origin': [
                {
                    'perspective-origin': scaleOrigin()
                }
            ],
            /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */ rotate: [
                {
                    rotate: scaleRotate()
                }
            ],
            /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */ 'rotate-x': [
                {
                    'rotate-x': scaleRotate()
                }
            ],
            /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */ 'rotate-y': [
                {
                    'rotate-y': scaleRotate()
                }
            ],
            /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */ 'rotate-z': [
                {
                    'rotate-z': scaleRotate()
                }
            ],
            /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */ scale: [
                {
                    scale: scaleScale()
                }
            ],
            /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-x': [
                {
                    'scale-x': scaleScale()
                }
            ],
            /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-y': [
                {
                    'scale-y': scaleScale()
                }
            ],
            /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-z': [
                {
                    'scale-z': scaleScale()
                }
            ],
            /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */ 'scale-3d': [
                'scale-3d'
            ],
            /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */ skew: [
                {
                    skew: scaleSkew()
                }
            ],
            /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */ 'skew-x': [
                {
                    'skew-x': scaleSkew()
                }
            ],
            /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */ 'skew-y': [
                {
                    'skew-y': scaleSkew()
                }
            ],
            /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */ transform: [
                {
                    transform: [
                        isArbitraryVariable,
                        isArbitraryValue,
                        '',
                        'none',
                        'gpu',
                        'cpu'
                    ]
                }
            ],
            /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */ 'transform-origin': [
                {
                    origin: scaleOrigin()
                }
            ],
            /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */ 'transform-style': [
                {
                    transform: [
                        '3d',
                        'flat'
                    ]
                }
            ],
            /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */ translate: [
                {
                    translate: scaleTranslate()
                }
            ],
            /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-x': [
                {
                    'translate-x': scaleTranslate()
                }
            ],
            /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-y': [
                {
                    'translate-y': scaleTranslate()
                }
            ],
            /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-z': [
                {
                    'translate-z': scaleTranslate()
                }
            ],
            /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */ 'translate-none': [
                'translate-none'
            ],
            // ---------------------
            // --- Interactivity ---
            // ---------------------
            /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */ accent: [
                {
                    accent: scaleColor()
                }
            ],
            /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */ appearance: [
                {
                    appearance: [
                        'none',
                        'auto'
                    ]
                }
            ],
            /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */ 'caret-color': [
                {
                    caret: scaleColor()
                }
            ],
            /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */ 'color-scheme': [
                {
                    scheme: [
                        'normal',
                        'dark',
                        'light',
                        'light-dark',
                        'only-dark',
                        'only-light'
                    ]
                }
            ],
            /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */ cursor: [
                {
                    cursor: [
                        'auto',
                        'default',
                        'pointer',
                        'wait',
                        'text',
                        'move',
                        'help',
                        'not-allowed',
                        'none',
                        'context-menu',
                        'progress',
                        'cell',
                        'crosshair',
                        'vertical-text',
                        'alias',
                        'copy',
                        'no-drop',
                        'grab',
                        'grabbing',
                        'all-scroll',
                        'col-resize',
                        'row-resize',
                        'n-resize',
                        'e-resize',
                        's-resize',
                        'w-resize',
                        'ne-resize',
                        'nw-resize',
                        'se-resize',
                        'sw-resize',
                        'ew-resize',
                        'ns-resize',
                        'nesw-resize',
                        'nwse-resize',
                        'zoom-in',
                        'zoom-out',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */ 'field-sizing': [
                {
                    'field-sizing': [
                        'fixed',
                        'content'
                    ]
                }
            ],
            /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */ 'pointer-events': [
                {
                    'pointer-events': [
                        'auto',
                        'none'
                    ]
                }
            ],
            /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */ resize: [
                {
                    resize: [
                        'none',
                        '',
                        'y',
                        'x'
                    ]
                }
            ],
            /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */ 'scroll-behavior': [
                {
                    scroll: [
                        'auto',
                        'smooth'
                    ]
                }
            ],
            /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-m': [
                {
                    'scroll-m': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mx': [
                {
                    'scroll-mx': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-my': [
                {
                    'scroll-my': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-ms': [
                {
                    'scroll-ms': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-me': [
                {
                    'scroll-me': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mt': [
                {
                    'scroll-mt': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mr': [
                {
                    'scroll-mr': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-mb': [
                {
                    'scroll-mb': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */ 'scroll-ml': [
                {
                    'scroll-ml': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-p': [
                {
                    'scroll-p': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-px': [
                {
                    'scroll-px': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-py': [
                {
                    'scroll-py': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-ps': [
                {
                    'scroll-ps': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pe': [
                {
                    'scroll-pe': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pt': [
                {
                    'scroll-pt': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pr': [
                {
                    'scroll-pr': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pb': [
                {
                    'scroll-pb': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */ 'scroll-pl': [
                {
                    'scroll-pl': scaleUnambiguousSpacing()
                }
            ],
            /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */ 'snap-align': [
                {
                    snap: [
                        'start',
                        'end',
                        'center',
                        'align-none'
                    ]
                }
            ],
            /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */ 'snap-stop': [
                {
                    snap: [
                        'normal',
                        'always'
                    ]
                }
            ],
            /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */ 'snap-type': [
                {
                    snap: [
                        'none',
                        'x',
                        'y',
                        'both'
                    ]
                }
            ],
            /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */ 'snap-strictness': [
                {
                    snap: [
                        'mandatory',
                        'proximity'
                    ]
                }
            ],
            /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */ touch: [
                {
                    touch: [
                        'auto',
                        'none',
                        'manipulation'
                    ]
                }
            ],
            /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */ 'touch-x': [
                {
                    'touch-pan': [
                        'x',
                        'left',
                        'right'
                    ]
                }
            ],
            /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */ 'touch-y': [
                {
                    'touch-pan': [
                        'y',
                        'up',
                        'down'
                    ]
                }
            ],
            /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */ 'touch-pz': [
                'touch-pinch-zoom'
            ],
            /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */ select: [
                {
                    select: [
                        'none',
                        'text',
                        'all',
                        'auto'
                    ]
                }
            ],
            /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */ 'will-change': [
                {
                    'will-change': [
                        'auto',
                        'scroll',
                        'contents',
                        'transform',
                        isArbitraryVariable,
                        isArbitraryValue
                    ]
                }
            ],
            // -----------
            // --- SVG ---
            // -----------
            /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */ fill: [
                {
                    fill: [
                        'none',
                        ...scaleColor()
                    ]
                }
            ],
            /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */ 'stroke-w': [
                {
                    stroke: [
                        isNumber,
                        isArbitraryVariableLength,
                        isArbitraryLength,
                        isArbitraryNumber
                    ]
                }
            ],
            /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */ stroke: [
                {
                    stroke: [
                        'none',
                        ...scaleColor()
                    ]
                }
            ],
            // ---------------------
            // --- Accessibility ---
            // ---------------------
            /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */ 'forced-color-adjust': [
                {
                    'forced-color-adjust': [
                        'auto',
                        'none'
                    ]
                }
            ]
        },
        conflictingClassGroups: {
            overflow: [
                'overflow-x',
                'overflow-y'
            ],
            overscroll: [
                'overscroll-x',
                'overscroll-y'
            ],
            inset: [
                'inset-x',
                'inset-y',
                'start',
                'end',
                'top',
                'right',
                'bottom',
                'left'
            ],
            'inset-x': [
                'right',
                'left'
            ],
            'inset-y': [
                'top',
                'bottom'
            ],
            flex: [
                'basis',
                'grow',
                'shrink'
            ],
            gap: [
                'gap-x',
                'gap-y'
            ],
            p: [
                'px',
                'py',
                'ps',
                'pe',
                'pt',
                'pr',
                'pb',
                'pl'
            ],
            px: [
                'pr',
                'pl'
            ],
            py: [
                'pt',
                'pb'
            ],
            m: [
                'mx',
                'my',
                'ms',
                'me',
                'mt',
                'mr',
                'mb',
                'ml'
            ],
            mx: [
                'mr',
                'ml'
            ],
            my: [
                'mt',
                'mb'
            ],
            size: [
                'w',
                'h'
            ],
            'font-size': [
                'leading'
            ],
            'fvn-normal': [
                'fvn-ordinal',
                'fvn-slashed-zero',
                'fvn-figure',
                'fvn-spacing',
                'fvn-fraction'
            ],
            'fvn-ordinal': [
                'fvn-normal'
            ],
            'fvn-slashed-zero': [
                'fvn-normal'
            ],
            'fvn-figure': [
                'fvn-normal'
            ],
            'fvn-spacing': [
                'fvn-normal'
            ],
            'fvn-fraction': [
                'fvn-normal'
            ],
            'line-clamp': [
                'display',
                'overflow'
            ],
            rounded: [
                'rounded-s',
                'rounded-e',
                'rounded-t',
                'rounded-r',
                'rounded-b',
                'rounded-l',
                'rounded-ss',
                'rounded-se',
                'rounded-ee',
                'rounded-es',
                'rounded-tl',
                'rounded-tr',
                'rounded-br',
                'rounded-bl'
            ],
            'rounded-s': [
                'rounded-ss',
                'rounded-es'
            ],
            'rounded-e': [
                'rounded-se',
                'rounded-ee'
            ],
            'rounded-t': [
                'rounded-tl',
                'rounded-tr'
            ],
            'rounded-r': [
                'rounded-tr',
                'rounded-br'
            ],
            'rounded-b': [
                'rounded-br',
                'rounded-bl'
            ],
            'rounded-l': [
                'rounded-tl',
                'rounded-bl'
            ],
            'border-spacing': [
                'border-spacing-x',
                'border-spacing-y'
            ],
            'border-w': [
                'border-w-s',
                'border-w-e',
                'border-w-t',
                'border-w-r',
                'border-w-b',
                'border-w-l'
            ],
            'border-w-x': [
                'border-w-r',
                'border-w-l'
            ],
            'border-w-y': [
                'border-w-t',
                'border-w-b'
            ],
            'border-color': [
                'border-color-s',
                'border-color-e',
                'border-color-t',
                'border-color-r',
                'border-color-b',
                'border-color-l'
            ],
            'border-color-x': [
                'border-color-r',
                'border-color-l'
            ],
            'border-color-y': [
                'border-color-t',
                'border-color-b'
            ],
            translate: [
                'translate-x',
                'translate-y',
                'translate-none'
            ],
            'translate-none': [
                'translate',
                'translate-x',
                'translate-y',
                'translate-z'
            ],
            'scroll-m': [
                'scroll-mx',
                'scroll-my',
                'scroll-ms',
                'scroll-me',
                'scroll-mt',
                'scroll-mr',
                'scroll-mb',
                'scroll-ml'
            ],
            'scroll-mx': [
                'scroll-mr',
                'scroll-ml'
            ],
            'scroll-my': [
                'scroll-mt',
                'scroll-mb'
            ],
            'scroll-p': [
                'scroll-px',
                'scroll-py',
                'scroll-ps',
                'scroll-pe',
                'scroll-pt',
                'scroll-pr',
                'scroll-pb',
                'scroll-pl'
            ],
            'scroll-px': [
                'scroll-pr',
                'scroll-pl'
            ],
            'scroll-py': [
                'scroll-pt',
                'scroll-pb'
            ],
            touch: [
                'touch-x',
                'touch-y',
                'touch-pz'
            ],
            'touch-x': [
                'touch'
            ],
            'touch-y': [
                'touch'
            ],
            'touch-pz': [
                'touch'
            ]
        },
        conflictingClassGroupModifiers: {
            'font-size': [
                'leading'
            ]
        },
        orderSensitiveModifiers: [
            'before',
            'after',
            'placeholder',
            'file',
            'marker',
            'selection',
            'first-line',
            'first-letter',
            'backdrop',
            '*',
            '**'
        ]
    };
};
/**
 * @param baseConfig Config where other config will be merged into. This object will be mutated.
 * @param configExtension Partial config to merge into the `baseConfig`.
 */ const mergeConfigs = (baseConfig, { cacheSize, prefix, experimentalParseClassName, extend = {}, override = {} })=>{
    overrideProperty(baseConfig, 'cacheSize', cacheSize);
    overrideProperty(baseConfig, 'prefix', prefix);
    overrideProperty(baseConfig, 'experimentalParseClassName', experimentalParseClassName);
    overrideConfigProperties(baseConfig.theme, override.theme);
    overrideConfigProperties(baseConfig.classGroups, override.classGroups);
    overrideConfigProperties(baseConfig.conflictingClassGroups, override.conflictingClassGroups);
    overrideConfigProperties(baseConfig.conflictingClassGroupModifiers, override.conflictingClassGroupModifiers);
    overrideProperty(baseConfig, 'orderSensitiveModifiers', override.orderSensitiveModifiers);
    mergeConfigProperties(baseConfig.theme, extend.theme);
    mergeConfigProperties(baseConfig.classGroups, extend.classGroups);
    mergeConfigProperties(baseConfig.conflictingClassGroups, extend.conflictingClassGroups);
    mergeConfigProperties(baseConfig.conflictingClassGroupModifiers, extend.conflictingClassGroupModifiers);
    mergeArrayProperties(baseConfig, extend, 'orderSensitiveModifiers');
    return baseConfig;
};
const overrideProperty = (baseObject, overrideKey, overrideValue)=>{
    if (overrideValue !== undefined) {
        baseObject[overrideKey] = overrideValue;
    }
};
const overrideConfigProperties = (baseObject, overrideObject)=>{
    if (overrideObject) {
        for(const key in overrideObject){
            overrideProperty(baseObject, key, overrideObject[key]);
        }
    }
};
const mergeConfigProperties = (baseObject, mergeObject)=>{
    if (mergeObject) {
        for(const key in mergeObject){
            mergeArrayProperties(baseObject, mergeObject, key);
        }
    }
};
const mergeArrayProperties = (baseObject, mergeObject, key)=>{
    const mergeValue = mergeObject[key];
    if (mergeValue !== undefined) {
        baseObject[key] = baseObject[key] ? baseObject[key].concat(mergeValue) : mergeValue;
    }
};
const extendTailwindMerge = (configExtension, ...createConfig)=>typeof configExtension === 'function' ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(()=>mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
const twMerge = /*#__PURE__*/ createTailwindMerge(getDefaultConfig);
;
 //# sourceMappingURL=bundle-mjs.mjs.map
}}),
"[project]/node_modules/@daily-co/daily-js/dist/daily-esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DAILY_ACCESS_LEVEL_FULL": (()=>hi),
    "DAILY_ACCESS_LEVEL_LOBBY": (()=>fi),
    "DAILY_ACCESS_LEVEL_NONE": (()=>vi),
    "DAILY_ACCESS_UNKNOWN": (()=>pi),
    "DAILY_CAMERA_ERROR_CAM_AND_MIC_IN_USE": (()=>Ai),
    "DAILY_CAMERA_ERROR_CAM_IN_USE": (()=>Pi),
    "DAILY_CAMERA_ERROR_CONSTRAINTS": (()=>Ii),
    "DAILY_CAMERA_ERROR_MIC_IN_USE": (()=>Oi),
    "DAILY_CAMERA_ERROR_NOT_FOUND": (()=>xi),
    "DAILY_CAMERA_ERROR_PERMISSIONS": (()=>ji),
    "DAILY_CAMERA_ERROR_UNDEF_MEDIADEVICES": (()=>Li),
    "DAILY_CAMERA_ERROR_UNKNOWN": (()=>Di),
    "DAILY_EVENT_ACCESS_STATE_UPDATED": (()=>Ki),
    "DAILY_EVENT_ACTIVE_SPEAKER_CHANGE": (()=>Mo),
    "DAILY_EVENT_ACTIVE_SPEAKER_MODE_CHANGE": (()=>Co),
    "DAILY_EVENT_APP_MSG": (()=>go),
    "DAILY_EVENT_CAMERA_ERROR": (()=>$i),
    "DAILY_EVENT_CPU_LOAD_CHANGE": (()=>Po),
    "DAILY_EVENT_ERROR": (()=>Uo),
    "DAILY_EVENT_EXIT_FULLSCREEN": (()=>jo),
    "DAILY_EVENT_FACE_COUNTS_UPDATED": (()=>Oo),
    "DAILY_EVENT_FULLSCREEN": (()=>Ao),
    "DAILY_EVENT_IFRAME_LAUNCH_CONFIG": (()=>Fi),
    "DAILY_EVENT_IFRAME_READY_FOR_LAUNCH_CONFIG": (()=>Ni),
    "DAILY_EVENT_INPUT_SETTINGS_UPDATED": (()=>Ro),
    "DAILY_EVENT_JOINED_MEETING": (()=>zi),
    "DAILY_EVENT_JOINING_MEETING": (()=>qi),
    "DAILY_EVENT_LANG_UPDATED": (()=>No),
    "DAILY_EVENT_LEFT_MEETING": (()=>Wi),
    "DAILY_EVENT_LIVE_STREAMING_ERROR": (()=>Do),
    "DAILY_EVENT_LIVE_STREAMING_STARTED": (()=>Lo),
    "DAILY_EVENT_LIVE_STREAMING_STOPPED": (()=>Io),
    "DAILY_EVENT_LIVE_STREAMING_UPDATED": (()=>xo),
    "DAILY_EVENT_LOADED": (()=>Vi),
    "DAILY_EVENT_LOADING": (()=>Bi),
    "DAILY_EVENT_LOAD_ATTEMPT_FAILED": (()=>Ui),
    "DAILY_EVENT_LOCAL_SCREEN_SHARE_CANCELED": (()=>So),
    "DAILY_EVENT_LOCAL_SCREEN_SHARE_STARTED": (()=>wo),
    "DAILY_EVENT_LOCAL_SCREEN_SHARE_STOPPED": (()=>ko),
    "DAILY_EVENT_MEETING_SESSION_DATA_ERROR": (()=>eo),
    "DAILY_EVENT_MEETING_SESSION_STATE_UPDATED": (()=>Zi),
    "DAILY_EVENT_MEETING_SESSION_SUMMARY_UPDATED": (()=>Xi),
    "DAILY_EVENT_NETWORK_CONNECTION": (()=>To),
    "DAILY_EVENT_NETWORK_QUALITY_CHANGE": (()=>Eo),
    "DAILY_EVENT_NONFATAL_ERROR": (()=>Bo),
    "DAILY_EVENT_PARTICIPANT_COUNTS_UPDATED": (()=>Yi),
    "DAILY_EVENT_PARTICIPANT_JOINED": (()=>Hi),
    "DAILY_EVENT_PARTICIPANT_LEFT": (()=>Qi),
    "DAILY_EVENT_PARTICIPANT_UPDATED": (()=>Gi),
    "DAILY_EVENT_RECEIVE_SETTINGS_UPDATED": (()=>Fo),
    "DAILY_EVENT_RECORDING_DATA": (()=>vo),
    "DAILY_EVENT_RECORDING_ERROR": (()=>ho),
    "DAILY_EVENT_RECORDING_STARTED": (()=>lo),
    "DAILY_EVENT_RECORDING_STATS": (()=>po),
    "DAILY_EVENT_RECORDING_STOPPED": (()=>uo),
    "DAILY_EVENT_RECORDING_UPLOAD_COMPLETED": (()=>fo),
    "DAILY_EVENT_REMOTE_MEDIA_PLAYER_STARTED": (()=>yo),
    "DAILY_EVENT_REMOTE_MEDIA_PLAYER_STOPPED": (()=>bo),
    "DAILY_EVENT_REMOTE_MEDIA_PLAYER_UPDATED": (()=>_o),
    "DAILY_EVENT_STARTED_CAMERA": (()=>Ji),
    "DAILY_EVENT_THEME_UPDATED": (()=>Ri),
    "DAILY_EVENT_TRACK_STARTED": (()=>io),
    "DAILY_EVENT_TRACK_STOPPED": (()=>oo),
    "DAILY_EVENT_TRANSCRIPTION_ERROR": (()=>co),
    "DAILY_EVENT_TRANSCRIPTION_MSG": (()=>mo),
    "DAILY_EVENT_TRANSCRIPTION_STARTED": (()=>ao),
    "DAILY_EVENT_TRANSCRIPTION_STOPPED": (()=>so),
    "DAILY_EVENT_WAITING_PARTICIPANT_ADDED": (()=>to),
    "DAILY_EVENT_WAITING_PARTICIPANT_REMOVED": (()=>ro),
    "DAILY_EVENT_WAITING_PARTICIPANT_UPDATED": (()=>no),
    "DAILY_FATAL_ERROR_CONNECTION": (()=>Ti),
    "DAILY_FATAL_ERROR_EJECTED": (()=>yi),
    "DAILY_FATAL_ERROR_EOL": (()=>Ci),
    "DAILY_FATAL_ERROR_EXP_ROOM": (()=>wi),
    "DAILY_FATAL_ERROR_EXP_TOKEN": (()=>ki),
    "DAILY_FATAL_ERROR_MEETING_FULL": (()=>Mi),
    "DAILY_FATAL_ERROR_NBF_ROOM": (()=>_i),
    "DAILY_FATAL_ERROR_NBF_TOKEN": (()=>bi),
    "DAILY_FATAL_ERROR_NOT_ALLOWED": (()=>Ei),
    "DAILY_FATAL_ERROR_NO_ROOM": (()=>Si),
    "DAILY_RECEIVE_SETTINGS_ALL_PARTICIPANTS_KEY": (()=>mi),
    "DAILY_RECEIVE_SETTINGS_BASE_KEY": (()=>gi),
    "DAILY_STATE_ERROR": (()=>oi),
    "DAILY_STATE_JOINED": (()=>ri),
    "DAILY_STATE_JOINING": (()=>ni),
    "DAILY_STATE_LEFT": (()=>ii),
    "DAILY_STATE_NEW": (()=>Zr),
    "DAILY_TRACK_STATE_BLOCKED": (()=>ai),
    "DAILY_TRACK_STATE_INTERRUPTED": (()=>ui),
    "DAILY_TRACK_STATE_LOADING": (()=>li),
    "DAILY_TRACK_STATE_OFF": (()=>si),
    "DAILY_TRACK_STATE_PLAYABLE": (()=>di),
    "DAILY_TRACK_STATE_SENDABLE": (()=>ci),
    "default": (()=>js)
});
function e1(e1, t) {
    if (null == e1) return {};
    var n, r, i = function(e1, t) {
        if (null == e1) return {};
        var n, r, i = {}, o = Object.keys(e1);
        for(r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e1[n]);
        return i;
    }(e1, t);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e1);
        for(r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e1, n) && (i[n] = e1[n]);
    }
    return i;
}
function t(e1, t) {
    if (!(e1 instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function n(e1) {
    return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e1) {
        return typeof e1;
    } : function(e1) {
        return e1 && "function" == typeof Symbol && e1.constructor === Symbol && e1 !== Symbol.prototype ? "symbol" : typeof e1;
    }, n(e1);
}
function r(e1) {
    var t = function(e1, t) {
        if ("object" !== n(e1) || null === e1) return e1;
        var r = e1[Symbol.toPrimitive];
        if (void 0 !== r) {
            var i = r.call(e1, t || "default");
            if ("object" !== n(i)) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (("TURBOPACK compile-time truthy", 1) ? String : ("TURBOPACK unreachable", undefined))(e1);
    }(e1, "string");
    return "symbol" === n(t) ? t : String(t);
}
function i(e1, t) {
    for(var n = 0; n < t.length; n++){
        var i = t[n];
        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e1, r(i.key), i);
    }
}
function o(e1, t, n) {
    return t && i(e1.prototype, t), n && i(e1, n), Object.defineProperty(e1, "prototype", {
        writable: !1
    }), e1;
}
function a(e1) {
    if (void 0 === e1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e1;
}
function s(e1, t) {
    return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e1, t) {
        return e1.__proto__ = t, e1;
    }, s(e1, t);
}
function c(e1, t) {
    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
    e1.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e1,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e1, "prototype", {
        writable: !1
    }), t && s(e1, t);
}
function l(e1, t) {
    if (t && ("object" === n(t) || "function" == typeof t)) return t;
    if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
    return a(e1);
}
function u(e1) {
    return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e1) {
        return e1.__proto__ || Object.getPrototypeOf(e1);
    }, u(e1);
}
function d(e1, t, n) {
    return (t = r(t)) in e1 ? Object.defineProperty(e1, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e1[t] = n, e1;
}
function p(e1, t, n, r, i, o, a) {
    try {
        var s = e1[o](a), c = s.value;
    } catch (e1) {
        return void n(e1);
    }
    s.done ? t(c) : Promise.resolve(c).then(r, i);
}
function h(e1) {
    return function() {
        var t = this, n = arguments;
        return new Promise(function(r, i) {
            var o = e1.apply(t, n);
            function a(e1) {
                p(o, r, i, a, s, "next", e1);
            }
            function s(e1) {
                p(o, r, i, a, s, "throw", e1);
            }
            a(void 0);
        });
    };
}
function f(e1, t) {
    (null == t || t > e1.length) && (t = e1.length);
    for(var n = 0, r = new Array(t); n < t; n++)r[n] = e1[n];
    return r;
}
function v(e1, t) {
    return function(e1) {
        if (Array.isArray(e1)) return e1;
    }(e1) || function(e1, t) {
        var n = null == e1 ? null : "undefined" != typeof Symbol && e1[Symbol.iterator] || e1["@@iterator"];
        if (null != n) {
            var r, i, o, a, s = [], c = !0, l = !1;
            try {
                if (o = (n = n.call(e1)).next, 0 === t) {
                    if (Object(n) !== n) return;
                    c = !1;
                } else for(; !(c = (r = o.call(n)).done) && (s.push(r.value), s.length !== t); c = !0);
            } catch (e1) {
                l = !0, i = e1;
            } finally{
                try {
                    if (!c && null != n.return && (a = n.return(), Object(a) !== a)) return;
                } finally{
                    if (l) throw i;
                }
            }
            return s;
        }
    }(e1, t) || function(e1, t) {
        if (e1) {
            if ("string" == typeof e1) return f(e1, t);
            var n = Object.prototype.toString.call(e1).slice(8, -1);
            return "Object" === n && e1.constructor && (n = e1.constructor.name), "Map" === n || "Set" === n ? Array.from(e1) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? f(e1, t) : void 0;
        }
    }(e1, t) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
}
var g, m = {}, y = {
    get exports () {
        return m;
    },
    set exports (e){
        m = e;
    }
}, _ = "object" == typeof Reflect ? Reflect : null, b = _ && "function" == typeof _.apply ? _.apply : function(e1, t, n) {
    return Function.prototype.apply.call(e1, t, n);
};
g = _ && "function" == typeof _.ownKeys ? _.ownKeys : Object.getOwnPropertySymbols ? function(e1) {
    return Object.getOwnPropertyNames(e1).concat(Object.getOwnPropertySymbols(e1));
} : function(e1) {
    return Object.getOwnPropertyNames(e1);
};
var w = Number.isNaN || function(e1) {
    return e1 != e1;
};
function k() {
    k.init.call(this);
}
y.exports = k, m.once = function(e1, t) {
    return new Promise(function(n, r) {
        function i(n) {
            e1.removeListener(t, o), r(n);
        }
        function o() {
            "function" == typeof e1.removeListener && e1.removeListener("error", i), n([].slice.call(arguments));
        }
        L(e1, t, o, {
            once: !0
        }), "error" !== t && function(e1, t, n) {
            "function" == typeof e1.on && L(e1, "error", t, n);
        }(e1, i, {
            once: !0
        });
    });
}, k.EventEmitter = k, k.prototype._events = void 0, k.prototype._eventsCount = 0, k.prototype._maxListeners = void 0;
var S = 10;
function M(e1) {
    if ("function" != typeof e1) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e1);
}
function C(e1) {
    return void 0 === e1._maxListeners ? k.defaultMaxListeners : e1._maxListeners;
}
function E(e1, t, n, r) {
    var i, o, a, s;
    if (M(n), void 0 === (o = e1._events) ? (o = e1._events = Object.create(null), e1._eventsCount = 0) : (void 0 !== o.newListener && (e1.emit("newListener", t, n.listener ? n.listener : n), o = e1._events), a = o[t]), void 0 === a) a = o[t] = n, ++e1._eventsCount;
    else if ("function" == typeof a ? a = o[t] = r ? [
        n,
        a
    ] : [
        a,
        n
    ] : r ? a.unshift(n) : a.push(n), (i = C(e1)) > 0 && a.length > i && !a.warned) {
        a.warned = !0;
        var c = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        c.name = "MaxListenersExceededWarning", c.emitter = e1, c.type = t, c.count = a.length, s = c, console && console.warn && console.warn(s);
    }
    return e1;
}
function T() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function P(e1, t, n) {
    var r = {
        fired: !1,
        wrapFn: void 0,
        target: e1,
        type: t,
        listener: n
    }, i = T.bind(r);
    return i.listener = n, r.wrapFn = i, i;
}
function O(e1, t, n) {
    var r = e1._events;
    if (void 0 === r) return [];
    var i = r[t];
    return void 0 === i ? [] : "function" == typeof i ? n ? [
        i.listener || i
    ] : [
        i
    ] : n ? function(e1) {
        for(var t = new Array(e1.length), n = 0; n < t.length; ++n)t[n] = e1[n].listener || e1[n];
        return t;
    }(i) : j(i, i.length);
}
function A(e1) {
    var t = this._events;
    if (void 0 !== t) {
        var n = t[e1];
        if ("function" == typeof n) return 1;
        if (void 0 !== n) return n.length;
    }
    return 0;
}
function j(e1, t) {
    for(var n = new Array(t), r = 0; r < t; ++r)n[r] = e1[r];
    return n;
}
function L(e1, t, n, r) {
    if ("function" == typeof e1.on) r.once ? e1.once(t, n) : e1.on(t, n);
    else {
        if ("function" != typeof e1.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e1);
        e1.addEventListener(t, function i(o) {
            r.once && e1.removeEventListener(t, i), n(o);
        });
    }
}
Object.defineProperty(k, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
        return S;
    },
    set: function(e1) {
        if ("number" != typeof e1 || e1 < 0 || w(e1)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e1 + ".");
        S = e1;
    }
}), k.init = function() {
    void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, k.prototype.setMaxListeners = function(e1) {
    if ("number" != typeof e1 || e1 < 0 || w(e1)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e1 + ".");
    return this._maxListeners = e1, this;
}, k.prototype.getMaxListeners = function() {
    return C(this);
}, k.prototype.emit = function(e1) {
    for(var t = [], n = 1; n < arguments.length; n++)t.push(arguments[n]);
    var r = "error" === e1, i = this._events;
    if (void 0 !== i) r = r && void 0 === i.error;
    else if (!r) return !1;
    if (r) {
        var o;
        if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
        var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
        throw a.context = o, a;
    }
    var s = i[e1];
    if (void 0 === s) return !1;
    if ("function" == typeof s) b(s, this, t);
    else {
        var c = s.length, l = j(s, c);
        for(n = 0; n < c; ++n)b(l[n], this, t);
    }
    return !0;
}, k.prototype.addListener = function(e1, t) {
    return E(this, e1, t, !1);
}, k.prototype.on = k.prototype.addListener, k.prototype.prependListener = function(e1, t) {
    return E(this, e1, t, !0);
}, k.prototype.once = function(e1, t) {
    return M(t), this.on(e1, P(this, e1, t)), this;
}, k.prototype.prependOnceListener = function(e1, t) {
    return M(t), this.prependListener(e1, P(this, e1, t)), this;
}, k.prototype.removeListener = function(e1, t) {
    var n, r, i, o, a;
    if (M(t), void 0 === (r = this._events)) return this;
    if (void 0 === (n = r[e1])) return this;
    if (n === t || n.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[e1], r.removeListener && this.emit("removeListener", e1, n.listener || t));
    else if ("function" != typeof n) {
        for(i = -1, o = n.length - 1; o >= 0; o--)if (n[o] === t || n[o].listener === t) {
            a = n[o].listener, i = o;
            break;
        }
        if (i < 0) return this;
        0 === i ? n.shift() : function(e1, t) {
            for(; t + 1 < e1.length; t++)e1[t] = e1[t + 1];
            e1.pop();
        }(n, i), 1 === n.length && (r[e1] = n[0]), void 0 !== r.removeListener && this.emit("removeListener", e1, a || t);
    }
    return this;
}, k.prototype.off = k.prototype.removeListener, k.prototype.removeAllListeners = function(e1) {
    var t, n, r;
    if (void 0 === (n = this._events)) return this;
    if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e1] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e1]), this;
    if (0 === arguments.length) {
        var i, o = Object.keys(n);
        for(r = 0; r < o.length; ++r)"removeListener" !== (i = o[r]) && this.removeAllListeners(i);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
    }
    if ("function" == typeof (t = n[e1])) this.removeListener(e1, t);
    else if (void 0 !== t) for(r = t.length - 1; r >= 0; r--)this.removeListener(e1, t[r]);
    return this;
}, k.prototype.listeners = function(e1) {
    return O(this, e1, !0);
}, k.prototype.rawListeners = function(e1) {
    return O(this, e1, !1);
}, k.listenerCount = function(e1, t) {
    return "function" == typeof e1.listenerCount ? e1.listenerCount(t) : A.call(e1, t);
}, k.prototype.listenerCount = A, k.prototype.eventNames = function() {
    return this._eventsCount > 0 ? g(this._events) : [];
};
var x = Object.prototype.hasOwnProperty;
function I(e1, t, n) {
    for (n of e1.keys())if (D(n, t)) return n;
}
function D(e1, t) {
    var n, r, i;
    if (e1 === t) return !0;
    if (e1 && t && (n = e1.constructor) === t.constructor) {
        if (n === Date) return e1.getTime() === t.getTime();
        if (n === RegExp) return e1.toString() === t.toString();
        if (n === Array) {
            if ((r = e1.length) === t.length) for(; r-- && D(e1[r], t[r]););
            return -1 === r;
        }
        if (n === Set) {
            if (e1.size !== t.size) return !1;
            for (r of e1){
                if ((i = r) && "object" == typeof i && !(i = I(t, i))) return !1;
                if (!t.has(i)) return !1;
            }
            return !0;
        }
        if (n === Map) {
            if (e1.size !== t.size) return !1;
            for (r of e1){
                if ((i = r[0]) && "object" == typeof i && !(i = I(t, i))) return !1;
                if (!D(r[1], t.get(i))) return !1;
            }
            return !0;
        }
        if (n === ArrayBuffer) e1 = new Uint8Array(e1), t = new Uint8Array(t);
        else if (n === DataView) {
            if ((r = e1.byteLength) === t.byteLength) for(; r-- && e1.getInt8(r) === t.getInt8(r););
            return -1 === r;
        }
        if (ArrayBuffer.isView(e1)) {
            if ((r = e1.byteLength) === t.byteLength) for(; r-- && e1[r] === t[r];);
            return -1 === r;
        }
        if (!n || "object" == typeof e1) {
            for(n in r = 0, e1){
                if (x.call(e1, n) && ++r && !x.call(t, n)) return !1;
                if (!(n in t) || !D(e1[n], t[n])) return !1;
            }
            return Object.keys(t).length === r;
        }
    }
    return e1 != e1 && t != t;
}
const N = {
    "Amazon Silk": "amazon_silk",
    "Android Browser": "android",
    Bada: "bada",
    BlackBerry: "blackberry",
    Chrome: "chrome",
    Chromium: "chromium",
    Electron: "electron",
    Epiphany: "epiphany",
    Firefox: "firefox",
    Focus: "focus",
    Generic: "generic",
    "Google Search": "google_search",
    Googlebot: "googlebot",
    "Internet Explorer": "ie",
    "K-Meleon": "k_meleon",
    Maxthon: "maxthon",
    "Microsoft Edge": "edge",
    "MZ Browser": "mz",
    "NAVER Whale Browser": "naver",
    Opera: "opera",
    "Opera Coast": "opera_coast",
    PhantomJS: "phantomjs",
    Puffin: "puffin",
    QupZilla: "qupzilla",
    QQ: "qq",
    QQLite: "qqlite",
    Safari: "safari",
    Sailfish: "sailfish",
    "Samsung Internet for Android": "samsung_internet",
    SeaMonkey: "seamonkey",
    Sleipnir: "sleipnir",
    Swing: "swing",
    Tizen: "tizen",
    "UC Browser": "uc",
    Vivaldi: "vivaldi",
    "WebOS Browser": "webos",
    WeChat: "wechat",
    "Yandex Browser": "yandex",
    Roku: "roku"
}, F = {
    amazon_silk: "Amazon Silk",
    android: "Android Browser",
    bada: "Bada",
    blackberry: "BlackBerry",
    chrome: "Chrome",
    chromium: "Chromium",
    electron: "Electron",
    epiphany: "Epiphany",
    firefox: "Firefox",
    focus: "Focus",
    generic: "Generic",
    googlebot: "Googlebot",
    google_search: "Google Search",
    ie: "Internet Explorer",
    k_meleon: "K-Meleon",
    maxthon: "Maxthon",
    edge: "Microsoft Edge",
    mz: "MZ Browser",
    naver: "NAVER Whale Browser",
    opera: "Opera",
    opera_coast: "Opera Coast",
    phantomjs: "PhantomJS",
    puffin: "Puffin",
    qupzilla: "QupZilla",
    qq: "QQ Browser",
    qqlite: "QQ Browser Lite",
    safari: "Safari",
    sailfish: "Sailfish",
    samsung_internet: "Samsung Internet for Android",
    seamonkey: "SeaMonkey",
    sleipnir: "Sleipnir",
    swing: "Swing",
    tizen: "Tizen",
    uc: "UC Browser",
    vivaldi: "Vivaldi",
    webos: "WebOS Browser",
    wechat: "WeChat",
    yandex: "Yandex Browser"
}, R = {
    tablet: "tablet",
    mobile: "mobile",
    desktop: "desktop",
    tv: "tv"
}, B = {
    WindowsPhone: "Windows Phone",
    Windows: "Windows",
    MacOS: "macOS",
    iOS: "iOS",
    Android: "Android",
    WebOS: "WebOS",
    BlackBerry: "BlackBerry",
    Bada: "Bada",
    Tizen: "Tizen",
    Linux: "Linux",
    ChromeOS: "Chrome OS",
    PlayStation4: "PlayStation 4",
    Roku: "Roku"
}, U = {
    EdgeHTML: "EdgeHTML",
    Blink: "Blink",
    Trident: "Trident",
    Presto: "Presto",
    Gecko: "Gecko",
    WebKit: "WebKit"
};
class V {
    static getFirstMatch(e1, t) {
        const n = t.match(e1);
        return n && n.length > 0 && n[1] || "";
    }
    static getSecondMatch(e1, t) {
        const n = t.match(e1);
        return n && n.length > 1 && n[2] || "";
    }
    static matchAndReturnConst(e1, t, n) {
        if (e1.test(t)) return n;
    }
    static getWindowsVersionName(e1) {
        switch(e1){
            case "NT":
                return "NT";
            case "XP":
            case "NT 5.1":
                return "XP";
            case "NT 5.0":
                return "2000";
            case "NT 5.2":
                return "2003";
            case "NT 6.0":
                return "Vista";
            case "NT 6.1":
                return "7";
            case "NT 6.2":
                return "8";
            case "NT 6.3":
                return "8.1";
            case "NT 10.0":
                return "10";
            default:
                return;
        }
    }
    static getMacOSVersionName(e1) {
        const t = e1.split(".").splice(0, 2).map((e1)=>parseInt(e1, 10) || 0);
        if (t.push(0), 10 === t[0]) switch(t[1]){
            case 5:
                return "Leopard";
            case 6:
                return "Snow Leopard";
            case 7:
                return "Lion";
            case 8:
                return "Mountain Lion";
            case 9:
                return "Mavericks";
            case 10:
                return "Yosemite";
            case 11:
                return "El Capitan";
            case 12:
                return "Sierra";
            case 13:
                return "High Sierra";
            case 14:
                return "Mojave";
            case 15:
                return "Catalina";
            default:
                return;
        }
    }
    static getAndroidVersionName(e1) {
        const t = e1.split(".").splice(0, 2).map((e1)=>parseInt(e1, 10) || 0);
        if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? "Cupcake" : 1 === t[0] && t[1] >= 6 ? "Donut" : 2 === t[0] && t[1] < 2 ? "Eclair" : 2 === t[0] && 2 === t[1] ? "Froyo" : 2 === t[0] && t[1] > 2 ? "Gingerbread" : 3 === t[0] ? "Honeycomb" : 4 === t[0] && t[1] < 1 ? "Ice Cream Sandwich" : 4 === t[0] && t[1] < 4 ? "Jelly Bean" : 4 === t[0] && t[1] >= 4 ? "KitKat" : 5 === t[0] ? "Lollipop" : 6 === t[0] ? "Marshmallow" : 7 === t[0] ? "Nougat" : 8 === t[0] ? "Oreo" : 9 === t[0] ? "Pie" : void 0;
    }
    static getVersionPrecision(e1) {
        return e1.split(".").length;
    }
    static compareVersions(e1, t, n = !1) {
        const r = V.getVersionPrecision(e1), i = V.getVersionPrecision(t);
        let o = Math.max(r, i), a = 0;
        const s = V.map([
            e1,
            t
        ], (e1)=>{
            const t = o - V.getVersionPrecision(e1), n = e1 + new Array(t + 1).join(".0");
            return V.map(n.split("."), (e1)=>new Array(20 - e1.length).join("0") + e1).reverse();
        });
        for(n && (a = o - Math.min(r, i)), o -= 1; o >= a;){
            if (s[0][o] > s[1][o]) return 1;
            if (s[0][o] === s[1][o]) {
                if (o === a) return 0;
                o -= 1;
            } else if (s[0][o] < s[1][o]) return -1;
        }
    }
    static map(e1, t) {
        const n = [];
        let r;
        if (Array.prototype.map) return Array.prototype.map.call(e1, t);
        for(r = 0; r < e1.length; r += 1)n.push(t(e1[r]));
        return n;
    }
    static find(e1, t) {
        let n, r;
        if (Array.prototype.find) return Array.prototype.find.call(e1, t);
        for(n = 0, r = e1.length; n < r; n += 1){
            const r = e1[n];
            if (t(r, n)) return r;
        }
    }
    static assign(e1, ...t) {
        const n = e1;
        let r, i;
        if ("TURBOPACK compile-time truthy", 1) return Object.assign(e1, ...t);
        "TURBOPACK unreachable";
    }
    static getBrowserAlias(e1) {
        return N[e1];
    }
    static getBrowserTypeByAlias(e1) {
        return F[e1] || "";
    }
}
const J = /version\/(\d+(\.?_?\d+)+)/i, $ = [
    {
        test: [
            /googlebot/i
        ],
        describe (e1) {
            const t = {
                name: "Googlebot"
            }, n = V.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /opera/i
        ],
        describe (e1) {
            const t = {
                name: "Opera"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /opr\/|opios/i
        ],
        describe (e1) {
            const t = {
                name: "Opera"
            }, n = V.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /SamsungBrowser/i
        ],
        describe (e1) {
            const t = {
                name: "Samsung Internet for Android"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /Whale/i
        ],
        describe (e1) {
            const t = {
                name: "NAVER Whale Browser"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /MZBrowser/i
        ],
        describe (e1) {
            const t = {
                name: "MZ Browser"
            }, n = V.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /focus/i
        ],
        describe (e1) {
            const t = {
                name: "Focus"
            }, n = V.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /swing/i
        ],
        describe (e1) {
            const t = {
                name: "Swing"
            }, n = V.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /coast/i
        ],
        describe (e1) {
            const t = {
                name: "Opera Coast"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /opt\/\d+(?:.?_?\d+)+/i
        ],
        describe (e1) {
            const t = {
                name: "Opera Touch"
            }, n = V.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /yabrowser/i
        ],
        describe (e1) {
            const t = {
                name: "Yandex Browser"
            }, n = V.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /ucbrowser/i
        ],
        describe (e1) {
            const t = {
                name: "UC Browser"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /Maxthon|mxios/i
        ],
        describe (e1) {
            const t = {
                name: "Maxthon"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /epiphany/i
        ],
        describe (e1) {
            const t = {
                name: "Epiphany"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /puffin/i
        ],
        describe (e1) {
            const t = {
                name: "Puffin"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /sleipnir/i
        ],
        describe (e1) {
            const t = {
                name: "Sleipnir"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /k-meleon/i
        ],
        describe (e1) {
            const t = {
                name: "K-Meleon"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /micromessenger/i
        ],
        describe (e1) {
            const t = {
                name: "WeChat"
            }, n = V.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /qqbrowser/i
        ],
        describe (e1) {
            const t = {
                name: /qqbrowserlite/i.test(e1) ? "QQ Browser Lite" : "QQ Browser"
            }, n = V.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /msie|trident/i
        ],
        describe (e1) {
            const t = {
                name: "Internet Explorer"
            }, n = V.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /\sedg\//i
        ],
        describe (e1) {
            const t = {
                name: "Microsoft Edge"
            }, n = V.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /edg([ea]|ios)/i
        ],
        describe (e1) {
            const t = {
                name: "Microsoft Edge"
            }, n = V.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /vivaldi/i
        ],
        describe (e1) {
            const t = {
                name: "Vivaldi"
            }, n = V.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /seamonkey/i
        ],
        describe (e1) {
            const t = {
                name: "SeaMonkey"
            }, n = V.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /sailfish/i
        ],
        describe (e1) {
            const t = {
                name: "Sailfish"
            }, n = V.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /silk/i
        ],
        describe (e1) {
            const t = {
                name: "Amazon Silk"
            }, n = V.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /phantom/i
        ],
        describe (e1) {
            const t = {
                name: "PhantomJS"
            }, n = V.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /slimerjs/i
        ],
        describe (e1) {
            const t = {
                name: "SlimerJS"
            }, n = V.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /blackberry|\bbb\d+/i,
            /rim\stablet/i
        ],
        describe (e1) {
            const t = {
                name: "BlackBerry"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /(web|hpw)[o0]s/i
        ],
        describe (e1) {
            const t = {
                name: "WebOS Browser"
            }, n = V.getFirstMatch(J, e1) || V.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /bada/i
        ],
        describe (e1) {
            const t = {
                name: "Bada"
            }, n = V.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /tizen/i
        ],
        describe (e1) {
            const t = {
                name: "Tizen"
            }, n = V.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /qupzilla/i
        ],
        describe (e1) {
            const t = {
                name: "QupZilla"
            }, n = V.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /firefox|iceweasel|fxios/i
        ],
        describe (e1) {
            const t = {
                name: "Firefox"
            }, n = V.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /electron/i
        ],
        describe (e1) {
            const t = {
                name: "Electron"
            }, n = V.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /MiuiBrowser/i
        ],
        describe (e1) {
            const t = {
                name: "Miui"
            }, n = V.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /chromium/i
        ],
        describe (e1) {
            const t = {
                name: "Chromium"
            }, n = V.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e1) || V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /chrome|crios|crmo/i
        ],
        describe (e1) {
            const t = {
                name: "Chrome"
            }, n = V.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /GSA/i
        ],
        describe (e1) {
            const t = {
                name: "Google Search"
            }, n = V.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test (e1) {
            const t = !e1.test(/like android/i), n = e1.test(/android/i);
            return t && n;
        },
        describe (e1) {
            const t = {
                name: "Android Browser"
            }, n = V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /playstation 4/i
        ],
        describe (e1) {
            const t = {
                name: "PlayStation 4"
            }, n = V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /safari|applewebkit/i
        ],
        describe (e1) {
            const t = {
                name: "Safari"
            }, n = V.getFirstMatch(J, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /.*/i
        ],
        describe (e1) {
            const t = -1 !== e1.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
            return {
                name: V.getFirstMatch(t, e1),
                version: V.getSecondMatch(t, e1)
            };
        }
    }
];
var q = [
    {
        test: [
            /Roku\/DVP/
        ],
        describe (e1) {
            const t = V.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e1);
            return {
                name: B.Roku,
                version: t
            };
        }
    },
    {
        test: [
            /windows phone/i
        ],
        describe (e1) {
            const t = V.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e1);
            return {
                name: B.WindowsPhone,
                version: t
            };
        }
    },
    {
        test: [
            /windows /i
        ],
        describe (e1) {
            const t = V.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e1), n = V.getWindowsVersionName(t);
            return {
                name: B.Windows,
                version: t,
                versionName: n
            };
        }
    },
    {
        test: [
            /Macintosh(.*?) FxiOS(.*?)\//
        ],
        describe (e1) {
            const t = {
                name: B.iOS
            }, n = V.getSecondMatch(/(Version\/)(\d[\d.]+)/, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /macintosh/i
        ],
        describe (e1) {
            const t = V.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e1).replace(/[_\s]/g, "."), n = V.getMacOSVersionName(t), r = {
                name: B.MacOS,
                version: t
            };
            return n && (r.versionName = n), r;
        }
    },
    {
        test: [
            /(ipod|iphone|ipad)/i
        ],
        describe (e1) {
            const t = V.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e1).replace(/[_\s]/g, ".");
            return {
                name: B.iOS,
                version: t
            };
        }
    },
    {
        test (e1) {
            const t = !e1.test(/like android/i), n = e1.test(/android/i);
            return t && n;
        },
        describe (e1) {
            const t = V.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e1), n = V.getAndroidVersionName(t), r = {
                name: B.Android,
                version: t
            };
            return n && (r.versionName = n), r;
        }
    },
    {
        test: [
            /(web|hpw)[o0]s/i
        ],
        describe (e1) {
            const t = V.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e1), n = {
                name: B.WebOS
            };
            return t && t.length && (n.version = t), n;
        }
    },
    {
        test: [
            /blackberry|\bbb\d+/i,
            /rim\stablet/i
        ],
        describe (e1) {
            const t = V.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e1) || V.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e1) || V.getFirstMatch(/\bbb(\d+)/i, e1);
            return {
                name: B.BlackBerry,
                version: t
            };
        }
    },
    {
        test: [
            /bada/i
        ],
        describe (e1) {
            const t = V.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e1);
            return {
                name: B.Bada,
                version: t
            };
        }
    },
    {
        test: [
            /tizen/i
        ],
        describe (e1) {
            const t = V.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e1);
            return {
                name: B.Tizen,
                version: t
            };
        }
    },
    {
        test: [
            /linux/i
        ],
        describe: ()=>({
                name: B.Linux
            })
    },
    {
        test: [
            /CrOS/
        ],
        describe: ()=>({
                name: B.ChromeOS
            })
    },
    {
        test: [
            /PlayStation 4/
        ],
        describe (e1) {
            const t = V.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e1);
            return {
                name: B.PlayStation4,
                version: t
            };
        }
    }
], z = [
    {
        test: [
            /googlebot/i
        ],
        describe: ()=>({
                type: "bot",
                vendor: "Google"
            })
    },
    {
        test: [
            /huawei/i
        ],
        describe (e1) {
            const t = V.getFirstMatch(/(can-l01)/i, e1) && "Nova", n = {
                type: R.mobile,
                vendor: "Huawei"
            };
            return t && (n.model = t), n;
        }
    },
    {
        test: [
            /nexus\s*(?:7|8|9|10).*/i
        ],
        describe: ()=>({
                type: R.tablet,
                vendor: "Nexus"
            })
    },
    {
        test: [
            /ipad/i
        ],
        describe: ()=>({
                type: R.tablet,
                vendor: "Apple",
                model: "iPad"
            })
    },
    {
        test: [
            /Macintosh(.*?) FxiOS(.*?)\//
        ],
        describe: ()=>({
                type: R.tablet,
                vendor: "Apple",
                model: "iPad"
            })
    },
    {
        test: [
            /kftt build/i
        ],
        describe: ()=>({
                type: R.tablet,
                vendor: "Amazon",
                model: "Kindle Fire HD 7"
            })
    },
    {
        test: [
            /silk/i
        ],
        describe: ()=>({
                type: R.tablet,
                vendor: "Amazon"
            })
    },
    {
        test: [
            /tablet(?! pc)/i
        ],
        describe: ()=>({
                type: R.tablet
            })
    },
    {
        test (e1) {
            const t = e1.test(/ipod|iphone/i), n = e1.test(/like (ipod|iphone)/i);
            return t && !n;
        },
        describe (e1) {
            const t = V.getFirstMatch(/(ipod|iphone)/i, e1);
            return {
                type: R.mobile,
                vendor: "Apple",
                model: t
            };
        }
    },
    {
        test: [
            /nexus\s*[0-6].*/i,
            /galaxy nexus/i
        ],
        describe: ()=>({
                type: R.mobile,
                vendor: "Nexus"
            })
    },
    {
        test: [
            /[^-]mobi/i
        ],
        describe: ()=>({
                type: R.mobile
            })
    },
    {
        test: (e1)=>"blackberry" === e1.getBrowserName(!0),
        describe: ()=>({
                type: R.mobile,
                vendor: "BlackBerry"
            })
    },
    {
        test: (e1)=>"bada" === e1.getBrowserName(!0),
        describe: ()=>({
                type: R.mobile
            })
    },
    {
        test: (e1)=>"windows phone" === e1.getBrowserName(),
        describe: ()=>({
                type: R.mobile,
                vendor: "Microsoft"
            })
    },
    {
        test (e1) {
            const t = Number(String(e1.getOSVersion()).split(".")[0]);
            return "android" === e1.getOSName(!0) && t >= 3;
        },
        describe: ()=>({
                type: R.tablet
            })
    },
    {
        test: (e1)=>"android" === e1.getOSName(!0),
        describe: ()=>({
                type: R.mobile
            })
    },
    {
        test: (e1)=>"macos" === e1.getOSName(!0),
        describe: ()=>({
                type: R.desktop,
                vendor: "Apple"
            })
    },
    {
        test: (e1)=>"windows" === e1.getOSName(!0),
        describe: ()=>({
                type: R.desktop
            })
    },
    {
        test: (e1)=>"linux" === e1.getOSName(!0),
        describe: ()=>({
                type: R.desktop
            })
    },
    {
        test: (e1)=>"playstation 4" === e1.getOSName(!0),
        describe: ()=>({
                type: R.tv
            })
    },
    {
        test: (e1)=>"roku" === e1.getOSName(!0),
        describe: ()=>({
                type: R.tv
            })
    }
], W = [
    {
        test: (e1)=>"microsoft edge" === e1.getBrowserName(!0),
        describe (e1) {
            if (/\sedg\//i.test(e1)) return {
                name: U.Blink
            };
            const t = V.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e1);
            return {
                name: U.EdgeHTML,
                version: t
            };
        }
    },
    {
        test: [
            /trident/i
        ],
        describe (e1) {
            const t = {
                name: U.Trident
            }, n = V.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: (e1)=>e1.test(/presto/i),
        describe (e1) {
            const t = {
                name: U.Presto
            }, n = V.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test (e1) {
            const t = e1.test(/gecko/i), n = e1.test(/like gecko/i);
            return t && !n;
        },
        describe (e1) {
            const t = {
                name: U.Gecko
            }, n = V.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    },
    {
        test: [
            /(apple)?webkit\/537\.36/i
        ],
        describe: ()=>({
                name: U.Blink
            })
    },
    {
        test: [
            /(apple)?webkit/i
        ],
        describe (e1) {
            const t = {
                name: U.WebKit
            }, n = V.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e1);
            return n && (t.version = n), t;
        }
    }
];
class H {
    constructor(e1, t = !1){
        if (null == e1 || "" === e1) throw new Error("UserAgent parameter can't be empty");
        this._ua = e1, this.parsedResult = {}, !0 !== t && this.parse();
    }
    getUA() {
        return this._ua;
    }
    test(e1) {
        return e1.test(this._ua);
    }
    parseBrowser() {
        this.parsedResult.browser = {};
        const e1 = V.find($, (e1)=>{
            if ("function" == typeof e1.test) return e1.test(this);
            if (e1.test instanceof Array) return e1.test.some((e1)=>this.test(e1));
            throw new Error("Browser's test function is not valid");
        });
        return e1 && (this.parsedResult.browser = e1.describe(this.getUA())), this.parsedResult.browser;
    }
    getBrowser() {
        return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
    }
    getBrowserName(e1) {
        return e1 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
    }
    getBrowserVersion() {
        return this.getBrowser().version;
    }
    getOS() {
        return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
    }
    parseOS() {
        this.parsedResult.os = {};
        const e1 = V.find(q, (e1)=>{
            if ("function" == typeof e1.test) return e1.test(this);
            if (e1.test instanceof Array) return e1.test.some((e1)=>this.test(e1));
            throw new Error("Browser's test function is not valid");
        });
        return e1 && (this.parsedResult.os = e1.describe(this.getUA())), this.parsedResult.os;
    }
    getOSName(e1) {
        const { name: t } = this.getOS();
        return e1 ? String(t).toLowerCase() || "" : t || "";
    }
    getOSVersion() {
        return this.getOS().version;
    }
    getPlatform() {
        return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
    }
    getPlatformType(e1 = !1) {
        const { type: t } = this.getPlatform();
        return e1 ? String(t).toLowerCase() || "" : t || "";
    }
    parsePlatform() {
        this.parsedResult.platform = {};
        const e1 = V.find(z, (e1)=>{
            if ("function" == typeof e1.test) return e1.test(this);
            if (e1.test instanceof Array) return e1.test.some((e1)=>this.test(e1));
            throw new Error("Browser's test function is not valid");
        });
        return e1 && (this.parsedResult.platform = e1.describe(this.getUA())), this.parsedResult.platform;
    }
    getEngine() {
        return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
    }
    getEngineName(e1) {
        return e1 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
    }
    parseEngine() {
        this.parsedResult.engine = {};
        const e1 = V.find(W, (e1)=>{
            if ("function" == typeof e1.test) return e1.test(this);
            if (e1.test instanceof Array) return e1.test.some((e1)=>this.test(e1));
            throw new Error("Browser's test function is not valid");
        });
        return e1 && (this.parsedResult.engine = e1.describe(this.getUA())), this.parsedResult.engine;
    }
    parse() {
        return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
    }
    getResult() {
        return V.assign({}, this.parsedResult);
    }
    satisfies(e1) {
        const t = {};
        let n = 0;
        const r = {};
        let i = 0;
        if (Object.keys(e1).forEach((o)=>{
            const a = e1[o];
            "string" == typeof a ? (r[o] = a, i += 1) : "object" == typeof a && (t[o] = a, n += 1);
        }), n > 0) {
            const e1 = Object.keys(t), n = V.find(e1, (e1)=>this.isOS(e1));
            if (n) {
                const e1 = this.satisfies(t[n]);
                if (void 0 !== e1) return e1;
            }
            const r = V.find(e1, (e1)=>this.isPlatform(e1));
            if (r) {
                const e1 = this.satisfies(t[r]);
                if (void 0 !== e1) return e1;
            }
        }
        if (i > 0) {
            const e1 = Object.keys(r), t = V.find(e1, (e1)=>this.isBrowser(e1, !0));
            if (void 0 !== t) return this.compareVersion(r[t]);
        }
    }
    isBrowser(e1, t = !1) {
        const n = this.getBrowserName().toLowerCase();
        let r = e1.toLowerCase();
        const i = V.getBrowserTypeByAlias(r);
        return t && i && (r = i.toLowerCase()), r === n;
    }
    compareVersion(e1) {
        let t = [
            0
        ], n = e1, r = !1;
        const i = this.getBrowserVersion();
        if ("string" == typeof i) return ">" === e1[0] || "<" === e1[0] ? (n = e1.substr(1), "=" === e1[1] ? (r = !0, n = e1.substr(2)) : t = [], ">" === e1[0] ? t.push(1) : t.push(-1)) : "=" === e1[0] ? n = e1.substr(1) : "~" === e1[0] && (r = !0, n = e1.substr(1)), t.indexOf(V.compareVersions(i, n, r)) > -1;
    }
    isOS(e1) {
        return this.getOSName(!0) === String(e1).toLowerCase();
    }
    isPlatform(e1) {
        return this.getPlatformType(!0) === String(e1).toLowerCase();
    }
    isEngine(e1) {
        return this.getEngineName(!0) === String(e1).toLowerCase();
    }
    is(e1, t = !1) {
        return this.isBrowser(e1, t) || this.isOS(e1) || this.isPlatform(e1);
    }
    some(e1 = []) {
        return e1.some((e1)=>this.is(e1));
    }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */ class G {
    static getParser(e1, t = !1) {
        if ("string" != typeof e1) throw new Error("UserAgent should be a string");
        return new H(e1, t);
    }
    static parse(e1) {
        return new H(e1).getResult();
    }
    static get BROWSER_MAP() {
        return F;
    }
    static get ENGINE_MAP() {
        return U;
    }
    static get OS_MAP() {
        return B;
    }
    static get PLATFORMS_MAP() {
        return R;
    }
}
function Q() {
    return Date.now() + Math.random().toString();
}
function Y() {
    throw new Error("Method must be implemented in subclass");
}
function K(e1, t) {
    return null != t && t.proxyUrl ? t.proxyUrl + ("/" === t.proxyUrl.slice(-1) ? "" : "/") + e1.substring(8) : e1;
}
function X(e1) {
    return null != e1 && e1.callObjectBundleUrlOverride ? e1.callObjectBundleUrlOverride : K("https://c.daily.co/call-machine/versioned/".concat("0.75.2", "/static/call-machine-object-bundle.js"), e1);
}
function Z(e1) {
    try {
        new URL(e1);
    } catch (e1) {
        return !1;
    }
    return !0;
}
const ee = Object.prototype.toString;
function te(e1) {
    switch(ee.call(e1)){
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
            return !0;
        default:
            return de(e1, Error);
    }
}
function ne(e1, t) {
    return ee.call(e1) === `[object ${t}]`;
}
function re(e1) {
    return ne(e1, "ErrorEvent");
}
function ie(e1) {
    return ne(e1, "DOMError");
}
function oe(e1) {
    return ne(e1, "String");
}
function ae(e1) {
    return "object" == typeof e1 && null !== e1 && "__sentry_template_string__" in e1 && "__sentry_template_values__" in e1;
}
function se(e1) {
    return null === e1 || ae(e1) || "object" != typeof e1 && "function" != typeof e1;
}
function ce(e1) {
    return ne(e1, "Object");
}
function le(e1) {
    return "undefined" != typeof Event && de(e1, Event);
}
function ue(e1) {
    return Boolean(e1 && e1.then && "function" == typeof e1.then);
}
function de(e1, t) {
    try {
        return e1 instanceof t;
    } catch (e1) {
        return !1;
    }
}
function pe(e1) {
    return !("object" != typeof e1 || null === e1 || !e1.__isVue && !e1._isVue);
}
function he(e1, t = 0) {
    return "string" != typeof e1 || 0 === t || e1.length <= t ? e1 : `${e1.slice(0, t)}...`;
}
function fe(e1, t) {
    if (!Array.isArray(e1)) return "";
    const n = [];
    for(let t = 0; t < e1.length; t++){
        const r = e1[t];
        try {
            pe(r) ? n.push("[VueViewModel]") : n.push(String(r));
        } catch (e1) {
            n.push("[value cannot be serialized]");
        }
    }
    return n.join(t);
}
function ve(e1, t, n = !1) {
    return !!oe(e1) && (ne(t, "RegExp") ? t.test(e1) : !!oe(t) && (n ? e1 === t : e1.includes(t)));
}
function ge(e1, t = [], n = !1) {
    return t.some((t)=>ve(e1, t, n));
}
function me(e1, t, n = 250, r, i, o, a) {
    if (!(o.exception && o.exception.values && a && de(a.originalException, Error))) return;
    const s = o.exception.values.length > 0 ? o.exception.values[o.exception.values.length - 1] : void 0;
    var c, l;
    s && (o.exception.values = (c = ye(e1, t, i, a.originalException, r, o.exception.values, s, 0), l = n, c.map((e1)=>(e1.value && (e1.value = he(e1.value, l)), e1))));
}
function ye(e1, t, n, r, i, o, a, s) {
    if (o.length >= n + 1) return o;
    let c = [
        ...o
    ];
    if (de(r[i], Error)) {
        _e(a, s);
        const o = e1(t, r[i]), l = c.length;
        be(o, i, l, s), c = ye(e1, t, n, r[i], i, [
            o,
            ...c
        ], o, l);
    }
    return Array.isArray(r.errors) && r.errors.forEach((r, o)=>{
        if (de(r, Error)) {
            _e(a, s);
            const l = e1(t, r), u = c.length;
            be(l, `errors[${o}]`, u, s), c = ye(e1, t, n, r, i, [
                l,
                ...c
            ], l, u);
        }
    }), c;
}
function _e(e1, t) {
    e1.mechanism = e1.mechanism || {
        type: "generic",
        handled: !0
    }, e1.mechanism = {
        ...e1.mechanism,
        ..."AggregateError" === e1.type && {
            is_exception_group: !0
        },
        exception_id: t
    };
}
function be(e1, t, n, r) {
    e1.mechanism = e1.mechanism || {
        type: "generic",
        handled: !0
    }, e1.mechanism = {
        ...e1.mechanism,
        type: "chained",
        source: t,
        exception_id: n,
        parent_id: r
    };
}
function we(e1) {
    return void 0 === e1 ? void 0 : e1 >= 400 && e1 < 500 ? "warning" : e1 >= 500 ? "error" : void 0;
}
const ke = "8.33.1", Se = globalThis;
function Me(e1, t, n) {
    const r = n || Se, i = r.__SENTRY__ = r.__SENTRY__ || {}, o = i[ke] = i[ke] || {};
    return o[e1] || (o[e1] = t());
}
const Ce = Se;
function Ee(e1, t = {}) {
    if (!e1) return "<unknown>";
    try {
        let n = e1;
        const r = 5, i = [];
        let o = 0, a = 0;
        const s = " > ", c = s.length;
        let l;
        const u = Array.isArray(t) ? t : t.keyAttrs, d = !Array.isArray(t) && t.maxStringLength || 80;
        for(; n && o++ < r && (l = Te(n, u), !("html" === l || o > 1 && a + i.length * c + l.length >= d));)i.push(l), a += l.length, n = n.parentNode;
        return i.reverse().join(s);
    } catch (e1) {
        return "<unknown>";
    }
}
function Te(e1, t) {
    const n = e1, r = [];
    if (!n || !n.tagName) return "";
    if (Ce.HTMLElement && n instanceof HTMLElement && n.dataset) {
        if (n.dataset.sentryComponent) return n.dataset.sentryComponent;
        if (n.dataset.sentryElement) return n.dataset.sentryElement;
    }
    r.push(n.tagName.toLowerCase());
    const i = t && t.length ? t.filter((e1)=>n.getAttribute(e1)).map((e1)=>[
            e1,
            n.getAttribute(e1)
        ]) : null;
    if (i && i.length) i.forEach((e1)=>{
        r.push(`[${e1[0]}="${e1[1]}"]`);
    });
    else {
        n.id && r.push(`#${n.id}`);
        const e1 = n.className;
        if (e1 && oe(e1)) {
            const t = e1.split(/\s+/);
            for (const e1 of t)r.push(`.${e1}`);
        }
    }
    const o = [
        "aria-label",
        "type",
        "name",
        "title",
        "alt"
    ];
    for (const e1 of o){
        const t = n.getAttribute(e1);
        t && r.push(`[${e1}="${t}"]`);
    }
    return r.join("");
}
const Pe = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, Oe = [
    "debug",
    "info",
    "warn",
    "error",
    "log",
    "assert",
    "trace"
], Ae = {};
function je(e1) {
    if (!("console" in Se)) return e1();
    const t = Se.console, n = {}, r = Object.keys(Ae);
    r.forEach((e1)=>{
        const r = Ae[e1];
        n[e1] = t[e1], t[e1] = r;
    });
    try {
        return e1();
    } finally{
        r.forEach((e1)=>{
            t[e1] = n[e1];
        });
    }
}
const Le = Me("logger", function() {
    let e1 = !1;
    const t = {
        enable: ()=>{
            e1 = !0;
        },
        disable: ()=>{
            e1 = !1;
        },
        isEnabled: ()=>e1
    };
    return Pe ? Oe.forEach((n)=>{
        t[n] = (...t)=>{
            e1 && je(()=>{
                Se.console[n](`Sentry Logger [${n}]:`, ...t);
            });
        };
    }) : Oe.forEach((e1)=>{
        t[e1] = ()=>{};
    }), t;
}), xe = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function Ie(e1, t = !1) {
    const { host: n, path: r, pass: i, port: o, projectId: a, protocol: s, publicKey: c } = e1;
    return `${s}://${c}${t && i ? `:${i}` : ""}@${n}${o ? `:${o}` : ""}/${r ? `${r}/` : r}${a}`;
}
function De(e1) {
    return {
        protocol: e1.protocol,
        publicKey: e1.publicKey || "",
        pass: e1.pass || "",
        host: e1.host,
        port: e1.port || "",
        path: e1.path || "",
        projectId: e1.projectId
    };
}
function Ne(e1) {
    const t = "string" == typeof e1 ? function(e1) {
        const t = xe.exec(e1);
        if (!t) return void je(()=>{
            console.error(`Invalid Sentry Dsn: ${e1}`);
        });
        const [n, r, i = "", o = "", a = "", s = ""] = t.slice(1);
        let c = "", l = s;
        const u = l.split("/");
        if (u.length > 1 && (c = u.slice(0, -1).join("/"), l = u.pop()), l) {
            const e1 = l.match(/^\d+/);
            e1 && (l = e1[0]);
        }
        return De({
            host: o,
            pass: i,
            path: c,
            projectId: l,
            port: a,
            protocol: n,
            publicKey: r
        });
    }(e1) : De(e1);
    if (t && function(e1) {
        if (!Pe) return !0;
        const { port: t, projectId: n, protocol: r } = e1;
        return !([
            "protocol",
            "publicKey",
            "host",
            "projectId"
        ].find((t)=>!e1[t] && (Le.error(`Invalid Sentry Dsn: ${t} missing`), !0)) || (n.match(/^\d+$/) ? function(e1) {
            return "http" === e1 || "https" === e1;
        }(r) ? t && isNaN(parseInt(t, 10)) && (Le.error(`Invalid Sentry Dsn: Invalid port ${t}`), 1) : (Le.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), 1) : (Le.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), 1)));
    }(t)) return t;
}
class Fe extends Error {
    constructor(e1, t = "warn"){
        super(e1), this.message = e1, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = t;
    }
}
function Re(e1, t, n) {
    if (!(t in e1)) return;
    const r = e1[t], i = n(r);
    "function" == typeof i && Ue(i, r), e1[t] = i;
}
function Be(e1, t, n) {
    try {
        Object.defineProperty(e1, t, {
            value: n,
            writable: !0,
            configurable: !0
        });
    } catch (n) {
        Pe && Le.log(`Failed to add non-enumerable property "${t}" to object`, e1);
    }
}
function Ue(e1, t) {
    try {
        const n = t.prototype || {};
        e1.prototype = t.prototype = n, Be(e1, "__sentry_original__", t);
    } catch (e1) {}
}
function Ve(e1) {
    return e1.__sentry_original__;
}
function Je(e1) {
    if (te(e1)) return {
        message: e1.message,
        name: e1.name,
        stack: e1.stack,
        ...qe(e1)
    };
    if (le(e1)) {
        const t = {
            type: e1.type,
            target: $e(e1.target),
            currentTarget: $e(e1.currentTarget),
            ...qe(e1)
        };
        return "undefined" != typeof CustomEvent && de(e1, CustomEvent) && (t.detail = e1.detail), t;
    }
    return e1;
}
function $e(e1) {
    try {
        return t = e1, "undefined" != typeof Element && de(t, Element) ? Ee(e1) : Object.prototype.toString.call(e1);
    } catch (e1) {
        return "<unknown>";
    }
    var t;
}
function qe(e1) {
    if ("object" == typeof e1 && null !== e1) {
        const t = {};
        for(const n in e1)Object.prototype.hasOwnProperty.call(e1, n) && (t[n] = e1[n]);
        return t;
    }
    return {};
}
function ze(e1) {
    return We(e1, new Map);
}
function We(e1, t) {
    if (function(e1) {
        if (!ce(e1)) return !1;
        try {
            const t = Object.getPrototypeOf(e1).constructor.name;
            return !t || "Object" === t;
        } catch (e1) {
            return !0;
        }
    }(e1)) {
        const n = t.get(e1);
        if (void 0 !== n) return n;
        const r = {};
        t.set(e1, r);
        for (const n of Object.getOwnPropertyNames(e1))void 0 !== e1[n] && (r[n] = We(e1[n], t));
        return r;
    }
    if (Array.isArray(e1)) {
        const n = t.get(e1);
        if (void 0 !== n) return n;
        const r = [];
        return t.set(e1, r), e1.forEach((e1)=>{
            r.push(We(e1, t));
        }), r;
    }
    return e1;
}
const He = "?", Ge = /\(error: (.*)\)/, Qe = /captureMessage|captureException/;
function Ye(e1) {
    return e1[e1.length - 1] || {};
}
const Ke = "<anonymous>";
function Xe(e1) {
    try {
        return e1 && "function" == typeof e1 && e1.name || Ke;
    } catch (e1) {
        return Ke;
    }
}
function Ze(e1) {
    const t = e1.exception;
    if (t) {
        const e1 = [];
        try {
            return t.values.forEach((t)=>{
                t.stacktrace.frames && e1.push(...t.stacktrace.frames);
            }), e1;
        } catch (e1) {
            return;
        }
    }
}
const et = {}, tt = {};
function nt(e1, t) {
    et[e1] = et[e1] || [], et[e1].push(t);
}
function rt(e1, t) {
    tt[e1] || (t(), tt[e1] = !0);
}
function it(e1, t) {
    const n = e1 && et[e1];
    if (n) for (const r of n)try {
        r(t);
    } catch (t) {
        Pe && Le.error(`Error while triggering instrumentation handler.\nType: ${e1}\nName: ${Xe(r)}\nError:`, t);
    }
}
function ot() {
    "console" in Se && Oe.forEach(function(e1) {
        e1 in Se.console && Re(Se.console, e1, function(t) {
            return Ae[e1] = t, function(...t) {
                it("console", {
                    args: t,
                    level: e1
                });
                const n = Ae[e1];
                n && n.apply(Se.console, t);
            };
        });
    });
}
const at = Se;
function st(e1) {
    return e1 && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(e1.toString());
}
function ct() {
    if ("string" == typeof EdgeRuntime) return !0;
    if (!function() {
        if (!("fetch" in at)) return !1;
        try {
            return new Headers, new Request("http://www.example.com"), new Response, !0;
        } catch (e1) {
            return !1;
        }
    }()) return !1;
    if (st(at.fetch)) return !0;
    let e1 = !1;
    const t = at.document;
    if (t && "function" == typeof t.createElement) try {
        const n = t.createElement("iframe");
        n.hidden = !0, t.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (e1 = st(n.contentWindow.fetch)), t.head.removeChild(n);
    } catch (e1) {
        Pe && Le.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e1);
    }
    return e1;
}
function lt() {
    return Date.now() / 1e3;
}
const ut = function() {
    const { performance: e1 } = Se;
    if (!e1 || !e1.now) return lt;
    const t = Date.now() - e1.now(), n = null == e1.timeOrigin ? t : e1.timeOrigin;
    return ()=>(n + e1.now()) / 1e3;
}();
function dt(e1, t) {
    const n = "fetch";
    nt(n, e1), rt(n, ()=>(function(e1, t = !1) {
            if (t && !ct()) return;
            Re(Se, "fetch", function(t) {
                return function(...n) {
                    const { method: r, url: i } = function(e1) {
                        if (0 === e1.length) return {
                            method: "GET",
                            url: ""
                        };
                        if (2 === e1.length) {
                            const [t, n] = e1;
                            return {
                                url: ht(t),
                                method: pt(n, "method") ? String(n.method).toUpperCase() : "GET"
                            };
                        }
                        const t = e1[0];
                        return {
                            url: ht(t),
                            method: pt(t, "method") ? String(t.method).toUpperCase() : "GET"
                        };
                    }(n), o = {
                        args: n,
                        fetchData: {
                            method: r,
                            url: i
                        },
                        startTimestamp: 1e3 * ut()
                    };
                    e1 || it("fetch", {
                        ...o
                    });
                    const a = (new Error).stack;
                    return t.apply(Se, n).then(async (t)=>(e1 ? e1(t) : it("fetch", {
                            ...o,
                            endTimestamp: 1e3 * ut(),
                            response: t
                        }), t), (e1)=>{
                        throw it("fetch", {
                            ...o,
                            endTimestamp: 1e3 * ut(),
                            error: e1
                        }), te(e1) && void 0 === e1.stack && (e1.stack = a, Be(e1, "framesToPop", 1)), e1;
                    });
                };
            });
        })(void 0, t));
}
function pt(e1, t) {
    return !!e1 && "object" == typeof e1 && !!e1[t];
}
function ht(e1) {
    return "string" == typeof e1 ? e1 : e1 ? pt(e1, "url") ? e1.url : e1.toString ? e1.toString() : "" : "";
}
(()=>{
    const { performance: e1 } = Se;
    if (!e1 || !e1.now) return;
    const t = 36e5, n = e1.now(), r = Date.now(), i = e1.timeOrigin ? Math.abs(e1.timeOrigin + n - r) : t, o = i < t, a = e1.timing && e1.timing.navigationStart, s = "number" == typeof a ? Math.abs(a + n - r) : t;
    (o || s < t) && i <= s && e1.timeOrigin;
})();
let ft = null;
function vt() {
    ft = Se.onerror, Se.onerror = function(e1, t, n, r, i) {
        return it("error", {
            column: r,
            error: i,
            line: n,
            msg: e1,
            url: t
        }), !(!ft || ft.__SENTRY_LOADER__) && ft.apply(this, arguments);
    }, Se.onerror.__SENTRY_INSTRUMENTED__ = !0;
}
let gt = null;
function mt() {
    gt = Se.onunhandledrejection, Se.onunhandledrejection = function(e1) {
        return it("unhandledrejection", e1), !(gt && !gt.__SENTRY_LOADER__) || gt.apply(this, arguments);
    }, Se.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0;
}
function yt() {
    const e1 = Se, t = e1.crypto || e1.msCrypto;
    let n = ()=>16 * Math.random();
    try {
        if (t && t.randomUUID) return t.randomUUID().replace(/-/g, "");
        t && t.getRandomValues && (n = ()=>{
            const e1 = new Uint8Array(1);
            return t.getRandomValues(e1), e1[0];
        });
    } catch (e1) {}
    return ([
        1e7
    ] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (e1)=>(e1 ^ (15 & n()) >> e1 / 4).toString(16));
}
function _t(e1) {
    return e1.exception && e1.exception.values ? e1.exception.values[0] : void 0;
}
function bt(e1) {
    const { message: t, event_id: n } = e1;
    if (t) return t;
    const r = _t(e1);
    return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>";
}
function wt(e1, t, n) {
    const r = e1.exception = e1.exception || {}, i = r.values = r.values || [], o = i[0] = i[0] || {};
    o.value || (o.value = t || ""), o.type || (o.type = n || "Error");
}
function kt(e1, t) {
    const n = _t(e1);
    if (!n) return;
    const r = n.mechanism;
    if (n.mechanism = {
        type: "generic",
        handled: !0,
        ...r,
        ...t
    }, t && "data" in t) {
        const e1 = {
            ...r && r.data,
            ...t.data
        };
        n.mechanism.data = e1;
    }
}
function St(e1) {
    if (e1 && e1.__sentry_captured__) return !0;
    try {
        Be(e1, "__sentry_captured__", !0);
    } catch (e1) {}
    return !1;
}
function Mt(e1, t = 100, n = 1 / 0) {
    try {
        return Et("", e1, t, n);
    } catch (e1) {
        return {
            ERROR: `**non-serializable** (${e1})`
        };
    }
}
function Ct(e1, t = 3, n = 102400) {
    const r = Mt(e1, t);
    return i = r, function(e1) {
        return ~-encodeURI(e1).split(/%..|./).length;
    }(JSON.stringify(i)) > n ? Ct(e1, t - 1, n) : r;
    "TURBOPACK unreachable";
    var i;
}
function Et(e1, t, n = 1 / 0, r = 1 / 0, i = function() {
    const e1 = "function" == typeof WeakSet, t = e1 ? new WeakSet : [];
    return [
        function(n) {
            if (e1) return !!t.has(n) || (t.add(n), !1);
            for(let e1 = 0; e1 < t.length; e1++)if (t[e1] === n) return !0;
            return t.push(n), !1;
        },
        function(n) {
            if (e1) t.delete(n);
            else for(let e1 = 0; e1 < t.length; e1++)if (t[e1] === n) {
                t.splice(e1, 1);
                break;
            }
        }
    ];
}()) {
    const [o, a] = i;
    if (null == t || [
        "boolean",
        "string"
    ].includes(typeof t) || "number" == typeof t && Number.isFinite(t)) return t;
    const s = function(e1, t) {
        try {
            if ("domain" === e1 && t && "object" == typeof t && t._events) return "[Domain]";
            if ("domainEmitter" === e1) return "[DomainEmitter]";
            if ("undefined" != typeof global && t === global) return "[Global]";
            if ("undefined" != typeof window && t === window) return "[Window]";
            if ("undefined" != typeof document && t === document) return "[Document]";
            if (pe(t)) return "[VueViewModel]";
            if (ce(n = t) && "nativeEvent" in n && "preventDefault" in n && "stopPropagation" in n) return "[SyntheticEvent]";
            if ("number" == typeof t && !Number.isFinite(t)) return `[${t}]`;
            if ("function" == typeof t) return `[Function: ${Xe(t)}]`;
            if ("symbol" == typeof t) return `[${String(t)}]`;
            if ("bigint" == typeof t) return `[BigInt: ${String(t)}]`;
            const r = function(e1) {
                const t = Object.getPrototypeOf(e1);
                return t ? t.constructor.name : "null prototype";
            }(t);
            return /^HTML(\w*)Element$/.test(r) ? `[HTMLElement: ${r}]` : `[object ${r}]`;
        } catch (e1) {
            return `**non-serializable** (${e1})`;
        }
        var n;
    }(e1, t);
    if (!s.startsWith("[object ")) return s;
    if (t.__sentry_skip_normalization__) return t;
    const c = "number" == typeof t.__sentry_override_normalization_depth__ ? t.__sentry_override_normalization_depth__ : n;
    if (0 === c) return s.replace("object ", "");
    if (o(t)) return "[Circular ~]";
    const l = t;
    if (l && "function" == typeof l.toJSON) try {
        return Et("", l.toJSON(), c - 1, r, i);
    } catch (e1) {}
    const u = Array.isArray(t) ? [] : {};
    let d = 0;
    const p = Je(t);
    for(const e1 in p){
        if (!Object.prototype.hasOwnProperty.call(p, e1)) continue;
        if (d >= r) {
            u[e1] = "[MaxProperties ~]";
            break;
        }
        const t = p[e1];
        u[e1] = Et(e1, t, c - 1, r, i), d++;
    }
    return a(t), u;
}
var Tt;
function Pt(e1) {
    return new At((t)=>{
        t(e1);
    });
}
function Ot(e1) {
    return new At((t, n)=>{
        n(e1);
    });
}
!function(e1) {
    e1[e1.PENDING = 0] = "PENDING";
    e1[e1.RESOLVED = 1] = "RESOLVED";
    e1[e1.REJECTED = 2] = "REJECTED";
}(Tt || (Tt = {}));
class At {
    constructor(e1){
        At.prototype.__init.call(this), At.prototype.__init2.call(this), At.prototype.__init3.call(this), At.prototype.__init4.call(this), this._state = Tt.PENDING, this._handlers = [];
        try {
            e1(this._resolve, this._reject);
        } catch (e1) {
            this._reject(e1);
        }
    }
    then(e1, t) {
        return new At((n, r)=>{
            this._handlers.push([
                !1,
                (t)=>{
                    if (e1) try {
                        n(e1(t));
                    } catch (e1) {
                        r(e1);
                    }
                    else n(t);
                },
                (e1)=>{
                    if (t) try {
                        n(t(e1));
                    } catch (e1) {
                        r(e1);
                    }
                    else r(e1);
                }
            ]), this._executeHandlers();
        });
    }
    catch(e1) {
        return this.then((e1)=>e1, e1);
    }
    finally(e1) {
        return new At((t, n)=>{
            let r, i;
            return this.then((t)=>{
                i = !1, r = t, e1 && e1();
            }, (t)=>{
                i = !0, r = t, e1 && e1();
            }).then(()=>{
                i ? n(r) : t(r);
            });
        });
    }
    __init() {
        this._resolve = (e1)=>{
            this._setResult(Tt.RESOLVED, e1);
        };
    }
    __init2() {
        this._reject = (e1)=>{
            this._setResult(Tt.REJECTED, e1);
        };
    }
    __init3() {
        this._setResult = (e1, t)=>{
            this._state === Tt.PENDING && (ue(t) ? t.then(this._resolve, this._reject) : (this._state = e1, this._value = t, this._executeHandlers()));
        };
    }
    __init4() {
        this._executeHandlers = ()=>{
            if (this._state === Tt.PENDING) return;
            const e1 = this._handlers.slice();
            this._handlers = [], e1.forEach((e1)=>{
                e1[0] || (this._state === Tt.RESOLVED && e1[1](this._value), this._state === Tt.REJECTED && e1[2](this._value), e1[0] = !0);
            });
        };
    }
}
function jt(e1) {
    const t = [];
    function n(e1) {
        return t.splice(t.indexOf(e1), 1)[0] || Promise.resolve(void 0);
    }
    return {
        $: t,
        add: function(r) {
            if (!(void 0 === e1 || t.length < e1)) return Ot(new Fe("Not adding Promise because buffer limit was reached."));
            const i = r();
            return -1 === t.indexOf(i) && t.push(i), i.then(()=>n(i)).then(null, ()=>n(i).then(null, ()=>{})), i;
        },
        drain: function(e1) {
            return new At((n, r)=>{
                let i = t.length;
                if (!i) return n(!0);
                const o = setTimeout(()=>{
                    e1 && e1 > 0 && n(!1);
                }, e1);
                t.forEach((e1)=>{
                    Pt(e1).then(()=>{
                        --i || (clearTimeout(o), n(!0));
                    }, r);
                });
            });
        }
    };
}
function Lt(e1) {
    if (!e1) return {};
    const t = e1.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!t) return {};
    const n = t[6] || "", r = t[8] || "";
    return {
        host: t[4],
        path: t[5],
        protocol: t[2],
        search: n,
        hash: r,
        relative: t[5] + n + r
    };
}
const xt = [
    "fatal",
    "error",
    "warning",
    "log",
    "info",
    "debug"
];
function It(e1) {
    return "warn" === e1 ? "warning" : xt.includes(e1) ? e1 : "log";
}
const Dt = /^sentry-/;
function Nt(e1) {
    const t = function(e1) {
        if (!e1 || !oe(e1) && !Array.isArray(e1)) return;
        if (Array.isArray(e1)) return e1.reduce((e1, t)=>{
            const n = Ft(t);
            return Object.entries(n).forEach(([t, n])=>{
                e1[t] = n;
            }), e1;
        }, {});
        return Ft(e1);
    }(e1);
    if (!t) return;
    const n = Object.entries(t).reduce((e1, [t, n])=>{
        if (t.match(Dt)) {
            e1[t.slice(7)] = n;
        }
        return e1;
    }, {});
    return Object.keys(n).length > 0 ? n : void 0;
}
function Ft(e1) {
    return e1.split(",").map((e1)=>e1.split("=").map((e1)=>decodeURIComponent(e1.trim()))).reduce((e1, [t, n])=>(t && n && (e1[t] = n), e1), {});
}
function Rt(e1, t = []) {
    return [
        e1,
        t
    ];
}
function Bt(e1, t) {
    const [n, r] = e1;
    return [
        n,
        [
            ...r,
            t
        ]
    ];
}
function Ut(e1, t) {
    const n = e1[1];
    for (const e1 of n){
        if (t(e1, e1[0].type)) return !0;
    }
    return !1;
}
function Vt(e1) {
    return Se.__SENTRY__ && Se.__SENTRY__.encodePolyfill ? Se.__SENTRY__.encodePolyfill(e1) : (new TextEncoder).encode(e1);
}
function Jt(e1) {
    const [t, n] = e1;
    let r = JSON.stringify(t);
    function i(e1) {
        "string" == typeof r ? r = "string" == typeof e1 ? r + e1 : [
            Vt(r),
            e1
        ] : r.push("string" == typeof e1 ? Vt(e1) : e1);
    }
    for (const e1 of n){
        const [t, n] = e1;
        if (i(`\n${JSON.stringify(t)}\n`), "string" == typeof n || n instanceof Uint8Array) i(n);
        else {
            let e1;
            try {
                e1 = JSON.stringify(n);
            } catch (t) {
                e1 = JSON.stringify(Mt(n));
            }
            i(e1);
        }
    }
    return "string" == typeof r ? r : function(e1) {
        const t = e1.reduce((e1, t)=>e1 + t.length, 0), n = new Uint8Array(t);
        let r = 0;
        for (const t of e1)n.set(t, r), r += t.length;
        return n;
    }(r);
}
function $t(e1) {
    const t = "string" == typeof e1.data ? Vt(e1.data) : e1.data;
    return [
        ze({
            type: "attachment",
            length: t.length,
            filename: e1.filename,
            content_type: e1.contentType,
            attachment_type: e1.attachmentType
        }),
        t
    ];
}
const qt = {
    session: "session",
    sessions: "session",
    attachment: "attachment",
    transaction: "transaction",
    event: "error",
    client_report: "internal",
    user_report: "default",
    profile: "profile",
    profile_chunk: "profile",
    replay_event: "replay",
    replay_recording: "replay",
    check_in: "monitor",
    feedback: "feedback",
    span: "span",
    statsd: "metric_bucket"
};
function zt(e1) {
    return qt[e1];
}
function Wt(e1) {
    if (!e1 || !e1.sdk) return;
    const { name: t, version: n } = e1.sdk;
    return {
        name: t,
        version: n
    };
}
function Ht(e1, { statusCode: t, headers: n }, r = Date.now()) {
    const i = {
        ...e1
    }, o = n && n["x-sentry-rate-limits"], a = n && n["retry-after"];
    if (o) for (const e1 of o.trim().split(",")){
        const [t, n, , , o] = e1.split(":", 5), a = parseInt(t, 10), s = 1e3 * (isNaN(a) ? 60 : a);
        if (n) for (const e1 of n.split(";"))"metric_bucket" === e1 && o && !o.split(";").includes("custom") || (i[e1] = r + s);
        else i.all = r + s;
    }
    else a ? i.all = r + function(e1, t = Date.now()) {
        const n = parseInt(`${e1}`, 10);
        if (!isNaN(n)) return 1e3 * n;
        const r = Date.parse(`${e1}`);
        return isNaN(r) ? 6e4 : r - t;
    }(a, r) : 429 === t && (i.all = r + 6e4);
    return i;
}
function Gt() {
    return {
        traceId: yt(),
        spanId: yt().substring(16)
    };
}
const Qt = Se;
const Yt = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
function Kt() {
    return Xt(Se), Se;
}
function Xt(e1) {
    const t = e1.__SENTRY__ = e1.__SENTRY__ || {};
    return t.version = t.version || ke, t[ke] = t[ke] || {};
}
function Zt(e1, t = {}) {
    if (t.user && (!e1.ipAddress && t.user.ip_address && (e1.ipAddress = t.user.ip_address), e1.did || t.did || (e1.did = t.user.id || t.user.email || t.user.username)), e1.timestamp = t.timestamp || ut(), t.abnormal_mechanism && (e1.abnormal_mechanism = t.abnormal_mechanism), t.ignoreDuration && (e1.ignoreDuration = t.ignoreDuration), t.sid && (e1.sid = 32 === t.sid.length ? t.sid : yt()), void 0 !== t.init && (e1.init = t.init), !e1.did && t.did && (e1.did = `${t.did}`), "number" == typeof t.started && (e1.started = t.started), e1.ignoreDuration) e1.duration = void 0;
    else if ("number" == typeof t.duration) e1.duration = t.duration;
    else {
        const t = e1.timestamp - e1.started;
        e1.duration = t >= 0 ? t : 0;
    }
    t.release && (e1.release = t.release), t.environment && (e1.environment = t.environment), !e1.ipAddress && t.ipAddress && (e1.ipAddress = t.ipAddress), !e1.userAgent && t.userAgent && (e1.userAgent = t.userAgent), "number" == typeof t.errors && (e1.errors = t.errors), t.status && (e1.status = t.status);
}
const en = "_sentrySpan";
function tn(e1, t) {
    t ? Be(e1, en, t) : delete e1[en];
}
function nn(e1) {
    return e1[en];
}
class rn {
    constructor(){
        this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = Gt();
    }
    clone() {
        const e1 = new rn;
        return e1._breadcrumbs = [
            ...this._breadcrumbs
        ], e1._tags = {
            ...this._tags
        }, e1._extra = {
            ...this._extra
        }, e1._contexts = {
            ...this._contexts
        }, e1._user = this._user, e1._level = this._level, e1._session = this._session, e1._transactionName = this._transactionName, e1._fingerprint = this._fingerprint, e1._eventProcessors = [
            ...this._eventProcessors
        ], e1._requestSession = this._requestSession, e1._attachments = [
            ...this._attachments
        ], e1._sdkProcessingMetadata = {
            ...this._sdkProcessingMetadata
        }, e1._propagationContext = {
            ...this._propagationContext
        }, e1._client = this._client, e1._lastEventId = this._lastEventId, tn(e1, nn(this)), e1;
    }
    setClient(e1) {
        this._client = e1;
    }
    setLastEventId(e1) {
        this._lastEventId = e1;
    }
    getClient() {
        return this._client;
    }
    lastEventId() {
        return this._lastEventId;
    }
    addScopeListener(e1) {
        this._scopeListeners.push(e1);
    }
    addEventProcessor(e1) {
        return this._eventProcessors.push(e1), this;
    }
    setUser(e1) {
        return this._user = e1 || {
            email: void 0,
            id: void 0,
            ip_address: void 0,
            username: void 0
        }, this._session && Zt(this._session, {
            user: e1
        }), this._notifyScopeListeners(), this;
    }
    getUser() {
        return this._user;
    }
    getRequestSession() {
        return this._requestSession;
    }
    setRequestSession(e1) {
        return this._requestSession = e1, this;
    }
    setTags(e1) {
        return this._tags = {
            ...this._tags,
            ...e1
        }, this._notifyScopeListeners(), this;
    }
    setTag(e1, t) {
        return this._tags = {
            ...this._tags,
            [e1]: t
        }, this._notifyScopeListeners(), this;
    }
    setExtras(e1) {
        return this._extra = {
            ...this._extra,
            ...e1
        }, this._notifyScopeListeners(), this;
    }
    setExtra(e1, t) {
        return this._extra = {
            ...this._extra,
            [e1]: t
        }, this._notifyScopeListeners(), this;
    }
    setFingerprint(e1) {
        return this._fingerprint = e1, this._notifyScopeListeners(), this;
    }
    setLevel(e1) {
        return this._level = e1, this._notifyScopeListeners(), this;
    }
    setTransactionName(e1) {
        return this._transactionName = e1, this._notifyScopeListeners(), this;
    }
    setContext(e1, t) {
        return null === t ? delete this._contexts[e1] : this._contexts[e1] = t, this._notifyScopeListeners(), this;
    }
    setSession(e1) {
        return e1 ? this._session = e1 : delete this._session, this._notifyScopeListeners(), this;
    }
    getSession() {
        return this._session;
    }
    update(e1) {
        if (!e1) return this;
        const t = "function" == typeof e1 ? e1(this) : e1, [n, r] = t instanceof on ? [
            t.getScopeData(),
            t.getRequestSession()
        ] : ce(t) ? [
            e1,
            e1.requestSession
        ] : [], { tags: i, extra: o, user: a, contexts: s, level: c, fingerprint: l = [], propagationContext: u } = n || {};
        return this._tags = {
            ...this._tags,
            ...i
        }, this._extra = {
            ...this._extra,
            ...o
        }, this._contexts = {
            ...this._contexts,
            ...s
        }, a && Object.keys(a).length && (this._user = a), c && (this._level = c), l.length && (this._fingerprint = l), u && (this._propagationContext = u), r && (this._requestSession = r), this;
    }
    clear() {
        return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, tn(this, void 0), this._attachments = [], this._propagationContext = Gt(), this._notifyScopeListeners(), this;
    }
    addBreadcrumb(e1, t) {
        const n = "number" == typeof t ? t : 100;
        if (n <= 0) return this;
        const r = {
            timestamp: lt(),
            ...e1
        }, i = this._breadcrumbs;
        return i.push(r), this._breadcrumbs = i.length > n ? i.slice(-n) : i, this._notifyScopeListeners(), this;
    }
    getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1];
    }
    clearBreadcrumbs() {
        return this._breadcrumbs = [], this._notifyScopeListeners(), this;
    }
    addAttachment(e1) {
        return this._attachments.push(e1), this;
    }
    clearAttachments() {
        return this._attachments = [], this;
    }
    getScopeData() {
        return {
            breadcrumbs: this._breadcrumbs,
            attachments: this._attachments,
            contexts: this._contexts,
            tags: this._tags,
            extra: this._extra,
            user: this._user,
            level: this._level,
            fingerprint: this._fingerprint || [],
            eventProcessors: this._eventProcessors,
            propagationContext: this._propagationContext,
            sdkProcessingMetadata: this._sdkProcessingMetadata,
            transactionName: this._transactionName,
            span: nn(this)
        };
    }
    setSDKProcessingMetadata(e1) {
        return this._sdkProcessingMetadata = {
            ...this._sdkProcessingMetadata,
            ...e1
        }, this;
    }
    setPropagationContext(e1) {
        return this._propagationContext = e1, this;
    }
    getPropagationContext() {
        return this._propagationContext;
    }
    captureException(e1, t) {
        const n = t && t.event_id ? t.event_id : yt();
        if (!this._client) return Le.warn("No client configured on scope - will not capture exception!"), n;
        const r = new Error("Sentry syntheticException");
        return this._client.captureException(e1, {
            originalException: e1,
            syntheticException: r,
            ...t,
            event_id: n
        }, this), n;
    }
    captureMessage(e1, t, n) {
        const r = n && n.event_id ? n.event_id : yt();
        if (!this._client) return Le.warn("No client configured on scope - will not capture message!"), r;
        const i = new Error(e1);
        return this._client.captureMessage(e1, t, {
            originalException: e1,
            syntheticException: i,
            ...n,
            event_id: r
        }, this), r;
    }
    captureEvent(e1, t) {
        const n = t && t.event_id ? t.event_id : yt();
        return this._client ? (this._client.captureEvent(e1, {
            ...t,
            event_id: n
        }, this), n) : (Le.warn("No client configured on scope - will not capture event!"), n);
    }
    _notifyScopeListeners() {
        this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((e1)=>{
            e1(this);
        }), this._notifyingListeners = !1);
    }
}
const on = rn;
class an {
    constructor(e1, t){
        let n, r;
        n = e1 || new on, r = t || new on, this._stack = [
            {
                scope: n
            }
        ], this._isolationScope = r;
    }
    withScope(e1) {
        const t = this._pushScope();
        let n;
        try {
            n = e1(t);
        } catch (e1) {
            throw this._popScope(), e1;
        }
        return ue(n) ? n.then((e1)=>(this._popScope(), e1), (e1)=>{
            throw this._popScope(), e1;
        }) : (this._popScope(), n);
    }
    getClient() {
        return this.getStackTop().client;
    }
    getScope() {
        return this.getStackTop().scope;
    }
    getIsolationScope() {
        return this._isolationScope;
    }
    getStackTop() {
        return this._stack[this._stack.length - 1];
    }
    _pushScope() {
        const e1 = this.getScope().clone();
        return this._stack.push({
            client: this.getClient(),
            scope: e1
        }), e1;
    }
    _popScope() {
        return !(this._stack.length <= 1) && !!this._stack.pop();
    }
}
function sn() {
    const e1 = Xt(Kt());
    return e1.stack = e1.stack || new an(Me("defaultCurrentScope", ()=>new on), Me("defaultIsolationScope", ()=>new on));
}
function cn(e1) {
    return sn().withScope(e1);
}
function ln(e1, t) {
    const n = sn();
    return n.withScope(()=>(n.getStackTop().scope = e1, t(e1)));
}
function un(e1) {
    return sn().withScope(()=>e1(sn().getIsolationScope()));
}
function dn(e1) {
    const t = Xt(e1);
    return t.acs ? t.acs : {
        withIsolationScope: un,
        withScope: cn,
        withSetScope: ln,
        withSetIsolationScope: (e1, t)=>un(t),
        getCurrentScope: ()=>sn().getScope(),
        getIsolationScope: ()=>sn().getIsolationScope()
    };
}
function pn() {
    return dn(Kt()).getCurrentScope();
}
function hn() {
    return dn(Kt()).getIsolationScope();
}
function fn() {
    return pn().getClient();
}
function vn(e1) {
    const t = e1._sentryMetrics;
    if (!t) return;
    const n = {};
    for (const [, [e1, r]] of t){
        (n[e1] || (n[e1] = [])).push(ze(r));
    }
    return n;
}
function gn(e1) {
    const { spanId: t, traceId: n } = e1.spanContext(), { parent_span_id: r } = _n(e1);
    return ze({
        parent_span_id: r,
        span_id: t,
        trace_id: n
    });
}
function mn(e1) {
    return "number" == typeof e1 ? yn(e1) : Array.isArray(e1) ? e1[0] + e1[1] / 1e9 : e1 instanceof Date ? yn(e1.getTime()) : ut();
}
function yn(e1) {
    return e1 > 9999999999 ? e1 / 1e3 : e1;
}
function _n(e1) {
    if (function(e1) {
        return "function" == typeof e1.getSpanJSON;
    }(e1)) return e1.getSpanJSON();
    try {
        const { spanId: t, traceId: n } = e1.spanContext();
        if (function(e1) {
            const t = e1;
            return !!(t.attributes && t.startTime && t.name && t.endTime && t.status);
        }(e1)) {
            const { attributes: r, startTime: i, name: o, endTime: a, parentSpanId: s, status: c } = e1;
            return ze({
                span_id: t,
                trace_id: n,
                data: r,
                description: o,
                parent_span_id: s,
                start_timestamp: mn(i),
                timestamp: mn(a) || void 0,
                status: bn(c),
                op: r["sentry.op"],
                origin: r["sentry.origin"],
                _metrics_summary: vn(e1)
            });
        }
        return {
            span_id: t,
            trace_id: n
        };
    } catch (e1) {
        return {};
    }
}
function bn(e1) {
    if (e1 && 0 !== e1.code) return 1 === e1.code ? "ok" : e1.message || "unknown_error";
}
function wn(e1) {
    return e1._sentryRootSpan || e1;
}
const kn = "production";
function Sn(e1, t) {
    const n = t.getOptions(), { publicKey: r } = t.getDsn() || {}, i = ze({
        environment: n.environment || kn,
        release: n.release,
        public_key: r,
        trace_id: e1
    });
    return t.emit("createDsc", i), i;
}
function Mn(e1) {
    const t = fn();
    if (!t) return {};
    const n = Sn(_n(e1).trace_id || "", t), r = wn(e1), i = r._frozenDsc;
    if (i) return i;
    const o = r.spanContext().traceState, a = o && o.get("sentry.dsc"), s = a && Nt(a);
    if (s) return s;
    const c = _n(r), l = c.data || {}, u = l["sentry.sample_rate"];
    null != u && (n.sample_rate = `${u}`);
    const d = l["sentry.source"], p = c.description;
    return "url" !== d && p && (n.transaction = p), function(e1) {
        if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return !1;
        const t = fn(), n = e1 || t && t.getOptions();
        return !!n && (n.enableTracing || "tracesSampleRate" in n || "tracesSampler" in n);
    }() && (n.sampled = String(function(e1) {
        const { traceFlags: t } = e1.spanContext();
        return 1 === t;
    }(r))), t.emit("createDsc", n, r), n;
}
function Cn(e1, t, n, r) {
    const i = Wt(n), o = e1.type && "replay_event" !== e1.type ? e1.type : "event";
    !function(e1, t) {
        t && (e1.sdk = e1.sdk || {}, e1.sdk.name = e1.sdk.name || t.name, e1.sdk.version = e1.sdk.version || t.version, e1.sdk.integrations = [
            ...e1.sdk.integrations || [],
            ...t.integrations || []
        ], e1.sdk.packages = [
            ...e1.sdk.packages || [],
            ...t.packages || []
        ]);
    }(e1, n && n.sdk);
    const a = function(e1, t, n, r) {
        const i = e1.sdkProcessingMetadata && e1.sdkProcessingMetadata.dynamicSamplingContext;
        return {
            event_id: e1.event_id,
            sent_at: (new Date).toISOString(),
            ...t && {
                sdk: t
            },
            ...!!n && r && {
                dsn: Ie(r)
            },
            ...i && {
                trace: ze({
                    ...i
                })
            }
        };
    }(e1, i, r, t);
    delete e1.sdkProcessingMetadata;
    return Rt(a, [
        [
            {
                type: o
            },
            e1
        ]
    ]);
}
function En(e1, t, n, r = 0) {
    return new At((i, o)=>{
        const a = e1[r];
        if (null === t || "function" != typeof a) i(t);
        else {
            const s = a({
                ...t
            }, n);
            Yt && a.id && null === s && Le.log(`Event processor "${a.id}" dropped event`), ue(s) ? s.then((t)=>En(e1, t, n, r + 1).then(i)).then(null, o) : En(e1, s, n, r + 1).then(i).then(null, o);
        }
    });
}
function Tn(e1, t) {
    const { fingerprint: n, span: r, breadcrumbs: i, sdkProcessingMetadata: o } = t;
    !function(e1, t) {
        const { extra: n, tags: r, user: i, contexts: o, level: a, transactionName: s } = t, c = ze(n);
        c && Object.keys(c).length && (e1.extra = {
            ...c,
            ...e1.extra
        });
        const l = ze(r);
        l && Object.keys(l).length && (e1.tags = {
            ...l,
            ...e1.tags
        });
        const u = ze(i);
        u && Object.keys(u).length && (e1.user = {
            ...u,
            ...e1.user
        });
        const d = ze(o);
        d && Object.keys(d).length && (e1.contexts = {
            ...d,
            ...e1.contexts
        });
        a && (e1.level = a);
        s && "transaction" !== e1.type && (e1.transaction = s);
    }(e1, t), r && function(e1, t) {
        e1.contexts = {
            trace: gn(t),
            ...e1.contexts
        }, e1.sdkProcessingMetadata = {
            dynamicSamplingContext: Mn(t),
            ...e1.sdkProcessingMetadata
        };
        const n = wn(t), r = _n(n).description;
        r && !e1.transaction && "transaction" === e1.type && (e1.transaction = r);
    }(e1, r), function(e1, t) {
        e1.fingerprint = e1.fingerprint ? function(e1) {
            return Array.isArray(e1) ? e1 : [
                e1
            ];
        }(e1.fingerprint) : [], t && (e1.fingerprint = e1.fingerprint.concat(t));
        e1.fingerprint && !e1.fingerprint.length && delete e1.fingerprint;
    }(e1, n), function(e1, t) {
        const n = [
            ...e1.breadcrumbs || [],
            ...t
        ];
        e1.breadcrumbs = n.length ? n : void 0;
    }(e1, i), function(e1, t) {
        e1.sdkProcessingMetadata = {
            ...e1.sdkProcessingMetadata,
            ...t
        };
    }(e1, o);
}
function Pn(e1, t) {
    const { extra: n, tags: r, user: i, contexts: o, level: a, sdkProcessingMetadata: s, breadcrumbs: c, fingerprint: l, eventProcessors: u, attachments: d, propagationContext: p, transactionName: h, span: f } = t;
    On(e1, "extra", n), On(e1, "tags", r), On(e1, "user", i), On(e1, "contexts", o), On(e1, "sdkProcessingMetadata", s), a && (e1.level = a), h && (e1.transactionName = h), f && (e1.span = f), c.length && (e1.breadcrumbs = [
        ...e1.breadcrumbs,
        ...c
    ]), l.length && (e1.fingerprint = [
        ...e1.fingerprint,
        ...l
    ]), u.length && (e1.eventProcessors = [
        ...e1.eventProcessors,
        ...u
    ]), d.length && (e1.attachments = [
        ...e1.attachments,
        ...d
    ]), e1.propagationContext = {
        ...e1.propagationContext,
        ...p
    };
}
function On(e1, t, n) {
    if (n && Object.keys(n).length) {
        e1[t] = {
            ...e1[t]
        };
        for(const r in n)Object.prototype.hasOwnProperty.call(n, r) && (e1[t][r] = n[r]);
    }
}
function An(e1, t, n, r, i, o) {
    const { normalizeDepth: a = 3, normalizeMaxBreadth: s = 1e3 } = e1, c = {
        ...t,
        event_id: t.event_id || n.event_id || yt(),
        timestamp: t.timestamp || lt()
    }, l = n.integrations || e1.integrations.map((e1)=>e1.name);
    !function(e1, t) {
        const { environment: n, release: r, dist: i, maxValueLength: o = 250 } = t;
        "environment" in e1 || (e1.environment = "environment" in t ? n : kn);
        void 0 === e1.release && void 0 !== r && (e1.release = r);
        void 0 === e1.dist && void 0 !== i && (e1.dist = i);
        e1.message && (e1.message = he(e1.message, o));
        const a = e1.exception && e1.exception.values && e1.exception.values[0];
        a && a.value && (a.value = he(a.value, o));
        const s = e1.request;
        s && s.url && (s.url = he(s.url, o));
    }(c, e1), function(e1, t) {
        t.length > 0 && (e1.sdk = e1.sdk || {}, e1.sdk.integrations = [
            ...e1.sdk.integrations || [],
            ...t
        ]);
    }(c, l), i && i.emit("applyFrameMetadata", t), void 0 === t.type && function(e1, t) {
        const n = Se._sentryDebugIds;
        if (!n) return;
        let r;
        const i = jn.get(t);
        i ? r = i : (r = new Map, jn.set(t, r));
        const o = Object.entries(n).reduce((e1, [n, i])=>{
            let o;
            const a = r.get(n);
            a ? o = a : (o = t(n), r.set(n, o));
            for(let t = o.length - 1; t >= 0; t--){
                const n = o[t];
                if (n.filename) {
                    e1[n.filename] = i;
                    break;
                }
            }
            return e1;
        }, {});
        try {
            e1.exception.values.forEach((e1)=>{
                e1.stacktrace.frames.forEach((e1)=>{
                    e1.filename && (e1.debug_id = o[e1.filename]);
                });
            });
        } catch (e1) {}
    }(c, e1.stackParser);
    const u = function(e1, t) {
        if (!t) return e1;
        const n = e1 ? e1.clone() : new on;
        return n.update(t), n;
    }(r, n.captureContext);
    n.mechanism && kt(c, n.mechanism);
    const d = i ? i.getEventProcessors() : [], p = Me("globalScope", ()=>new on).getScopeData();
    if (o) {
        Pn(p, o.getScopeData());
    }
    if (u) {
        Pn(p, u.getScopeData());
    }
    const h = [
        ...n.attachments || [],
        ...p.attachments
    ];
    h.length && (n.attachments = h), Tn(c, p);
    return En([
        ...d,
        ...p.eventProcessors
    ], c, n).then((e1)=>(e1 && function(e1) {
            const t = {};
            try {
                e1.exception.values.forEach((e1)=>{
                    e1.stacktrace.frames.forEach((e1)=>{
                        e1.debug_id && (e1.abs_path ? t[e1.abs_path] = e1.debug_id : e1.filename && (t[e1.filename] = e1.debug_id), delete e1.debug_id);
                    });
                });
            } catch (e1) {}
            if (0 === Object.keys(t).length) return;
            e1.debug_meta = e1.debug_meta || {}, e1.debug_meta.images = e1.debug_meta.images || [];
            const n = e1.debug_meta.images;
            Object.entries(t).forEach(([e1, t])=>{
                n.push({
                    type: "sourcemap",
                    code_file: e1,
                    debug_id: t
                });
            });
        }(e1), "number" == typeof a && a > 0 ? function(e1, t, n) {
            if (!e1) return null;
            const r = {
                ...e1,
                ...e1.breadcrumbs && {
                    breadcrumbs: e1.breadcrumbs.map((e1)=>({
                            ...e1,
                            ...e1.data && {
                                data: Mt(e1.data, t, n)
                            }
                        }))
                },
                ...e1.user && {
                    user: Mt(e1.user, t, n)
                },
                ...e1.contexts && {
                    contexts: Mt(e1.contexts, t, n)
                },
                ...e1.extra && {
                    extra: Mt(e1.extra, t, n)
                }
            };
            e1.contexts && e1.contexts.trace && r.contexts && (r.contexts.trace = e1.contexts.trace, e1.contexts.trace.data && (r.contexts.trace.data = Mt(e1.contexts.trace.data, t, n)));
            e1.spans && (r.spans = e1.spans.map((e1)=>({
                    ...e1,
                    ...e1.data && {
                        data: Mt(e1.data, t, n)
                    }
                })));
            return r;
        }(e1, a, s) : e1));
}
const jn = new WeakMap;
function Ln(e1) {
    if (e1) return function(e1) {
        return e1 instanceof on || "function" == typeof e1;
    }(e1) || function(e1) {
        return Object.keys(e1).some((e1)=>xn.includes(e1));
    }(e1) ? {
        captureContext: e1
    } : e1;
}
const xn = [
    "user",
    "level",
    "extra",
    "contexts",
    "tags",
    "fingerprint",
    "requestSession",
    "propagationContext"
];
function In(e1, t) {
    return pn().captureEvent(e1, t);
}
function Dn(e1, t) {
    return n = {
        sentry_key: e1.publicKey,
        sentry_version: "7",
        ...t && {
            sentry_client: `${t.name}/${t.version}`
        }
    }, Object.keys(n).map((e1)=>`${encodeURIComponent(e1)}=${encodeURIComponent(n[e1])}`).join("&");
    "TURBOPACK unreachable";
    var n;
}
const Nn = [];
function Fn(e1, t) {
    for (const n of t)n && n.afterAllSetup && n.afterAllSetup(e1);
}
function Rn(e1, t, n) {
    if (n[t.name]) Yt && Le.log(`Integration skipped because it was already installed: ${t.name}`);
    else {
        if (n[t.name] = t, -1 === Nn.indexOf(t.name) && "function" == typeof t.setupOnce && (t.setupOnce(), Nn.push(t.name)), t.setup && "function" == typeof t.setup && t.setup(e1), "function" == typeof t.preprocessEvent) {
            const n = t.preprocessEvent.bind(t);
            e1.on("preprocessEvent", (t, r)=>n(t, r, e1));
        }
        if ("function" == typeof t.processEvent) {
            const n = t.processEvent.bind(t), r = Object.assign((t, r)=>n(t, r, e1), {
                id: t.name
            });
            e1.addEventProcessor(r);
        }
        Yt && Le.log(`Integration installed: ${t.name}`);
    }
}
const Bn = "Not capturing exception because it's already been captured.";
class Un {
    constructor(e1){
        if (this._options = e1, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e1.dsn ? this._dsn = Ne(e1.dsn) : Yt && Le.warn("No DSN provided, client will not send events."), this._dsn) {
            const i = (t = this._dsn, n = e1.tunnel, r = e1._metadata ? e1._metadata.sdk : void 0, n || `${function(e1) {
                return `${function(e1) {
                    const t = e1.protocol ? `${e1.protocol}:` : "", n = e1.port ? `:${e1.port}` : "";
                    return `${t}//${e1.host}${n}${e1.path ? `/${e1.path}` : ""}/api/`;
                }(e1)}${e1.projectId}/envelope/`;
            }(t)}?${Dn(t, r)}`);
            this._transport = e1.transport({
                tunnel: this._options.tunnel,
                recordDroppedEvent: this.recordDroppedEvent.bind(this),
                ...e1.transportOptions,
                url: i
            });
        }
        var t, n, r;
    }
    captureException(e1, t, n) {
        const r = yt();
        if (St(e1)) return Yt && Le.log(Bn), r;
        const i = {
            event_id: r,
            ...t
        };
        return this._process(this.eventFromException(e1, i).then((e1)=>this._captureEvent(e1, i, n))), i.event_id;
    }
    captureMessage(e1, t, n, r) {
        const i = {
            event_id: yt(),
            ...n
        }, o = ae(e1) ? e1 : String(e1), a = se(e1) ? this.eventFromMessage(o, t, i) : this.eventFromException(e1, i);
        return this._process(a.then((e1)=>this._captureEvent(e1, i, r))), i.event_id;
    }
    captureEvent(e1, t, n) {
        const r = yt();
        if (t && t.originalException && St(t.originalException)) return Yt && Le.log(Bn), r;
        const i = {
            event_id: r,
            ...t
        }, o = (e1.sdkProcessingMetadata || {}).capturedSpanScope;
        return this._process(this._captureEvent(e1, i, o || n)), i.event_id;
    }
    captureSession(e1) {
        "string" != typeof e1.release ? Yt && Le.warn("Discarded session because of missing or non-string release") : (this.sendSession(e1), Zt(e1, {
            init: !1
        }));
    }
    getDsn() {
        return this._dsn;
    }
    getOptions() {
        return this._options;
    }
    getSdkMetadata() {
        return this._options._metadata;
    }
    getTransport() {
        return this._transport;
    }
    flush(e1) {
        const t = this._transport;
        return t ? (this.emit("flush"), this._isClientDoneProcessing(e1).then((n)=>t.flush(e1).then((e1)=>n && e1))) : Pt(!0);
    }
    close(e1) {
        return this.flush(e1).then((e1)=>(this.getOptions().enabled = !1, this.emit("close"), e1));
    }
    getEventProcessors() {
        return this._eventProcessors;
    }
    addEventProcessor(e1) {
        this._eventProcessors.push(e1);
    }
    init() {
        (this._isEnabled() || this._options.integrations.some(({ name: e1 })=>e1.startsWith("Spotlight"))) && this._setupIntegrations();
    }
    getIntegrationByName(e1) {
        return this._integrations[e1];
    }
    addIntegration(e1) {
        const t = this._integrations[e1.name];
        Rn(this, e1, this._integrations), t || Fn(this, [
            e1
        ]);
    }
    sendEvent(e1, t = {}) {
        this.emit("beforeSendEvent", e1, t);
        let n = Cn(e1, this._dsn, this._options._metadata, this._options.tunnel);
        for (const e1 of t.attachments || [])n = Bt(n, $t(e1));
        const r = this.sendEnvelope(n);
        r && r.then((t)=>this.emit("afterSendEvent", e1, t), null);
    }
    sendSession(e1) {
        const t = function(e1, t, n, r) {
            const i = Wt(n);
            return Rt({
                sent_at: (new Date).toISOString(),
                ...i && {
                    sdk: i
                },
                ...!!r && t && {
                    dsn: Ie(t)
                }
            }, [
                "aggregates" in e1 ? [
                    {
                        type: "sessions"
                    },
                    e1
                ] : [
                    {
                        type: "session"
                    },
                    e1.toJSON()
                ]
            ]);
        }(e1, this._dsn, this._options._metadata, this._options.tunnel);
        this.sendEnvelope(t);
    }
    recordDroppedEvent(e1, t, n) {
        if (this._options.sendClientReports) {
            const r = "number" == typeof n ? n : 1, i = `${e1}:${t}`;
            Yt && Le.log(`Recording outcome: "${i}"${r > 1 ? ` (${r} times)` : ""}`), this._outcomes[i] = (this._outcomes[i] || 0) + r;
        }
    }
    on(e1, t) {
        const n = this._hooks[e1] = this._hooks[e1] || [];
        return n.push(t), ()=>{
            const e1 = n.indexOf(t);
            e1 > -1 && n.splice(e1, 1);
        };
    }
    emit(e1, ...t) {
        const n = this._hooks[e1];
        n && n.forEach((e1)=>e1(...t));
    }
    sendEnvelope(e1) {
        return this.emit("beforeEnvelope", e1), this._isEnabled() && this._transport ? this._transport.send(e1).then(null, (e1)=>(Yt && Le.error("Error while sending event:", e1), e1)) : (Yt && Le.error("Transport disabled"), Pt({}));
    }
    _setupIntegrations() {
        const { integrations: e1 } = this._options;
        this._integrations = function(e1, t) {
            const n = {};
            return t.forEach((t)=>{
                t && Rn(e1, t, n);
            }), n;
        }(this, e1), Fn(this, e1);
    }
    _updateSessionFromEvent(e1, t) {
        let n = !1, r = !1;
        const i = t.exception && t.exception.values;
        if (i) {
            r = !0;
            for (const e1 of i){
                const t = e1.mechanism;
                if (t && !1 === t.handled) {
                    n = !0;
                    break;
                }
            }
        }
        const o = "ok" === e1.status;
        (o && 0 === e1.errors || o && n) && (Zt(e1, {
            ...n && {
                status: "crashed"
            },
            errors: e1.errors || Number(r || n)
        }), this.captureSession(e1));
    }
    _isClientDoneProcessing(e1) {
        return new At((t)=>{
            let n = 0;
            const r = setInterval(()=>{
                0 == this._numProcessing ? (clearInterval(r), t(!0)) : (n += 1, e1 && n >= e1 && (clearInterval(r), t(!1)));
            }, 1);
        });
    }
    _isEnabled() {
        return !1 !== this.getOptions().enabled && void 0 !== this._transport;
    }
    _prepareEvent(e1, t, n, r = hn()) {
        const i = this.getOptions(), o = Object.keys(this._integrations);
        return !t.integrations && o.length > 0 && (t.integrations = o), this.emit("preprocessEvent", e1, t), e1.type || r.setLastEventId(e1.event_id || t.event_id), An(i, e1, t, n, this, r).then((e1)=>{
            if (null === e1) return e1;
            const t = {
                ...r.getPropagationContext(),
                ...n ? n.getPropagationContext() : void 0
            };
            if (!(e1.contexts && e1.contexts.trace) && t) {
                const { traceId: n, spanId: r, parentSpanId: i, dsc: o } = t;
                e1.contexts = {
                    trace: ze({
                        trace_id: n,
                        span_id: r,
                        parent_span_id: i
                    }),
                    ...e1.contexts
                };
                const a = o || Sn(n, this);
                e1.sdkProcessingMetadata = {
                    dynamicSamplingContext: a,
                    ...e1.sdkProcessingMetadata
                };
            }
            return e1;
        });
    }
    _captureEvent(e1, t = {}, n) {
        return this._processEvent(e1, t, n).then((e1)=>e1.event_id, (e1)=>{
            if (Yt) {
                const t = e1;
                "log" === t.logLevel ? Le.log(t.message) : Le.warn(t);
            }
        });
    }
    _processEvent(e1, t, n) {
        const r = this.getOptions(), { sampleRate: i } = r, o = Jn(e1), a = Vn(e1), s = e1.type || "error", c = `before send for type \`${s}\``, l = void 0 === i ? void 0 : function(e1) {
            if ("boolean" == typeof e1) return Number(e1);
            const t = "string" == typeof e1 ? parseFloat(e1) : e1;
            if (!("number" != typeof t || isNaN(t) || t < 0 || t > 1)) return t;
            Yt && Le.warn(`[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(e1)} of type ${JSON.stringify(typeof e1)}.`);
        }(i);
        if (a && "number" == typeof l && Math.random() > l) return this.recordDroppedEvent("sample_rate", "error", e1), Ot(new Fe(`Discarding event because it's not included in the random sample (sampling rate = ${i})`, "log"));
        const u = "replay_event" === s ? "replay" : s, d = (e1.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
        return this._prepareEvent(e1, t, n, d).then((n)=>{
            if (null === n) throw this.recordDroppedEvent("event_processor", u, e1), new Fe("An event processor returned `null`, will not send event.", "log");
            if (t.data && !0 === t.data.__sentry__) return n;
            const i = function(e1, t, n, r) {
                const { beforeSend: i, beforeSendTransaction: o, beforeSendSpan: a } = t;
                if (Vn(n) && i) return i(n, r);
                if (Jn(n)) {
                    if (n.spans && a) {
                        const t = [];
                        for (const r of n.spans){
                            const n = a(r);
                            n ? t.push(n) : e1.recordDroppedEvent("before_send", "span");
                        }
                        n.spans = t;
                    }
                    if (o) {
                        if (n.spans) {
                            const e1 = n.spans.length;
                            n.sdkProcessingMetadata = {
                                ...n.sdkProcessingMetadata,
                                spanCountBeforeProcessing: e1
                            };
                        }
                        return o(n, r);
                    }
                }
                return n;
            }(this, r, n, t);
            return function(e1, t) {
                const n = `${t} must return \`null\` or a valid event.`;
                if (ue(e1)) return e1.then((e1)=>{
                    if (!ce(e1) && null !== e1) throw new Fe(n);
                    return e1;
                }, (e1)=>{
                    throw new Fe(`${t} rejected with ${e1}`);
                });
                if (!ce(e1) && null !== e1) throw new Fe(n);
                return e1;
            }(i, c);
        }).then((r)=>{
            if (null === r) {
                if (this.recordDroppedEvent("before_send", u, e1), o) {
                    const t = 1 + (e1.spans || []).length;
                    this.recordDroppedEvent("before_send", "span", t);
                }
                throw new Fe(`${c} returned \`null\`, will not send event.`, "log");
            }
            const i = n && n.getSession();
            if (!o && i && this._updateSessionFromEvent(i, r), o) {
                const e1 = (r.sdkProcessingMetadata && r.sdkProcessingMetadata.spanCountBeforeProcessing || 0) - (r.spans ? r.spans.length : 0);
                e1 > 0 && this.recordDroppedEvent("before_send", "span", e1);
            }
            const a = r.transaction_info;
            if (o && a && r.transaction !== e1.transaction) {
                const e1 = "custom";
                r.transaction_info = {
                    ...a,
                    source: e1
                };
            }
            return this.sendEvent(r, t), r;
        }).then(null, (e1)=>{
            if (e1 instanceof Fe) throw e1;
            throw this.captureException(e1, {
                data: {
                    __sentry__: !0
                },
                originalException: e1
            }), new Fe(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${e1}`);
        });
    }
    _process(e1) {
        this._numProcessing++, e1.then((e1)=>(this._numProcessing--, e1), (e1)=>(this._numProcessing--, e1));
    }
    _clearOutcomes() {
        const e1 = this._outcomes;
        return this._outcomes = {}, Object.entries(e1).map(([e1, t])=>{
            const [n, r] = e1.split(":");
            return {
                reason: n,
                category: r,
                quantity: t
            };
        });
    }
    _flushOutcomes() {
        Yt && Le.log("Flushing outcomes...");
        const e1 = this._clearOutcomes();
        if (0 === e1.length) return void (Yt && Le.log("No outcomes to send"));
        if (!this._dsn) return void (Yt && Le.log("No dsn provided, will not send outcomes"));
        Yt && Le.log("Sending outcomes:", e1);
        const t = (n = e1, Rt((r = this._options.tunnel && Ie(this._dsn)) ? {
            dsn: r
        } : {}, [
            [
                {
                    type: "client_report"
                },
                {
                    timestamp: i || lt(),
                    discarded_events: n
                }
            ]
        ]));
        var n, r, i;
        this.sendEnvelope(t);
    }
}
function Vn(e1) {
    return void 0 === e1.type;
}
function Jn(e1) {
    return "transaction" === e1.type;
}
function $n(e1, t, n = jt(e1.bufferSize || 64)) {
    let r = {};
    return {
        send: function(i) {
            const o = [];
            if (Ut(i, (t, n)=>{
                const i = zt(n);
                if (function(e1, t, n = Date.now()) {
                    return function(e1, t) {
                        return e1[t] || e1.all || 0;
                    }(e1, t) > n;
                }(r, i)) {
                    const r = qn(t, n);
                    e1.recordDroppedEvent("ratelimit_backoff", i, r);
                } else o.push(t);
            }), 0 === o.length) return Pt({});
            const a = Rt(i[0], o), s = (t)=>{
                Ut(a, (n, r)=>{
                    const i = qn(n, r);
                    e1.recordDroppedEvent(t, zt(r), i);
                });
            };
            return n.add(()=>t({
                    body: Jt(a)
                }).then((e1)=>(void 0 !== e1.statusCode && (e1.statusCode < 200 || e1.statusCode >= 300) && Yt && Le.warn(`Sentry responded with status code ${e1.statusCode} to sent event.`), r = Ht(r, e1), e1), (e1)=>{
                    throw s("network_error"), e1;
                })).then((e1)=>e1, (e1)=>{
                if (e1 instanceof Fe) return Yt && Le.error("Skipped sending event because buffer is full."), s("queue_overflow"), Pt({});
                throw e1;
            });
        },
        flush: (e1)=>n.drain(e1)
    };
}
function qn(e1, t) {
    if ("event" === t || "transaction" === t) return Array.isArray(e1) ? e1[1] : void 0;
}
const zn = 100;
function Wn(e1, t) {
    const n = fn(), r = hn();
    if (!n) return;
    const { beforeBreadcrumb: i = null, maxBreadcrumbs: o = zn } = n.getOptions();
    if (o <= 0) return;
    const a = {
        timestamp: lt(),
        ...e1
    }, s = i ? je(()=>i(a, t)) : a;
    null !== s && (n.emit && n.emit("beforeAddBreadcrumb", s, t), r.addBreadcrumb(s, o));
}
let Hn;
const Gn = new WeakMap, Qn = ()=>({
        name: "FunctionToString",
        setupOnce () {
            Hn = Function.prototype.toString;
            try {
                Function.prototype.toString = function(...e1) {
                    const t = Ve(this), n = Gn.has(fn()) && void 0 !== t ? t : this;
                    return Hn.apply(n, e1);
                };
            } catch (e1) {}
        },
        setup (e1) {
            Gn.set(e1, !0);
        }
    }), Yn = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/,
    "undefined is not an object (evaluating 'a.L')",
    'can\'t redefine non-configurable property "solana"',
    "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
    "Can't find variable: _AutofillCallbackHandler"
], Kn = (e1 = {})=>({
        name: "InboundFilters",
        processEvent (t, n, r) {
            const i = r.getOptions(), o = function(e1 = {}, t = {}) {
                return {
                    allowUrls: [
                        ...e1.allowUrls || [],
                        ...t.allowUrls || []
                    ],
                    denyUrls: [
                        ...e1.denyUrls || [],
                        ...t.denyUrls || []
                    ],
                    ignoreErrors: [
                        ...e1.ignoreErrors || [],
                        ...t.ignoreErrors || [],
                        ...e1.disableErrorDefaults ? [] : Yn
                    ],
                    ignoreTransactions: [
                        ...e1.ignoreTransactions || [],
                        ...t.ignoreTransactions || []
                    ],
                    ignoreInternal: void 0 === e1.ignoreInternal || e1.ignoreInternal
                };
            }(e1, i);
            return function(e1, t) {
                if (t.ignoreInternal && function(e1) {
                    try {
                        return "SentryError" === e1.exception.values[0].type;
                    } catch (e1) {}
                    return !1;
                }(e1)) return Yt && Le.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${bt(e1)}`), !0;
                if (function(e1, t) {
                    if (e1.type || !t || !t.length) return !1;
                    return (function(e1) {
                        const t = [];
                        e1.message && t.push(e1.message);
                        let n;
                        try {
                            n = e1.exception.values[e1.exception.values.length - 1];
                        } catch (e1) {}
                        n && n.value && (t.push(n.value), n.type && t.push(`${n.type}: ${n.value}`));
                        return t;
                    })(e1).some((e1)=>ge(e1, t));
                }(e1, t.ignoreErrors)) return Yt && Le.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${bt(e1)}`), !0;
                if (function(e1) {
                    if (e1.type) return !1;
                    if (!e1.exception || !e1.exception.values || 0 === e1.exception.values.length) return !1;
                    return !e1.message && !e1.exception.values.some((e1)=>e1.stacktrace || e1.type && "Error" !== e1.type || e1.value);
                }(e1)) return Yt && Le.warn(`Event dropped due to not having an error message, error type or stacktrace.\nEvent: ${bt(e1)}`), !0;
                if (function(e1, t) {
                    if ("transaction" !== e1.type || !t || !t.length) return !1;
                    const n = e1.transaction;
                    return !!n && ge(n, t);
                }(e1, t.ignoreTransactions)) return Yt && Le.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${bt(e1)}`), !0;
                if (function(e1, t) {
                    if (!t || !t.length) return !1;
                    const n = Xn(e1);
                    return !!n && ge(n, t);
                }(e1, t.denyUrls)) return Yt && Le.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${bt(e1)}.\nUrl: ${Xn(e1)}`), !0;
                if (!function(e1, t) {
                    if (!t || !t.length) return !0;
                    const n = Xn(e1);
                    return !n || ge(n, t);
                }(e1, t.allowUrls)) return Yt && Le.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${bt(e1)}.\nUrl: ${Xn(e1)}`), !0;
                return !1;
            }(t, o) ? null : t;
        }
    });
function Xn(e1) {
    try {
        let t;
        try {
            t = e1.exception.values[0].stacktrace.frames;
        } catch (e1) {}
        return t ? function(e1 = []) {
            for(let t = e1.length - 1; t >= 0; t--){
                const n = e1[t];
                if (n && "<anonymous>" !== n.filename && "[native code]" !== n.filename) return n.filename || null;
            }
            return null;
        }(t) : null;
    } catch (t) {
        return Yt && Le.error(`Cannot extract url for event ${bt(e1)}`), null;
    }
}
const Zn = ()=>{
    let e1;
    return {
        name: "Dedupe",
        processEvent (t) {
            if (t.type) return t;
            try {
                if (function(e1, t) {
                    if (!t) return !1;
                    if (function(e1, t) {
                        const n = e1.message, r = t.message;
                        if (!n && !r) return !1;
                        if (n && !r || !n && r) return !1;
                        if (n !== r) return !1;
                        if (!tr(e1, t)) return !1;
                        if (!er(e1, t)) return !1;
                        return !0;
                    }(e1, t)) return !0;
                    if (function(e1, t) {
                        const n = nr(t), r = nr(e1);
                        if (!n || !r) return !1;
                        if (n.type !== r.type || n.value !== r.value) return !1;
                        if (!tr(e1, t)) return !1;
                        if (!er(e1, t)) return !1;
                        return !0;
                    }(e1, t)) return !0;
                    return !1;
                }(t, e1)) return Yt && Le.warn("Event dropped due to being a duplicate of previously captured event."), null;
            } catch (e1) {}
            return e1 = t;
        }
    };
};
function er(e1, t) {
    let n = Ze(e1), r = Ze(t);
    if (!n && !r) return !0;
    if (n && !r || !n && r) return !1;
    if (r.length !== n.length) return !1;
    for(let e1 = 0; e1 < r.length; e1++){
        const t = r[e1], i = n[e1];
        if (t.filename !== i.filename || t.lineno !== i.lineno || t.colno !== i.colno || t.function !== i.function) return !1;
    }
    return !0;
}
function tr(e1, t) {
    let n = e1.fingerprint, r = t.fingerprint;
    if (!n && !r) return !0;
    if (n && !r || !n && r) return !1;
    try {
        return !(n.join("") !== r.join(""));
    } catch (e1) {
        return !1;
    }
}
function nr(e1) {
    return e1.exception && e1.exception.values && e1.exception.values[0];
}
const rr = Se;
let ir = 0;
function or() {
    return ir > 0;
}
function ar(e1, t = {}, n) {
    if ("function" != typeof e1) return e1;
    try {
        const t = e1.__sentry_wrapped__;
        if (t) return "function" == typeof t ? t : e1;
        if (Ve(e1)) return e1;
    } catch (t) {
        return e1;
    }
    const r = function() {
        const r = Array.prototype.slice.call(arguments);
        try {
            n && "function" == typeof n && n.apply(this, arguments);
            const i = r.map((e1)=>ar(e1, t));
            return e1.apply(this, i);
        } catch (e1) {
            throw ir++, setTimeout(()=>{
                ir--;
            }), function(...e1) {
                const t = dn(Kt());
                if (2 === e1.length) {
                    const [n, r] = e1;
                    return n ? t.withSetScope(n, r) : t.withScope(r);
                }
                t.withScope(e1[0]);
            }((n)=>{
                var i, o;
                n.addEventProcessor((e1)=>(t.mechanism && (wt(e1, void 0, void 0), kt(e1, t.mechanism)), e1.extra = {
                        ...e1.extra,
                        arguments: r
                    }, e1)), i = e1, pn().captureException(i, Ln(o));
            }), e1;
        }
    };
    try {
        for(const t in e1)Object.prototype.hasOwnProperty.call(e1, t) && (r[t] = e1[t]);
    } catch (e1) {}
    Ue(r, e1), Be(e1, "__sentry_wrapped__", r);
    try {
        Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
            get: ()=>e1.name
        });
    } catch (e1) {}
    return r;
}
const sr = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
function cr(e1, t) {
    const n = dr(e1, t), r = {
        type: t && t.name,
        value: hr(t)
    };
    return n.length && (r.stacktrace = {
        frames: n
    }), void 0 === r.type && "" === r.value && (r.value = "Unrecoverable error caught"), r;
}
function lr(e1, t, n, r) {
    const i = fn(), o = i && i.getOptions().normalizeDepth, a = function(e1) {
        for(const t in e1)if (Object.prototype.hasOwnProperty.call(e1, t)) {
            const n = e1[t];
            if (n instanceof Error) return n;
        }
        return;
    }(t), s = {
        __serialized__: Ct(t, o)
    };
    if (a) return {
        exception: {
            values: [
                cr(e1, a)
            ]
        },
        extra: s
    };
    const c = {
        exception: {
            values: [
                {
                    type: le(t) ? t.constructor.name : r ? "UnhandledRejection" : "Error",
                    value: gr(t, {
                        isUnhandledRejection: r
                    })
                }
            ]
        },
        extra: s
    };
    if (n) {
        const t = dr(e1, n);
        t.length && (c.exception.values[0].stacktrace = {
            frames: t
        });
    }
    return c;
}
function ur(e1, t) {
    return {
        exception: {
            values: [
                cr(e1, t)
            ]
        }
    };
}
function dr(e1, t) {
    const n = t.stacktrace || t.stack || "", r = function(e1) {
        if (e1 && pr.test(e1.message)) return 1;
        return 0;
    }(t), i = function(e1) {
        if ("number" == typeof e1.framesToPop) return e1.framesToPop;
        return 0;
    }(t);
    try {
        return e1(n, r, i);
    } catch (e1) {}
    return [];
}
const pr = /Minified React error #\d+;/i;
function hr(e1) {
    const t = e1 && e1.message;
    return t ? t.error && "string" == typeof t.error.message ? t.error.message : t : "No error message";
}
function fr(e1, t, n, r, i) {
    let o;
    if (re(t) && t.error) {
        return ur(e1, t.error);
    }
    if (ie(t) || ne(t, "DOMException")) {
        const i = t;
        if ("stack" in t) o = ur(e1, t);
        else {
            const t = i.name || (ie(i) ? "DOMError" : "DOMException"), a = i.message ? `${t}: ${i.message}` : t;
            o = vr(e1, a, n, r), wt(o, a);
        }
        return "code" in i && (o.tags = {
            ...o.tags,
            "DOMException.code": `${i.code}`
        }), o;
    }
    if (te(t)) return ur(e1, t);
    if (ce(t) || le(t)) {
        return o = lr(e1, t, n, i), kt(o, {
            synthetic: !0
        }), o;
    }
    return o = vr(e1, t, n, r), wt(o, `${t}`, void 0), kt(o, {
        synthetic: !0
    }), o;
}
function vr(e1, t, n, r) {
    const i = {};
    if (r && n) {
        const r = dr(e1, n);
        r.length && (i.exception = {
            values: [
                {
                    value: t,
                    stacktrace: {
                        frames: r
                    }
                }
            ]
        });
    }
    if (ae(t)) {
        const { __sentry_template_string__: e1, __sentry_template_values__: n } = t;
        return i.logentry = {
            message: e1,
            params: n
        }, i;
    }
    return i.message = t, i;
}
function gr(e1, { isUnhandledRejection: t }) {
    const n = function(e1, t = 40) {
        const n = Object.keys(Je(e1));
        n.sort();
        const r = n[0];
        if (!r) return "[object has no keys]";
        if (r.length >= t) return he(r, t);
        for(let e1 = n.length; e1 > 0; e1--){
            const r = n.slice(0, e1).join(", ");
            if (!(r.length > t)) return e1 === n.length ? r : he(r, t);
        }
        return "";
    }(e1), r = t ? "promise rejection" : "exception";
    if (re(e1)) return `Event \`ErrorEvent\` captured as ${r} with message \`${e1.message}\``;
    if (le(e1)) {
        return `Event \`${function(e1) {
            try {
                const t = Object.getPrototypeOf(e1);
                return t ? t.constructor.name : void 0;
            } catch (e1) {}
        }(e1)}\` (type=${e1.type}) captured as ${r}`;
    }
    return `Object captured as ${r} with keys: ${n}`;
}
class mr extends Un {
    constructor(e1){
        const t = {
            parentSpanIsAlwaysRootSpan: !0,
            ...e1
        };
        !function(e1, t, n = [
            t
        ], r = "npm") {
            const i = e1._metadata || {};
            i.sdk || (i.sdk = {
                name: `sentry.javascript.${t}`,
                packages: n.map((e1)=>({
                        name: `${r}:@sentry/${e1}`,
                        version: ke
                    })),
                version: ke
            }), e1._metadata = i;
        }(t, "browser", [
            "browser"
        ], rr.SENTRY_SDK_SOURCE || "npm"), super(t), t.sendClientReports && rr.document && rr.document.addEventListener("visibilitychange", ()=>{
            "hidden" === rr.document.visibilityState && this._flushOutcomes();
        });
    }
    eventFromException(e1, t) {
        return function(e1, t, n, r) {
            const i = fr(e1, t, n && n.syntheticException || void 0, r);
            return kt(i), i.level = "error", n && n.event_id && (i.event_id = n.event_id), Pt(i);
        }(this._options.stackParser, e1, t, this._options.attachStacktrace);
    }
    eventFromMessage(e1, t = "info", n) {
        return function(e1, t, n = "info", r, i) {
            const o = vr(e1, t, r && r.syntheticException || void 0, i);
            return o.level = n, r && r.event_id && (o.event_id = r.event_id), Pt(o);
        }(this._options.stackParser, e1, t, n, this._options.attachStacktrace);
    }
    captureUserFeedback(e1) {
        if (!this._isEnabled()) return void (sr && Le.warn("SDK not enabled, will not capture user feedback."));
        const t = function(e1, { metadata: t, tunnel: n, dsn: r }) {
            const i = {
                event_id: e1.event_id,
                sent_at: (new Date).toISOString(),
                ...t && t.sdk && {
                    sdk: {
                        name: t.sdk.name,
                        version: t.sdk.version
                    }
                },
                ...!!n && !!r && {
                    dsn: Ie(r)
                }
            }, o = function(e1) {
                return [
                    {
                        type: "user_report"
                    },
                    e1
                ];
            }(e1);
            return Rt(i, [
                o
            ]);
        }(e1, {
            metadata: this.getSdkMetadata(),
            dsn: this.getDsn(),
            tunnel: this.getOptions().tunnel
        });
        this.sendEnvelope(t);
    }
    _prepareEvent(e1, t, n) {
        return e1.platform = e1.platform || "javascript", super._prepareEvent(e1, t, n);
    }
}
const yr = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, _r = Se;
let br, wr, kr, Sr;
function Mr() {
    if (!_r.document) return;
    const e1 = it.bind(null, "dom"), t = Cr(e1, !0);
    _r.document.addEventListener("click", t, !1), _r.document.addEventListener("keypress", t, !1), [
        "EventTarget",
        "Node"
    ].forEach((t)=>{
        const n = _r[t] && _r[t].prototype;
        n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && (Re(n, "addEventListener", function(t) {
            return function(n, r, i) {
                if ("click" === n || "keypress" == n) try {
                    const r = this, o = r.__sentry_instrumentation_handlers__ = r.__sentry_instrumentation_handlers__ || {}, a = o[n] = o[n] || {
                        refCount: 0
                    };
                    if (!a.handler) {
                        const r = Cr(e1);
                        a.handler = r, t.call(this, n, r, i);
                    }
                    a.refCount++;
                } catch (e1) {}
                return t.call(this, n, r, i);
            };
        }), Re(n, "removeEventListener", function(e1) {
            return function(t, n, r) {
                if ("click" === t || "keypress" == t) try {
                    const n = this, i = n.__sentry_instrumentation_handlers__ || {}, o = i[t];
                    o && (o.refCount--, o.refCount <= 0 && (e1.call(this, t, o.handler, r), o.handler = void 0, delete i[t]), 0 === Object.keys(i).length && delete n.__sentry_instrumentation_handlers__);
                } catch (e1) {}
                return e1.call(this, t, n, r);
            };
        }));
    });
}
function Cr(e1, t = !1) {
    return (n)=>{
        if (!n || n._sentryCaptured) return;
        const r = function(e1) {
            try {
                return e1.target;
            } catch (e1) {
                return null;
            }
        }(n);
        if (function(e1, t) {
            return "keypress" === e1 && (!t || !t.tagName || "INPUT" !== t.tagName && "TEXTAREA" !== t.tagName && !t.isContentEditable);
        }(n.type, r)) return;
        Be(n, "_sentryCaptured", !0), r && !r._sentryId && Be(r, "_sentryId", yt());
        const i = "keypress" === n.type ? "input" : n.type;
        if (!function(e1) {
            if (e1.type !== wr) return !1;
            try {
                if (!e1.target || e1.target._sentryId !== kr) return !1;
            } catch (e1) {}
            return !0;
        }(n)) {
            e1({
                event: n,
                name: i,
                global: t
            }), wr = n.type, kr = r ? r._sentryId : void 0;
        }
        clearTimeout(br), br = _r.setTimeout(()=>{
            kr = void 0, wr = void 0;
        }, 1e3);
    };
}
function Er() {
    if (!function() {
        const e1 = Qt.chrome, t = e1 && e1.app && e1.app.runtime, n = "history" in Qt && !!Qt.history.pushState && !!Qt.history.replaceState;
        return !t && n;
    }()) return;
    const e1 = _r.onpopstate;
    function t(e1) {
        return function(...t) {
            const n = t.length > 2 ? t[2] : void 0;
            if (n) {
                const e1 = Sr, t = String(n);
                Sr = t;
                it("history", {
                    from: e1,
                    to: t
                });
            }
            return e1.apply(this, t);
        };
    }
    _r.onpopstate = function(...t) {
        const n = _r.location.href, r = Sr;
        Sr = n;
        if (it("history", {
            from: r,
            to: n
        }), e1) try {
            return e1.apply(this, t);
        } catch (e1) {}
    }, Re(_r.history, "pushState", t), Re(_r.history, "replaceState", t);
}
const Tr = {};
function Pr(e1) {
    Tr[e1] = void 0;
}
const Or = "__sentry_xhr_v3__";
function Ar() {
    if (!_r.XMLHttpRequest) return;
    const e1 = XMLHttpRequest.prototype;
    e1.open = new Proxy(e1.open, {
        apply (e1, t, n) {
            const r = 1e3 * ut(), i = oe(n[0]) ? n[0].toUpperCase() : void 0, o = function(e1) {
                if (oe(e1)) return e1;
                try {
                    return e1.toString();
                } catch (e1) {}
                return;
            }(n[1]);
            if (!i || !o) return e1.apply(t, n);
            t[Or] = {
                method: i,
                url: o,
                request_headers: {}
            }, "POST" === i && o.match(/sentry_key/) && (t.__sentry_own_request__ = !0);
            const a = ()=>{
                const e1 = t[Or];
                if (e1 && 4 === t.readyState) {
                    try {
                        e1.status_code = t.status;
                    } catch (e1) {}
                    it("xhr", {
                        endTimestamp: 1e3 * ut(),
                        startTimestamp: r,
                        xhr: t
                    });
                }
            };
            return "onreadystatechange" in t && "function" == typeof t.onreadystatechange ? t.onreadystatechange = new Proxy(t.onreadystatechange, {
                apply: (e1, t, n)=>(a(), e1.apply(t, n))
            }) : t.addEventListener("readystatechange", a), t.setRequestHeader = new Proxy(t.setRequestHeader, {
                apply (e1, t, n) {
                    const [r, i] = n, o = t[Or];
                    return o && oe(r) && oe(i) && (o.request_headers[r.toLowerCase()] = i), e1.apply(t, n);
                }
            }), e1.apply(t, n);
        }
    }), e1.send = new Proxy(e1.send, {
        apply (e1, t, n) {
            const r = t[Or];
            if (!r) return e1.apply(t, n);
            void 0 !== n[0] && (r.body = n[0]);
            return it("xhr", {
                startTimestamp: 1e3 * ut(),
                xhr: t
            }), e1.apply(t, n);
        }
    });
}
function jr(e1, t = function(e1) {
    const t = Tr[e1];
    if (t) return t;
    let n = _r[e1];
    if (st(n)) return Tr[e1] = n.bind(_r);
    const r = _r.document;
    if (r && "function" == typeof r.createElement) try {
        const t = r.createElement("iframe");
        t.hidden = !0, r.head.appendChild(t);
        const i = t.contentWindow;
        i && i[e1] && (n = i[e1]), r.head.removeChild(t);
    } catch (t) {
        yr && Le.warn(`Could not create sandbox iframe for ${e1} check, bailing to window.${e1}: `, t);
    }
    return n ? Tr[e1] = n.bind(_r) : n;
}("fetch")) {
    let n = 0, r = 0;
    return $n(e1, function(i) {
        const o = i.body.length;
        n += o, r++;
        const a = {
            body: i.body,
            method: "POST",
            referrerPolicy: "origin",
            headers: e1.headers,
            keepalive: n <= 6e4 && r < 15,
            ...e1.fetchOptions
        };
        if (!t) return Pr("fetch"), Ot("No fetch implementation available");
        try {
            return t(e1.url, a).then((e1)=>(n -= o, r--, {
                    statusCode: e1.status,
                    headers: {
                        "x-sentry-rate-limits": e1.headers.get("X-Sentry-Rate-Limits"),
                        "retry-after": e1.headers.get("Retry-After")
                    }
                }));
        } catch (e1) {
            return Pr("fetch"), n -= o, r--, Ot(e1);
        }
    });
}
function Lr(e1, t, n, r) {
    const i = {
        filename: e1,
        function: "<anonymous>" === t ? He : t,
        in_app: !0
    };
    return void 0 !== n && (i.lineno = n), void 0 !== r && (i.colno = r), i;
}
const xr = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i, Ir = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, Dr = /\((\S*)(?::(\d+))(?::(\d+))\)/, Nr = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, Fr = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, Rr = function(...e1) {
    const t = e1.sort((e1, t)=>e1[0] - t[0]).map((e1)=>e1[1]);
    return (e1, n = 0, r = 0)=>{
        const i = [], o = e1.split("\n");
        for(let e1 = n; e1 < o.length; e1++){
            const n = o[e1];
            if (n.length > 1024) continue;
            const a = Ge.test(n) ? n.replace(Ge, "$1") : n;
            if (!a.match(/\S*Error: /)) {
                for (const e1 of t){
                    const t = e1(a);
                    if (t) {
                        i.push(t);
                        break;
                    }
                }
                if (i.length >= 50 + r) break;
            }
        }
        return function(e1) {
            if (!e1.length) return [];
            const t = Array.from(e1);
            /sentryWrapped/.test(Ye(t).function || "") && t.pop();
            t.reverse(), Qe.test(Ye(t).function || "") && (t.pop(), Qe.test(Ye(t).function || "") && t.pop());
            return t.slice(0, 50).map((e1)=>({
                    ...e1,
                    filename: e1.filename || Ye(t).filename,
                    function: e1.function || He
                }));
        }(i.slice(r));
    };
}(...[
    [
        30,
        (e1)=>{
            const t = xr.exec(e1);
            if (t) {
                const [, e1, n, r] = t;
                return Lr(e1, He, +n, +r);
            }
            const n = Ir.exec(e1);
            if (n) {
                if (n[2] && 0 === n[2].indexOf("eval")) {
                    const e1 = Dr.exec(n[2]);
                    e1 && (n[2] = e1[1], n[3] = e1[2], n[4] = e1[3]);
                }
                const [e1, t] = Br(n[1] || He, n[2]);
                return Lr(t, e1, n[3] ? +n[3] : void 0, n[4] ? +n[4] : void 0);
            }
        }
    ],
    [
        50,
        (e1)=>{
            const t = Nr.exec(e1);
            if (t) {
                if (t[3] && t[3].indexOf(" > eval") > -1) {
                    const e1 = Fr.exec(t[3]);
                    e1 && (t[1] = t[1] || "eval", t[3] = e1[1], t[4] = e1[2], t[5] = "");
                }
                let e1 = t[3], n = t[1] || He;
                return [n, e1] = Br(n, e1), Lr(e1, n, t[4] ? +t[4] : void 0, t[5] ? +t[5] : void 0);
            }
        }
    ]
]), Br = (e1, t)=>{
    const n = -1 !== e1.indexOf("safari-extension"), r = -1 !== e1.indexOf("safari-web-extension");
    return n || r ? [
        -1 !== e1.indexOf("@") ? e1.split("@")[0] : He,
        n ? `safari-extension:${t}` : `safari-web-extension:${t}`
    ] : [
        e1,
        t
    ];
}, Ur = 1024, Vr = (e1 = {})=>{
    const t = {
        console: !0,
        dom: !0,
        fetch: !0,
        history: !0,
        sentry: !0,
        xhr: !0,
        ...e1
    };
    return {
        name: "Breadcrumbs",
        setup (e1) {
            var n;
            t.console && function(e1) {
                const t = "console";
                nt(t, e1), rt(t, ot);
            }(function(e1) {
                return function(t) {
                    if (fn() !== e1) return;
                    const n = {
                        category: "console",
                        data: {
                            arguments: t.args,
                            logger: "console"
                        },
                        level: It(t.level),
                        message: fe(t.args, " ")
                    };
                    if ("assert" === t.level) {
                        if (!1 !== t.args[0]) return;
                        n.message = `Assertion failed: ${fe(t.args.slice(1), " ") || "console.assert"}`, n.data.arguments = t.args.slice(1);
                    }
                    Wn(n, {
                        input: t.args,
                        level: t.level
                    });
                };
            }(e1)), t.dom && (n = function(e1, t) {
                return function(n) {
                    if (fn() !== e1) return;
                    let r, i, o = "object" == typeof t ? t.serializeAttribute : void 0, a = "object" == typeof t && "number" == typeof t.maxStringLength ? t.maxStringLength : void 0;
                    a && a > Ur && (sr && Le.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${a} was configured. Sentry will use 1024 instead.`), a = Ur), "string" == typeof o && (o = [
                        o
                    ]);
                    try {
                        const e1 = n.event, t = function(e1) {
                            return !!e1 && !!e1.target;
                        }(e1) ? e1.target : e1;
                        r = Ee(t, {
                            keyAttrs: o,
                            maxStringLength: a
                        }), i = function(e1) {
                            if (!Ce.HTMLElement) return null;
                            let t = e1;
                            for(let e1 = 0; e1 < 5; e1++){
                                if (!t) return null;
                                if (t instanceof HTMLElement) {
                                    if (t.dataset.sentryComponent) return t.dataset.sentryComponent;
                                    if (t.dataset.sentryElement) return t.dataset.sentryElement;
                                }
                                t = t.parentNode;
                            }
                            return null;
                        }(t);
                    } catch (e1) {
                        r = "<unknown>";
                    }
                    if (0 === r.length) return;
                    const s = {
                        category: `ui.${n.name}`,
                        message: r
                    };
                    i && (s.data = {
                        "ui.component_name": i
                    }), Wn(s, {
                        event: n.event,
                        name: n.name,
                        global: n.global
                    });
                };
            }(e1, t.dom), nt("dom", n), rt("dom", Mr)), t.xhr && function(e1) {
                nt("xhr", e1), rt("xhr", Ar);
            }(function(e1) {
                return function(t) {
                    if (fn() !== e1) return;
                    const { startTimestamp: n, endTimestamp: r } = t, i = t.xhr[Or];
                    if (!n || !r || !i) return;
                    const { method: o, url: a, status_code: s, body: c } = i, l = {
                        method: o,
                        url: a,
                        status_code: s
                    }, u = {
                        xhr: t.xhr,
                        input: c,
                        startTimestamp: n,
                        endTimestamp: r
                    };
                    Wn({
                        category: "xhr",
                        data: l,
                        type: "http",
                        level: we(s)
                    }, u);
                };
            }(e1)), t.fetch && dt(function(e1) {
                return function(t) {
                    if (fn() !== e1) return;
                    const { startTimestamp: n, endTimestamp: r } = t;
                    if (r && (!t.fetchData.url.match(/sentry_key/) || "POST" !== t.fetchData.method)) if (t.error) {
                        Wn({
                            category: "fetch",
                            data: t.fetchData,
                            level: "error",
                            type: "http"
                        }, {
                            data: t.error,
                            input: t.args,
                            startTimestamp: n,
                            endTimestamp: r
                        });
                    } else {
                        const e1 = t.response, i = {
                            ...t.fetchData,
                            status_code: e1 && e1.status
                        }, o = {
                            input: t.args,
                            response: e1,
                            startTimestamp: n,
                            endTimestamp: r
                        };
                        Wn({
                            category: "fetch",
                            data: i,
                            type: "http",
                            level: we(i.status_code)
                        }, o);
                    }
                };
            }(e1)), t.history && function(e1) {
                const t = "history";
                nt(t, e1), rt(t, Er);
            }(function(e1) {
                return function(t) {
                    if (fn() !== e1) return;
                    let n = t.from, r = t.to;
                    const i = Lt(rr.location.href);
                    let o = n ? Lt(n) : void 0;
                    const a = Lt(r);
                    o && o.path || (o = i), i.protocol === a.protocol && i.host === a.host && (r = a.relative), i.protocol === o.protocol && i.host === o.host && (n = o.relative), Wn({
                        category: "navigation",
                        data: {
                            from: n,
                            to: r
                        }
                    });
                };
            }(e1)), t.sentry && e1.on("beforeSendEvent", function(e1) {
                return function(t) {
                    fn() === e1 && Wn({
                        category: "sentry." + ("transaction" === t.type ? "transaction" : "event"),
                        event_id: t.event_id,
                        level: t.level,
                        message: bt(t)
                    }, {
                        event: t
                    });
                };
            }(e1));
        }
    };
};
const Jr = [
    "EventTarget",
    "Window",
    "Node",
    "ApplicationCache",
    "AudioTrackList",
    "BroadcastChannel",
    "ChannelMergerNode",
    "CryptoOperation",
    "EventSource",
    "FileReader",
    "HTMLUnknownElement",
    "IDBDatabase",
    "IDBRequest",
    "IDBTransaction",
    "KeyOperation",
    "MediaController",
    "MessagePort",
    "ModalWindow",
    "Notification",
    "SVGElementInstance",
    "Screen",
    "SharedWorker",
    "TextTrack",
    "TextTrackCue",
    "TextTrackList",
    "WebSocket",
    "WebSocketWorker",
    "Worker",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestUpload"
], $r = (e1 = {})=>{
    const t = {
        XMLHttpRequest: !0,
        eventTarget: !0,
        requestAnimationFrame: !0,
        setInterval: !0,
        setTimeout: !0,
        ...e1
    };
    return {
        name: "BrowserApiErrors",
        setupOnce () {
            t.setTimeout && Re(rr, "setTimeout", qr), t.setInterval && Re(rr, "setInterval", qr), t.requestAnimationFrame && Re(rr, "requestAnimationFrame", zr), t.XMLHttpRequest && "XMLHttpRequest" in rr && Re(XMLHttpRequest.prototype, "send", Wr);
            const e1 = t.eventTarget;
            if (e1) {
                (Array.isArray(e1) ? e1 : Jr).forEach(Hr);
            }
        }
    };
};
function qr(e1) {
    return function(...t) {
        const n = t[0];
        return t[0] = ar(n, {
            mechanism: {
                data: {
                    function: Xe(e1)
                },
                handled: !1,
                type: "instrument"
            }
        }), e1.apply(this, t);
    };
}
function zr(e1) {
    return function(t) {
        return e1.apply(this, [
            ar(t, {
                mechanism: {
                    data: {
                        function: "requestAnimationFrame",
                        handler: Xe(e1)
                    },
                    handled: !1,
                    type: "instrument"
                }
            })
        ]);
    };
}
function Wr(e1) {
    return function(...t) {
        const n = this;
        return [
            "onload",
            "onerror",
            "onprogress",
            "onreadystatechange"
        ].forEach((e1)=>{
            e1 in n && "function" == typeof n[e1] && Re(n, e1, function(t) {
                const n = {
                    mechanism: {
                        data: {
                            function: e1,
                            handler: Xe(t)
                        },
                        handled: !1,
                        type: "instrument"
                    }
                }, r = Ve(t);
                return r && (n.mechanism.data.handler = Xe(r)), ar(t, n);
            });
        }), e1.apply(this, t);
    };
}
function Hr(e1) {
    const t = rr, n = t[e1] && t[e1].prototype;
    n && n.hasOwnProperty && n.hasOwnProperty("addEventListener") && (Re(n, "addEventListener", function(t) {
        return function(n, r, i) {
            try {
                "function" == typeof r.handleEvent && (r.handleEvent = ar(r.handleEvent, {
                    mechanism: {
                        data: {
                            function: "handleEvent",
                            handler: Xe(r),
                            target: e1
                        },
                        handled: !1,
                        type: "instrument"
                    }
                }));
            } catch (e1) {}
            return t.apply(this, [
                n,
                ar(r, {
                    mechanism: {
                        data: {
                            function: "addEventListener",
                            handler: Xe(r),
                            target: e1
                        },
                        handled: !1,
                        type: "instrument"
                    }
                }),
                i
            ]);
        };
    }), Re(n, "removeEventListener", function(e1) {
        return function(t, n, r) {
            const i = n;
            try {
                const n = i && i.__sentry_wrapped__;
                n && e1.call(this, t, n, r);
            } catch (e1) {}
            return e1.call(this, t, i, r);
        };
    }));
}
const Gr = (e1 = {})=>{
    const t = {
        onerror: !0,
        onunhandledrejection: !0,
        ...e1
    };
    return {
        name: "GlobalHandlers",
        setupOnce () {
            Error.stackTraceLimit = 50;
        },
        setup (e1) {
            t.onerror && (!function(e1) {
                !function(e1) {
                    const t = "error";
                    nt(t, e1), rt(t, vt);
                }((t)=>{
                    const { stackParser: n, attachStacktrace: r } = Yr();
                    if (fn() !== e1 || or()) return;
                    const { msg: i, url: o, line: a, column: s, error: c } = t, l = function(e1, t, n, r) {
                        const i = e1.exception = e1.exception || {}, o = i.values = i.values || [], a = o[0] = o[0] || {}, s = a.stacktrace = a.stacktrace || {}, c = s.frames = s.frames || [], l = isNaN(parseInt(r, 10)) ? void 0 : r, u = isNaN(parseInt(n, 10)) ? void 0 : n, d = oe(t) && t.length > 0 ? t : function() {
                            try {
                                return Ce.document.location.href;
                            } catch (e1) {
                                return "";
                            }
                        }();
                        0 === c.length && c.push({
                            colno: l,
                            filename: d,
                            function: He,
                            in_app: !0,
                            lineno: u
                        });
                        return e1;
                    }(fr(n, c || i, void 0, r, !1), o, a, s);
                    l.level = "error", In(l, {
                        originalException: c,
                        mechanism: {
                            handled: !1,
                            type: "onerror"
                        }
                    });
                });
            }(e1), Qr("onerror")), t.onunhandledrejection && (!function(e1) {
                !function(e1) {
                    const t = "unhandledrejection";
                    nt(t, e1), rt(t, mt);
                }((t)=>{
                    const { stackParser: n, attachStacktrace: r } = Yr();
                    if (fn() !== e1 || or()) return;
                    const i = function(e1) {
                        if (se(e1)) return e1;
                        try {
                            if ("reason" in e1) return e1.reason;
                            if ("detail" in e1 && "reason" in e1.detail) return e1.detail.reason;
                        } catch (e1) {}
                        return e1;
                    }(t), o = se(i) ? {
                        exception: {
                            values: [
                                {
                                    type: "UnhandledRejection",
                                    value: `Non-Error promise rejection captured with value: ${String(i)}`
                                }
                            ]
                        }
                    } : fr(n, i, void 0, r, !0);
                    o.level = "error", In(o, {
                        originalException: i,
                        mechanism: {
                            handled: !1,
                            type: "onunhandledrejection"
                        }
                    });
                });
            }(e1), Qr("onunhandledrejection"));
        }
    };
};
function Qr(e1) {
    sr && Le.log(`Global Handler attached: ${e1}`);
}
function Yr() {
    const e1 = fn();
    return e1 && e1.getOptions() || {
        stackParser: ()=>[],
        attachStacktrace: !1
    };
}
const Kr = ()=>({
        name: "HttpContext",
        preprocessEvent (e1) {
            if (!rr.navigator && !rr.location && !rr.document) return;
            const t = e1.request && e1.request.url || rr.location && rr.location.href, { referrer: n } = rr.document || {}, { userAgent: r } = rr.navigator || {}, i = {
                ...e1.request && e1.request.headers,
                ...n && {
                    Referer: n
                },
                ...r && {
                    "User-Agent": r
                }
            }, o = {
                ...e1.request,
                ...t && {
                    url: t
                },
                headers: i
            };
            e1.request = o;
        }
    }), Xr = (e1 = {})=>{
    const t = e1.limit || 5, n = e1.key || "cause";
    return {
        name: "LinkedErrors",
        preprocessEvent (e1, r, i) {
            const o = i.getOptions();
            me(cr, o.stackParser, o.maxValueLength, n, t, e1, r);
        }
    };
};
var Zr = "new", ei = "loading", ti = "loaded", ni = "joining-meeting", ri = "joined-meeting", ii = "left-meeting", oi = "error", ai = "blocked", si = "off", ci = "sendable", li = "loading", ui = "interrupted", di = "playable", pi = "unknown", hi = "full", fi = "lobby", vi = "none", gi = "base", mi = "*", yi = "ejected", _i = "nbf-room", bi = "nbf-token", wi = "exp-room", ki = "exp-token", Si = "no-room", Mi = "meeting-full", Ci = "end-of-life", Ei = "not-allowed", Ti = "connection-error", Pi = "cam-in-use", Oi = "mic-in-use", Ai = "cam-mic-in-use", ji = "permissions", Li = "undefined-mediadevices", xi = "not-found", Ii = "constraints", Di = "unknown", Ni = "iframe-ready-for-launch-config", Fi = "iframe-launch-config", Ri = "theme-updated", Bi = "loading", Ui = "load-attempt-failed", Vi = "loaded", Ji = "started-camera", $i = "camera-error", qi = "joining-meeting", zi = "joined-meeting", Wi = "left-meeting", Hi = "participant-joined", Gi = "participant-updated", Qi = "participant-left", Yi = "participant-counts-updated", Ki = "access-state-updated", Xi = "meeting-session-summary-updated", Zi = "meeting-session-state-updated", eo = "meeting-session-data-error", to = "waiting-participant-added", no = "waiting-participant-updated", ro = "waiting-participant-removed", io = "track-started", oo = "track-stopped", ao = "transcription-started", so = "transcription-stopped", co = "transcription-error", lo = "recording-started", uo = "recording-stopped", po = "recording-stats", ho = "recording-error", fo = "recording-upload-completed", vo = "recording-data", go = "app-message", mo = "transcription-message", yo = "remote-media-player-started", _o = "remote-media-player-updated", bo = "remote-media-player-stopped", wo = "local-screen-share-started", ko = "local-screen-share-stopped", So = "local-screen-share-canceled", Mo = "active-speaker-change", Co = "active-speaker-mode-change", Eo = "network-quality-change", To = "network-connection", Po = "cpu-load-change", Oo = "face-counts-updated", Ao = "fullscreen", jo = "exited-fullscreen", Lo = "live-streaming-started", xo = "live-streaming-updated", Io = "live-streaming-stopped", Do = "live-streaming-error", No = "lang-updated", Fo = "receive-settings-updated", Ro = "input-settings-updated", Bo = "nonfatal-error", Uo = "error", Vo = 4096, Jo = 102400, $o = "iframe-call-message", qo = "local-screen-start", zo = "daily-method-update-live-streaming-endpoints", Wo = "transmit-log", Ho = "daily-custom-track", Go = {
    NONE: "none",
    BGBLUR: "background-blur",
    BGIMAGE: "background-image",
    FACE_DETECTION: "face-detection"
}, Qo = {
    NONE: "none",
    NOISE_CANCELLATION: "noise-cancellation"
}, Yo = {
    PLAY: "play",
    PAUSE: "pause"
}, Ko = [
    "jpg",
    "png",
    "jpeg"
], Xo = "add-endpoints", Zo = "remove-endpoints", ea = "sip-call-transfer";
function ta() {
    return !na() && "undefined" != typeof window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : "";
}
function na() {
    return "undefined" != typeof navigator && navigator.product && "ReactNative" === navigator.product;
}
function ra() {
    return navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
}
function ia() {
    return !!(navigator && navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) && (function(e1, t) {
        if (!e1 || !t) return !0;
        switch(e1){
            case "Chrome":
                return t.major >= 75;
            case "Safari":
                return RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection") && !(13 === t.major && 0 === t.minor && 0 === t.point);
            case "Firefox":
                return t.major >= 67;
        }
        return !0;
    }(pa(), ha()) || na());
}
function oa() {
    if (na()) return !1;
    if (!document) return !1;
    var e1 = document.createElement("iframe");
    return !!e1.requestFullscreen || !!e1.webkitRequestFullscreen;
}
var aa = function() {
    try {
        var e1 = document.createElement("canvas"), t = null != e1.getContext("webgl2");
        return e1.remove(), t;
    } catch (e1) {
        return !1;
    }
}();
function sa() {
    var e1 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    return !na() && !!aa && (e1 ? function() {
        if (da()) return !1;
        return [
            "Chrome",
            "Firefox"
        ].includes(pa());
    }() : function() {
        if (da()) return !1;
        var e1 = pa();
        if ("Safari" === e1) {
            var t = ma();
            if (t.major < 15 || 15 === t.major && t.minor < 4) return !1;
        }
        if ("Chrome" === e1) {
            return fa().major >= 77;
        }
        if ("Firefox" === e1) {
            return ya().major >= 97;
        }
        return [
            "Chrome",
            "Firefox",
            "Safari"
        ].includes(e1);
    }());
}
function ca() {
    if (na()) return !1;
    if (ua()) return !1;
    if ("undefined" == typeof AudioWorkletNode) return !1;
    switch(pa()){
        case "Chrome":
        case "Firefox":
            return !0;
        case "Safari":
            var e1 = ha();
            return e1.major > 17 || 17 === e1.major && e1.minor >= 4;
    }
    return !1;
}
function la() {
    return ra() && !function() {
        var e1, t = pa();
        if (!ta()) return !0;
        switch(t){
            case "Chrome":
                return (e1 = fa()).major && e1.major > 0 && e1.major < 75;
            case "Firefox":
                return (e1 = ya()).major < 91;
            case "Safari":
                return (e1 = ma()).major < 13 || 13 === e1.major && e1.minor < 1;
            default:
                return !0;
        }
    }();
}
function ua() {
    return ta().match(/Linux; Android/);
}
function da() {
    var e1, t, n = ta(), r = n.match(/Mac/) && (!na() && "undefined" != typeof window && null !== (e1 = window) && void 0 !== e1 && null !== (t = e1.navigator) && void 0 !== t && t.maxTouchPoints ? window.navigator.maxTouchPoints : 0) >= 5;
    return !!(n.match(/Mobi/) || n.match(/Android/) || r) || !!ta().match(/DailyAnd\//) || void 0;
}
function pa() {
    if ("undefined" != typeof window) {
        var e1 = ta();
        return va() ? "Safari" : e1.indexOf("Edge") > -1 ? "Edge" : e1.match(/Chrome\//) ? "Chrome" : e1.indexOf("Safari") > -1 || ga() ? "Safari" : e1.indexOf("Firefox") > -1 ? "Firefox" : e1.indexOf("MSIE") > -1 || e1.indexOf(".NET") > -1 ? "IE" : "Unknown Browser";
    }
}
function ha() {
    switch(pa()){
        case "Chrome":
            return fa();
        case "Safari":
            return ma();
        case "Firefox":
            return ya();
        case "Edge":
            return function() {
                var e1 = 0, t = 0;
                if ("undefined" != typeof window) {
                    var n = ta().match(/Edge\/(\d+).(\d+)/);
                    if (n) try {
                        e1 = parseInt(n[1]), t = parseInt(n[2]);
                    } catch (e1) {}
                }
                return {
                    major: e1,
                    minor: t
                };
            }();
    }
}
function fa() {
    var e1 = 0, t = 0, n = 0, r = 0, i = !1;
    if ("undefined" != typeof window) {
        var o = ta(), a = o.match(/Chrome\/(\d+).(\d+).(\d+).(\d+)/);
        if (a) try {
            e1 = parseInt(a[1]), t = parseInt(a[2]), n = parseInt(a[3]), r = parseInt(a[4]), i = o.indexOf("OPR/") > -1;
        } catch (e1) {}
    }
    return {
        major: e1,
        minor: t,
        build: n,
        patch: r,
        opera: i
    };
}
function va() {
    return !!ta().match(/iPad|iPhone|iPod/i) && ra();
}
function ga() {
    return ta().indexOf("AppleWebKit/605.1.15") > -1;
}
function ma() {
    var e1 = 0, t = 0, n = 0;
    if ("undefined" != typeof window) {
        var r = ta().match(/Version\/(\d+).(\d+)(.(\d+))?/);
        if (r) try {
            e1 = parseInt(r[1]), t = parseInt(r[2]), n = parseInt(r[4]);
        } catch (e1) {}
        else (va() || ga()) && (e1 = 14, t = 0, n = 3);
    }
    return {
        major: e1,
        minor: t,
        point: n
    };
}
function ya() {
    var e1 = 0, t = 0;
    if ("undefined" != typeof window) {
        var n = ta().match(/Firefox\/(\d+).(\d+)/);
        if (n) try {
            e1 = parseInt(n[1]), t = parseInt(n[2]);
        } catch (e1) {}
    }
    return {
        major: e1,
        minor: t
    };
}
var _a = function() {
    function e1() {
        t(this, e1);
    }
    return o(e1, [
        {
            key: "addListenerForMessagesFromCallMachine",
            value: function(e1, t, n) {
                Y();
            }
        },
        {
            key: "addListenerForMessagesFromDailyJs",
            value: function(e1, t, n) {
                Y();
            }
        },
        {
            key: "sendMessageToCallMachine",
            value: function(e1, t, n, r) {
                Y();
            }
        },
        {
            key: "sendMessageToDailyJs",
            value: function(e1, t) {
                Y();
            }
        },
        {
            key: "removeListener",
            value: function(e1) {
                Y();
            }
        }
    ]), e1;
}();
function ba(e1, t) {
    var n = Object.keys(e1);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e1);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e1, t).enumerable;
        })), n.push.apply(n, r);
    }
    return n;
}
function wa(e1) {
    for(var t = 1; t < arguments.length; t++){
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? ba(Object(n), !0).forEach(function(t) {
            d(e1, t, n[t]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : ba(Object(n)).forEach(function(t) {
            Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
        });
    }
    return e1;
}
function ka(e1) {
    var t = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0;
        } catch (e1) {
            return !1;
        }
    }();
    return function() {
        var n, r = u(e1);
        if (t) {
            var i = u(this).constructor;
            n = Reflect.construct(r, arguments, i);
        } else n = r.apply(this, arguments);
        return l(this, n);
    };
}
var Sa = function() {
    c(n, _a);
    var e1 = ka(n);
    function n() {
        var r;
        return t(this, n), (r = e1.call(this))._wrappedListeners = {}, r._messageCallbacks = {}, r;
    }
    return o(n, [
        {
            key: "addListenerForMessagesFromCallMachine",
            value: function(e1, t, n) {
                var r = this, i = function(i) {
                    if (i.data && "iframe-call-message" === i.data.what && (!i.data.callClientId || i.data.callClientId === t) && (!i.data.from || "module" !== i.data.from)) {
                        var o = wa({}, i.data);
                        if (delete o.from, o.callbackStamp && r._messageCallbacks[o.callbackStamp]) {
                            var a = o.callbackStamp;
                            r._messageCallbacks[a].call(n, o), delete r._messageCallbacks[a];
                        }
                        delete o.what, delete o.callbackStamp, e1.call(n, o);
                    }
                };
                this._wrappedListeners[e1] = i, window.addEventListener("message", i);
            }
        },
        {
            key: "addListenerForMessagesFromDailyJs",
            value: function(e1, t, n) {
                var r = function(r) {
                    var i;
                    if (!(!r.data || r.data.what !== $o || !r.data.action || r.data.from && "module" !== r.data.from || r.data.callClientId && t && r.data.callClientId !== t || null != r && null !== (i = r.data) && void 0 !== i && i.callFrameId)) {
                        var o = r.data;
                        e1.call(n, o);
                    }
                };
                this._wrappedListeners[e1] = r, window.addEventListener("message", r);
            }
        },
        {
            key: "sendMessageToCallMachine",
            value: function(e1, t, n, r) {
                if (!n) throw new Error("undefined callClientId. Are you trying to use a DailyCall instance previously destroyed?");
                var i = wa({}, e1);
                if (i.what = $o, i.from = "module", i.callClientId = n, t) {
                    var o = Q();
                    this._messageCallbacks[o] = t, i.callbackStamp = o;
                }
                var a = r ? r.contentWindow : window, s = this._callMachineTargetOrigin(r);
                s && a.postMessage(i, s);
            }
        },
        {
            key: "sendMessageToDailyJs",
            value: function(e1, t) {
                e1.what = $o, e1.callClientId = t, e1.from = "embedded", window.postMessage(e1, this._targetOriginFromWindowLocation());
            }
        },
        {
            key: "removeListener",
            value: function(e1) {
                var t = this._wrappedListeners[e1];
                t && (window.removeEventListener("message", t), delete this._wrappedListeners[e1]);
            }
        },
        {
            key: "forwardPackagedMessageToCallMachine",
            value: function(e1, t, n) {
                var r = wa({}, e1);
                r.callClientId = n;
                var i = t ? t.contentWindow : window, o = this._callMachineTargetOrigin(t);
                o && i.postMessage(r, o);
            }
        },
        {
            key: "addListenerForPackagedMessagesFromCallMachine",
            value: function(e1, t) {
                var n = function(n) {
                    if (n.data && "iframe-call-message" === n.data.what && (!n.data.callClientId || n.data.callClientId === t) && (!n.data.from || "module" !== n.data.from)) {
                        var r = n.data;
                        e1(r);
                    }
                };
                return this._wrappedListeners[e1] = n, window.addEventListener("message", n), e1;
            }
        },
        {
            key: "removeListenerForPackagedMessagesFromCallMachine",
            value: function(e1) {
                var t = this._wrappedListeners[e1];
                t && (window.removeEventListener("message", t), delete this._wrappedListeners[e1]);
            }
        },
        {
            key: "_callMachineTargetOrigin",
            value: function(e1) {
                return e1 ? e1.src ? new URL(e1.src).origin : void 0 : this._targetOriginFromWindowLocation();
            }
        },
        {
            key: "_targetOriginFromWindowLocation",
            value: function() {
                return "file:" === window.location.protocol ? "*" : window.location.origin;
            }
        }
    ]), n;
}();
function Ma(e1, t) {
    var n = Object.keys(e1);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e1);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e1, t).enumerable;
        })), n.push.apply(n, r);
    }
    return n;
}
function Ca(e1) {
    var t = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0;
        } catch (e1) {
            return !1;
        }
    }();
    return function() {
        var n, r = u(e1);
        if (t) {
            var i = u(this).constructor;
            n = Reflect.construct(r, arguments, i);
        } else n = r.apply(this, arguments);
        return l(this, n);
    };
}
var Ea = function() {
    c(n, _a);
    var e1 = Ca(n);
    function n() {
        var r;
        return t(this, n), r = e1.call(this), global.callMachineToDailyJsEmitter = global.callMachineToDailyJsEmitter || new m.EventEmitter, global.dailyJsToCallMachineEmitter = global.dailyJsToCallMachineEmitter || new m.EventEmitter, r._wrappedListeners = {}, r._messageCallbacks = {}, r;
    }
    return o(n, [
        {
            key: "addListenerForMessagesFromCallMachine",
            value: function(e1, t, n) {
                this._addListener(e1, global.callMachineToDailyJsEmitter, t, n, "received call machine message");
            }
        },
        {
            key: "addListenerForMessagesFromDailyJs",
            value: function(e1, t, n) {
                this._addListener(e1, global.dailyJsToCallMachineEmitter, t, n, "received daily-js message");
            }
        },
        {
            key: "sendMessageToCallMachine",
            value: function(e1, t, n) {
                this._sendMessage(e1, global.dailyJsToCallMachineEmitter, n, t, "sending message to call machine");
            }
        },
        {
            key: "sendMessageToDailyJs",
            value: function(e1, t) {
                this._sendMessage(e1, global.callMachineToDailyJsEmitter, t, null, "sending message to daily-js");
            }
        },
        {
            key: "removeListener",
            value: function(e1) {
                var t = this._wrappedListeners[e1];
                t && (global.callMachineToDailyJsEmitter.removeListener("message", t), global.dailyJsToCallMachineEmitter.removeListener("message", t), delete this._wrappedListeners[e1]);
            }
        },
        {
            key: "_addListener",
            value: function(e1, t, n, r, i) {
                var o = this, a = function(t) {
                    if (t.callClientId === n) {
                        if (t.callbackStamp && o._messageCallbacks[t.callbackStamp]) {
                            var i = t.callbackStamp;
                            o._messageCallbacks[i].call(r, t), delete o._messageCallbacks[i];
                        }
                        e1.call(r, t);
                    }
                };
                this._wrappedListeners[e1] = a, t.addListener("message", a);
            }
        },
        {
            key: "_sendMessage",
            value: function(e1, t, n, r, i) {
                var o = function(e1) {
                    for(var t = 1; t < arguments.length; t++){
                        var n = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? Ma(Object(n), !0).forEach(function(t) {
                            d(e1, t, n[t]);
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : Ma(Object(n)).forEach(function(t) {
                            Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
                        });
                    }
                    return e1;
                }({}, e1);
                if (o.callClientId = n, r) {
                    var a = Q();
                    this._messageCallbacks[a] = r, o.callbackStamp = a;
                }
                t.emit("message", o);
            }
        }
    ]), n;
}(), Ta = "replace", Pa = "shallow-merge", Oa = [
    Ta,
    Pa
];
var Aa = function() {
    function e1() {
        var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = n.data, i = n.mergeStrategy, o = void 0 === i ? Ta : i;
        t(this, e1), e1._validateMergeStrategy(o), e1._validateData(r, o), this.mergeStrategy = o, this.data = r;
    }
    return o(e1, [
        {
            key: "isNoOp",
            value: function() {
                return e1.isNoOpUpdate(this.data, this.mergeStrategy);
            }
        }
    ], [
        {
            key: "isNoOpUpdate",
            value: function(e1, t) {
                return 0 === Object.keys(e1).length && t === Pa;
            }
        },
        {
            key: "_validateMergeStrategy",
            value: function(e1) {
                if (!Oa.includes(e1)) throw Error("Unrecognized mergeStrategy provided. Options are: [".concat(Oa, "]"));
            }
        },
        {
            key: "_validateData",
            value: function(e1, t) {
                if (!function(e1) {
                    if (null == e1 || "object" !== n(e1)) return !1;
                    var t = Object.getPrototypeOf(e1);
                    return null == t || t === Object.prototype;
                }(e1)) throw Error("Meeting session data must be a plain (map-like) object");
                var r;
                try {
                    if (r = JSON.stringify(e1), t === Ta) {
                        var i = JSON.parse(r);
                        D(i, e1) || console.warn("The meeting session data provided will be modified when serialized.", i, e1);
                    } else if (t === Pa) {
                        for(var o in e1)if (Object.hasOwnProperty.call(e1, o) && void 0 !== e1[o]) {
                            var a = JSON.parse(JSON.stringify(e1[o]));
                            D(e1[o], a) || console.warn("At least one key in the meeting session data provided will be modified when serialized.", a, e1[o]);
                        }
                    }
                } catch (e1) {
                    throw Error("Meeting session data must be serializable to JSON: ".concat(e1));
                }
                if (r.length > Jo) throw Error("Meeting session data is too large (".concat(r.length, " characters). Maximum size suppported is ").concat(Jo, "."));
            }
        }
    ]), e1;
}();
function ja(e1, t, n) {
    return ja = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0;
        } catch (e1) {
            return !1;
        }
    }() ? Reflect.construct.bind() : function(e1, t, n) {
        var r = [
            null
        ];
        r.push.apply(r, t);
        var i = new (Function.bind.apply(e1, r));
        return n && s(i, n.prototype), i;
    }, ja.apply(null, arguments);
}
function La(e1) {
    var t = "function" == typeof Map ? new Map : void 0;
    return La = function(e1) {
        if (null === e1 || (n = e1, -1 === Function.toString.call(n).indexOf("[native code]"))) return e1;
        var n;
        if ("function" != typeof e1) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== t) {
            if (t.has(e1)) return t.get(e1);
            t.set(e1, r);
        }
        function r() {
            return ja(e1, arguments, u(this).constructor);
        }
        return r.prototype = Object.create(e1.prototype, {
            constructor: {
                value: r,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), s(r, e1);
    }, La(e1);
}
function xa(e1) {
    var t = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0;
        } catch (e1) {
            return !1;
        }
    }();
    return function() {
        var n, r = u(e1);
        if (t) {
            var i = u(this).constructor;
            n = Reflect.construct(r, arguments, i);
        } else n = r.apply(this, arguments);
        return l(this, n);
    };
}
function Ia(e1) {
    var t, n = null === (t = window._daily) || void 0 === t ? void 0 : t.pendings;
    if (n) {
        var r = n.indexOf(e1);
        -1 !== r && n.splice(r, 1);
    }
}
var Da = function() {
    function e1(n) {
        t(this, e1), this._currentLoad = null, this._callClientId = n;
    }
    return o(e1, [
        {
            key: "load",
            value: function() {
                var e1, t = this, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0, i = arguments.length > 2 ? arguments[2] : void 0;
                if (this.loaded) return window._daily.instances[this._callClientId].callMachine.reset(), void r(!0);
                e1 = this._callClientId, window._daily.pendings.push(e1), this._currentLoad && this._currentLoad.cancel(), this._currentLoad = new Na(n, function() {
                    r(!1);
                }, function(e1, n) {
                    n || Ia(t._callClientId), i(e1, n);
                }), this._currentLoad.start();
            }
        },
        {
            key: "cancel",
            value: function() {
                this._currentLoad && this._currentLoad.cancel(), Ia(this._callClientId);
            }
        },
        {
            key: "loaded",
            get: function() {
                return this._currentLoad && this._currentLoad.succeeded;
            }
        }
    ]), e1;
}(), Na = function() {
    function e1() {
        var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0, i = arguments.length > 2 ? arguments[2] : void 0;
        t(this, e1), this._attemptsRemaining = 3, this._currentAttempt = null, this._dailyConfig = n, this._successCallback = r, this._failureCallback = i;
    }
    return o(e1, [
        {
            key: "start",
            value: function() {
                var e1 = this;
                if (!this._currentAttempt) {
                    this._currentAttempt = new Ba(this._dailyConfig, this._successCallback, function t(n) {
                        e1._currentAttempt.cancelled || (e1._attemptsRemaining--, e1._failureCallback(n, e1._attemptsRemaining > 0), e1._attemptsRemaining <= 0 || setTimeout(function() {
                            e1._currentAttempt.cancelled || (e1._currentAttempt = new Ba(e1._dailyConfig, e1._successCallback, t), e1._currentAttempt.start());
                        }, 3e3));
                    }), this._currentAttempt.start();
                }
            }
        },
        {
            key: "cancel",
            value: function() {
                this._currentAttempt && this._currentAttempt.cancel();
            }
        },
        {
            key: "cancelled",
            get: function() {
                return this._currentAttempt && this._currentAttempt.cancelled;
            }
        },
        {
            key: "succeeded",
            get: function() {
                return this._currentAttempt && this._currentAttempt.succeeded;
            }
        }
    ]), e1;
}(), Fa = function() {
    c(n, La(Error));
    var e1 = xa(n);
    function n() {
        return t(this, n), e1.apply(this, arguments);
    }
    return o(n);
}(), Ra = 2e4, Ba = function() {
    function e1(n, r, i) {
        t(this, e1), this._loadAttemptImpl = na() || !n.avoidEval ? new Ua(n, r, i) : new Va(n, r, i);
    }
    var n;
    return o(e1, [
        {
            key: "start",
            value: (n = h(function*() {
                return this._loadAttemptImpl.start();
            }), function() {
                return n.apply(this, arguments);
            })
        },
        {
            key: "cancel",
            value: function() {
                this._loadAttemptImpl.cancel();
            }
        },
        {
            key: "cancelled",
            get: function() {
                return this._loadAttemptImpl.cancelled;
            }
        },
        {
            key: "succeeded",
            get: function() {
                return this._loadAttemptImpl.succeeded;
            }
        }
    ]), e1;
}(), Ua = function() {
    function e1(n, r, i) {
        t(this, e1), this.cancelled = !1, this.succeeded = !1, this._networkTimedOut = !1, this._networkTimeout = null, this._iosCache = "undefined" != typeof iOSCallObjectBundleCache && iOSCallObjectBundleCache, this._refetchHeaders = null, this._dailyConfig = n, this._successCallback = r, this._failureCallback = i;
    }
    var n, r, i, a;
    return o(e1, [
        {
            key: "start",
            value: (a = h(function*() {
                var e1 = X(this._dailyConfig);
                !(yield this._tryLoadFromIOSCache(e1)) && this._loadFromNetwork(e1);
            }), function() {
                return a.apply(this, arguments);
            })
        },
        {
            key: "cancel",
            value: function() {
                clearTimeout(this._networkTimeout), this.cancelled = !0;
            }
        },
        {
            key: "_tryLoadFromIOSCache",
            value: (i = h(function*(e1) {
                if (!this._iosCache) return !1;
                try {
                    var t = yield this._iosCache.get(e1);
                    return !!this.cancelled || !!t && (t.code ? (Function('"use strict";' + t.code)(), this.succeeded = !0, this._successCallback(), !0) : (this._refetchHeaders = t.refetchHeaders, !1));
                } catch (e1) {
                    return !1;
                }
            }), function(e1) {
                return i.apply(this, arguments);
            })
        },
        {
            key: "_loadFromNetwork",
            value: (r = h(function*(e1) {
                var t = this;
                this._networkTimeout = setTimeout(function() {
                    t._networkTimedOut = !0, t._failureCallback({
                        msg: "Timed out (>".concat(Ra, " ms) when loading call object bundle ").concat(e1),
                        type: "timeout"
                    });
                }, Ra);
                try {
                    var n = this._refetchHeaders ? {
                        headers: this._refetchHeaders
                    } : {}, r = yield fetch(e1, n);
                    if (clearTimeout(this._networkTimeout), this.cancelled || this._networkTimedOut) throw new Fa;
                    var i = yield this._getBundleCodeFromResponse(e1, r);
                    if (this.cancelled) throw new Fa;
                    Function('"use strict";' + i)(), this._iosCache && this._iosCache.set(e1, i, r.headers), this.succeeded = !0, this._successCallback();
                } catch (t) {
                    if (clearTimeout(this._networkTimeout), t instanceof Fa || this.cancelled || this._networkTimedOut) return;
                    this._failureCallback({
                        msg: "Failed to load call object bundle ".concat(e1, ": ").concat(t),
                        type: t.message
                    });
                }
            }), function(e1) {
                return r.apply(this, arguments);
            })
        },
        {
            key: "_getBundleCodeFromResponse",
            value: (n = h(function*(e1, t) {
                if (t.ok) return yield t.text();
                if (this._iosCache && 304 === t.status) return (yield this._iosCache.renew(e1, t.headers)).code;
                throw new Error("Received ".concat(t.status, " response"));
            }), function(e1, t) {
                return n.apply(this, arguments);
            })
        }
    ]), e1;
}(), Va = function() {
    function e1(n, r, i) {
        t(this, e1), this.cancelled = !1, this.succeeded = !1, this._dailyConfig = n, this._successCallback = r, this._failureCallback = i, this._attemptId = Q(), this._networkTimeout = null, this._scriptElement = null;
    }
    return o(e1, [
        {
            key: "start",
            value: function() {
                window._dailyCallMachineLoadWaitlist || (window._dailyCallMachineLoadWaitlist = new Set);
                var e1 = X(this._dailyConfig);
                "object" === ("undefined" == typeof document ? "undefined" : n(document)) ? this._startLoading(e1) : this._failureCallback({
                    msg: "Call object bundle must be loaded in a DOM/web context",
                    type: "missing context"
                });
            }
        },
        {
            key: "cancel",
            value: function() {
                this._stopLoading(), this.cancelled = !0;
            }
        },
        {
            key: "_startLoading",
            value: function(e1) {
                var t = this;
                this._signUpForCallMachineLoadWaitlist(), this._networkTimeout = setTimeout(function() {
                    t._stopLoading(), t._failureCallback({
                        msg: "Timed out (>".concat(Ra, " ms) when loading call object bundle ").concat(e1),
                        type: "timeout"
                    });
                }, Ra);
                var n = document.getElementsByTagName("head")[0], r = document.createElement("script");
                this._scriptElement = r, r.onload = function() {
                    t._stopLoading(), t.succeeded = !0, t._successCallback();
                }, r.onerror = function(e1) {
                    t._stopLoading(), t._failureCallback({
                        msg: "Failed to load call object bundle ".concat(e1.target.src),
                        type: e1.message
                    });
                }, r.src = e1, n.appendChild(r);
            }
        },
        {
            key: "_stopLoading",
            value: function() {
                this._withdrawFromCallMachineLoadWaitlist(), clearTimeout(this._networkTimeout), this._scriptElement && (this._scriptElement.onload = null, this._scriptElement.onerror = null);
            }
        },
        {
            key: "_signUpForCallMachineLoadWaitlist",
            value: function() {
                window._dailyCallMachineLoadWaitlist.add(this._attemptId);
            }
        },
        {
            key: "_withdrawFromCallMachineLoadWaitlist",
            value: function() {
                window._dailyCallMachineLoadWaitlist.delete(this._attemptId);
            }
        }
    ]), e1;
}(), Ja = function(e1, t, n) {
    return !0 === za(e1.local, t, n);
}, $a = function(e1, t, n) {
    return e1.local.streams && e1.local.streams[t] && e1.local.streams[t].stream && e1.local.streams[t].stream["get".concat("video" === n ? "Video" : "Audio", "Tracks")]()[0];
}, qa = function(e1, t, n, r) {
    var i = Wa(e1, t, n, r);
    return i && i.pendingTrack;
}, za = function(e1, t, n) {
    if (!e1) return !1;
    var r = function(e1) {
        switch(e1){
            case "avatar":
                return !0;
            case "staged":
                return e1;
            default:
                return !!e1;
        }
    }, i = e1.public.subscribedTracks;
    return i && i[t] ? -1 === [
        "cam-audio",
        "cam-video",
        "screen-video",
        "screen-audio",
        "rmpAudio",
        "rmpVideo"
    ].indexOf(n) && i[t].custom ? [
        !0,
        "staged"
    ].includes(i[t].custom) ? r(i[t].custom) : r(i[t].custom[n]) : r(i[t][n]) : !i || r(i.ALL);
}, Wa = function(e1, t, n, r) {
    var i = Object.values(e1.streams || {}).filter(function(e1) {
        return e1.participantId === t && e1.type === n && e1.pendingTrack && e1.pendingTrack.kind === r;
    }).sort(function(e1, t) {
        return new Date(t.starttime) - new Date(e1.starttime);
    });
    return i && i[0];
}, Ha = function(e1, t) {
    var n = e1.local.public.customTracks;
    if (n && n[t]) return n[t].track;
};
function Ga(e1, t) {
    for(var n = t.getState(), r = 0, i = [
        "cam",
        "screen"
    ]; r < i.length; r++)for(var o = i[r], a = 0, s = [
        "video",
        "audio"
    ]; a < s.length; a++){
        var c = s[a], l = "cam" === o ? c : "screen".concat(c.charAt(0).toUpperCase() + c.slice(1)), u = e1.tracks[l];
        if (u) {
            var d = e1.local ? $a(n, o, c) : qa(n, e1.session_id, o, c);
            "playable" === u.state && (u.track = d), u.persistentTrack = d;
        }
    }
}
function Qa(e1, t) {
    try {
        var n = t.getState();
        for(var r in e1.tracks)if (!Ya(r)) {
            var i = e1.tracks[r].kind;
            if (i) {
                var o = e1.tracks[r];
                if (o) {
                    var a = e1.local ? Ha(n, r) : qa(n, e1.session_id, r, i);
                    "playable" === o.state && (e1.tracks[r].track = a), o.persistentTrack = a;
                }
            } else console.error("unknown type for custom track");
        }
    } catch (e1) {
        console.error(e1);
    }
}
function Ya(e1) {
    return [
        "video",
        "audio",
        "screenVideo",
        "screenAudio"
    ].includes(e1);
}
function Ka(e1, t, n) {
    var r = n.getState();
    if (e1.local) {
        if (e1.audio) try {
            e1.audioTrack = r.local.streams.cam.stream.getAudioTracks()[0], e1.audioTrack || (e1.audio = !1);
        } catch (e1) {}
        if (e1.video) try {
            e1.videoTrack = r.local.streams.cam.stream.getVideoTracks()[0], e1.videoTrack || (e1.video = !1);
        } catch (e1) {}
        if (e1.screen) try {
            e1.screenVideoTrack = r.local.streams.screen.stream.getVideoTracks()[0], e1.screenAudioTrack = r.local.streams.screen.stream.getAudioTracks()[0], e1.screenVideoTrack || e1.screenAudioTrack || (e1.screen = !1);
        } catch (e1) {}
    } else {
        var i = !0;
        try {
            var o = r.participants[e1.session_id];
            o && o.public && o.public.rtcType && "peer-to-peer" === o.public.rtcType.impl && o.private && ![
                "connected",
                "completed"
            ].includes(o.private.peeringState) && (i = !1);
        } catch (e1) {
            console.error(e1);
        }
        if (!i) return e1.audio = !1, e1.audioTrack = !1, e1.video = !1, e1.videoTrack = !1, e1.screen = !1, void (e1.screenTrack = !1);
        try {
            r.streams;
            if (e1.audio && Ja(r, e1.session_id, "cam-audio")) {
                var a = qa(r, e1.session_id, "cam", "audio");
                a && (t && t.audioTrack && t.audioTrack.id === a.id ? e1.audioTrack = a : a.muted || (e1.audioTrack = a)), e1.audioTrack || (e1.audio = !1);
            }
            if (e1.video && Ja(r, e1.session_id, "cam-video")) {
                var s = qa(r, e1.session_id, "cam", "video");
                s && (t && t.videoTrack && t.videoTrack.id === s.id ? e1.videoTrack = s : s.muted || (e1.videoTrack = s)), e1.videoTrack || (e1.video = !1);
            }
            if (e1.screen && Ja(r, e1.session_id, "screen-audio")) {
                var c = qa(r, e1.session_id, "screen", "audio");
                c && (t && t.screenAudioTrack && t.screenAudioTrack.id === c.id ? e1.screenAudioTrack = c : c.muted || (e1.screenAudioTrack = c));
            }
            if (e1.screen && Ja(r, e1.session_id, "screen-video")) {
                var l = qa(r, e1.session_id, "screen", "video");
                l && (t && t.screenVideoTrack && t.screenVideoTrack.id === l.id ? e1.screenVideoTrack = l : l.muted || (e1.screenVideoTrack = l));
            }
            e1.screenVideoTrack || e1.screenAudioTrack || (e1.screen = !1);
        } catch (e1) {
            console.error("unexpected error matching up tracks", e1);
        }
    }
}
function Xa(e1, t) {
    var n = "undefined" != typeof Symbol && e1[Symbol.iterator] || e1["@@iterator"];
    if (!n) {
        if (Array.isArray(e1) || (n = function(e1, t) {
            if (!e1) return;
            if ("string" == typeof e1) return Za(e1, t);
            var n = Object.prototype.toString.call(e1).slice(8, -1);
            "Object" === n && e1.constructor && (n = e1.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(e1);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Za(e1, t);
        }(e1)) || t && e1 && "number" == typeof e1.length) {
            n && (e1 = n);
            var r = 0, i = function() {};
            return {
                s: i,
                n: function() {
                    return r >= e1.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: e1[r++]
                    };
                },
                e: function(e1) {
                    throw e1;
                },
                f: i
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = !0, s = !1;
    return {
        s: function() {
            n = n.call(e1);
        },
        n: function() {
            var e1 = n.next();
            return a = e1.done, e1;
        },
        e: function(e1) {
            s = !0, o = e1;
        },
        f: function() {
            try {
                a || null == n.return || n.return();
            } finally{
                if (s) throw o;
            }
        }
    };
}
function Za(e1, t) {
    (null == t || t > e1.length) && (t = e1.length);
    for(var n = 0, r = new Array(t); n < t; n++)r[n] = e1[n];
    return r;
}
var es = new Map, ts = null;
function ns(e1, t) {
    var n = "undefined" != typeof Symbol && e1[Symbol.iterator] || e1["@@iterator"];
    if (!n) {
        if (Array.isArray(e1) || (n = function(e1, t) {
            if (!e1) return;
            if ("string" == typeof e1) return rs(e1, t);
            var n = Object.prototype.toString.call(e1).slice(8, -1);
            "Object" === n && e1.constructor && (n = e1.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(e1);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rs(e1, t);
        }(e1)) || t && e1 && "number" == typeof e1.length) {
            n && (e1 = n);
            var r = 0, i = function() {};
            return {
                s: i,
                n: function() {
                    return r >= e1.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: e1[r++]
                    };
                },
                e: function(e1) {
                    throw e1;
                },
                f: i
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = !0, s = !1;
    return {
        s: function() {
            n = n.call(e1);
        },
        n: function() {
            var e1 = n.next();
            return a = e1.done, e1;
        },
        e: function(e1) {
            s = !0, o = e1;
        },
        f: function() {
            try {
                a || null == n.return || n.return();
            } finally{
                if (s) throw o;
            }
        }
    };
}
function rs(e1, t) {
    (null == t || t > e1.length) && (t = e1.length);
    for(var n = 0, r = new Array(t); n < t; n++)r[n] = e1[n];
    return r;
}
var is = new Map, os = null;
function as(e1) {
    cs() ? function(e1) {
        es.has(e1) || (es.set(e1, {}), navigator.mediaDevices.enumerateDevices().then(function(t) {
            es.has(e1) && (es.get(e1).lastDevicesString = JSON.stringify(t), ts || (ts = function() {
                var e1 = h(function*() {
                    var e1, t = yield navigator.mediaDevices.enumerateDevices(), n = Xa(es.keys());
                    try {
                        for(n.s(); !(e1 = n.n()).done;){
                            var r = e1.value, i = JSON.stringify(t);
                            i !== es.get(r).lastDevicesString && (es.get(r).lastDevicesString = i, r(t));
                        }
                    } catch (e1) {
                        n.e(e1);
                    } finally{
                        n.f();
                    }
                });
                return function() {
                    return e1.apply(this, arguments);
                };
            }(), navigator.mediaDevices.addEventListener("devicechange", ts)));
        }).catch(function() {}));
    }(e1) : function(e1) {
        is.has(e1) || (is.set(e1, {}), navigator.mediaDevices.enumerateDevices().then(function(t) {
            is.has(e1) && (is.get(e1).lastDevicesString = JSON.stringify(t), os || (os = setInterval(h(function*() {
                var e1, t = yield navigator.mediaDevices.enumerateDevices(), n = ns(is.keys());
                try {
                    for(n.s(); !(e1 = n.n()).done;){
                        var r = e1.value, i = JSON.stringify(t);
                        i !== is.get(r).lastDevicesString && (is.get(r).lastDevicesString = i, r(t));
                    }
                } catch (e1) {
                    n.e(e1);
                } finally{
                    n.f();
                }
            }), 3e3)));
        }));
    }(e1);
}
function ss(e1) {
    cs() ? function(e1) {
        es.has(e1) && (es.delete(e1), 0 === es.size && ts && (navigator.mediaDevices.removeEventListener("devicechange", ts), ts = null));
    }(e1) : function(e1) {
        is.has(e1) && (is.delete(e1), 0 === is.size && os && (clearInterval(os), os = null));
    }(e1);
}
function cs() {
    var e1;
    return na() || void 0 !== (null === (e1 = navigator.mediaDevices) || void 0 === e1 ? void 0 : e1.ondevicechange);
}
var ls = new Set;
function us(e1, t) {
    var n = t.isLocalScreenVideo;
    return e1 && "live" === e1.readyState && !function(e1, t) {
        return (!t.isLocalScreenVideo || "Chrome" !== pa()) && e1.muted && !ls.has(e1.id);
    }(e1, {
        isLocalScreenVideo: n
    });
}
var ds = [
    "result"
], ps = [
    "preserveIframe"
];
function hs(e1, t) {
    var n = Object.keys(e1);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(e1);
        t && (r = r.filter(function(t) {
            return Object.getOwnPropertyDescriptor(e1, t).enumerable;
        })), n.push.apply(n, r);
    }
    return n;
}
function fs(e1) {
    for(var t = 1; t < arguments.length; t++){
        var n = null != arguments[t] ? arguments[t] : {};
        t % 2 ? hs(Object(n), !0).forEach(function(t) {
            d(e1, t, n[t]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e1, Object.getOwnPropertyDescriptors(n)) : hs(Object(n)).forEach(function(t) {
            Object.defineProperty(e1, t, Object.getOwnPropertyDescriptor(n, t));
        });
    }
    return e1;
}
function vs(e1) {
    var t = function() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0;
        } catch (e1) {
            return !1;
        }
    }();
    return function() {
        var n, r = u(e1);
        if (t) {
            var i = u(this).constructor;
            n = Reflect.construct(r, arguments, i);
        } else n = r.apply(this, arguments);
        return l(this, n);
    };
}
function gs(e1, t) {
    var n = "undefined" != typeof Symbol && e1[Symbol.iterator] || e1["@@iterator"];
    if (!n) {
        if (Array.isArray(e1) || (n = function(e1, t) {
            if (!e1) return;
            if ("string" == typeof e1) return ms(e1, t);
            var n = Object.prototype.toString.call(e1).slice(8, -1);
            "Object" === n && e1.constructor && (n = e1.constructor.name);
            if ("Map" === n || "Set" === n) return Array.from(e1);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ms(e1, t);
        }(e1)) || t && e1 && "number" == typeof e1.length) {
            n && (e1 = n);
            var r = 0, i = function() {};
            return {
                s: i,
                n: function() {
                    return r >= e1.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: e1[r++]
                    };
                },
                e: function(e1) {
                    throw e1;
                },
                f: i
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = !0, s = !1;
    return {
        s: function() {
            n = n.call(e1);
        },
        n: function() {
            var e1 = n.next();
            return a = e1.done, e1;
        },
        e: function(e1) {
            s = !0, o = e1;
        },
        f: function() {
            try {
                a || null == n.return || n.return();
            } finally{
                if (s) throw o;
            }
        }
    };
}
function ms(e1, t) {
    (null == t || t > e1.length) && (t = e1.length);
    for(var n = 0, r = new Array(t); n < t; n++)r[n] = e1[n];
    return r;
}
var ys = {};
var _s = "video", bs = "voice", ws = na() ? {
    data: {}
} : {
    data: {},
    topology: "none"
}, ks = {
    present: 0,
    hidden: 0
}, Ss = {
    maxBitrate: {
        min: 1e5,
        max: 25e5
    },
    maxFramerate: {
        min: 1,
        max: 30
    },
    scaleResolutionDownBy: {
        min: 1,
        max: 8
    }
}, Ms = Object.keys(Ss), Cs = [
    "state",
    "volume",
    "simulcastEncodings"
], Es = {
    androidInCallNotification: {
        title: "string",
        subtitle: "string",
        iconName: "string",
        disableForCustomOverride: "boolean"
    },
    disableAutoDeviceManagement: {
        audio: "boolean",
        video: "boolean"
    }
}, Ts = {
    id: {
        iconPath: "string",
        iconPathDarkMode: "string",
        label: "string",
        tooltip: "string",
        visualState: "'default' | 'sidebar-open' | 'active'"
    }
}, Ps = {
    id: {
        allow: "string",
        controlledBy: "'*' | 'owners' | string[]",
        csp: "string",
        iconURL: "string",
        label: "string",
        loading: "'eager' | 'lazy'",
        location: "'main' | 'sidebar'",
        name: "string",
        referrerPolicy: "string",
        sandbox: "string",
        src: "string",
        srcdoc: "string",
        shared: "string[] | 'owners' | boolean"
    }
}, Os = {
    customIntegrations: {
        validate: Zs,
        help: Ks()
    },
    customTrayButtons: {
        validate: Xs,
        help: "customTrayButtons should be a dictionary of the type ".concat(JSON.stringify(Ts))
    },
    url: {
        validate: function(e1) {
            return "string" == typeof e1;
        },
        help: "url should be a string"
    },
    baseUrl: {
        validate: function(e1) {
            return "string" == typeof e1;
        },
        help: "baseUrl should be a string"
    },
    token: {
        validate: function(e1) {
            return "string" == typeof e1;
        },
        help: "token should be a string",
        queryString: "t"
    },
    dailyConfig: {
        validate: function(e1, t) {
            try {
                return t.validateDailyConfig(e1), !0;
            } catch (e1) {
                console.error("Failed to validate dailyConfig", e1);
            }
            return !1;
        },
        help: "Unsupported dailyConfig. Check error logs for detailed info."
    },
    reactNativeConfig: {
        validate: function(e1) {
            return ec(e1, Es);
        },
        help: "reactNativeConfig should look like ".concat(JSON.stringify(Es), ", all fields optional")
    },
    lang: {
        validate: function(e1) {
            return [
                "da",
                "de",
                "en-us",
                "en",
                "es",
                "fi",
                "fr",
                "it",
                "jp",
                "ka",
                "nl",
                "no",
                "pl",
                "pt",
                "pt-BR",
                "ru",
                "sv",
                "tr",
                "user"
            ].includes(e1);
        },
        help: "language not supported. Options are: da, de, en-us, en, es, fi, fr, it, jp, ka, nl, no, pl, pt, pt-BR, ru, sv, tr, user"
    },
    userName: !0,
    userData: {
        validate: function(e1) {
            try {
                return Js(e1), !0;
            } catch (e1) {
                return console.error(e1), !1;
            }
        },
        help: "invalid userData type provided"
    },
    startVideoOff: !0,
    startAudioOff: !0,
    allowLocalVideo: !0,
    allowLocalAudio: !0,
    activeSpeakerMode: !0,
    showLeaveButton: !0,
    showLocalVideo: !0,
    showParticipantsBar: !0,
    showFullscreenButton: !0,
    showUserNameChangeUI: !0,
    iframeStyle: !0,
    customLayout: !0,
    cssFile: !0,
    cssText: !0,
    bodyClass: !0,
    videoSource: {
        validate: function(e1, t) {
            if ("boolean" == typeof e1) return t._preloadCache.allowLocalVideo = e1, !0;
            var n;
            if (e1 instanceof MediaStreamTrack) t._sharedTracks.videoTrack = e1, n = {
                customTrack: Ho
            };
            else {
                if (delete t._sharedTracks.videoTrack, "string" != typeof e1) return console.error("videoSource must be a MediaStreamTrack, boolean, or a string"), !1;
                n = {
                    deviceId: e1
                };
            }
            return t._updatePreloadCacheInputSettings({
                video: {
                    settings: n
                }
            }, !1), !0;
        }
    },
    audioSource: {
        validate: function(e1, t) {
            if ("boolean" == typeof e1) return t._preloadCache.allowLocalAudio = e1, !0;
            var n;
            if (e1 instanceof MediaStreamTrack) t._sharedTracks.audioTrack = e1, n = {
                customTrack: Ho
            };
            else {
                if (delete t._sharedTracks.audioTrack, "string" != typeof e1) return console.error("audioSource must be a MediaStreamTrack, boolean, or a string"), !1;
                n = {
                    deviceId: e1
                };
            }
            return t._updatePreloadCacheInputSettings({
                audio: {
                    settings: n
                }
            }, !1), !0;
        }
    },
    subscribeToTracksAutomatically: {
        validate: function(e1, t) {
            return t._preloadCache.subscribeToTracksAutomatically = e1, !0;
        }
    },
    theme: {
        validate: function(e1) {
            var t = [
                "accent",
                "accentText",
                "background",
                "backgroundAccent",
                "baseText",
                "border",
                "mainAreaBg",
                "mainAreaBgAccent",
                "mainAreaText",
                "supportiveText"
            ], r = function(e1) {
                for(var n = 0, r = Object.keys(e1); n < r.length; n++){
                    var i = r[n];
                    if (!t.includes(i)) return console.error('unsupported color "'.concat(i, '". Valid colors: ').concat(t.join(", "))), !1;
                    if (!e1[i].match(/^#[0-9a-f]{6}|#[0-9a-f]{3}$/i)) return console.error("".concat(i, ' theme color should be provided in valid hex color format. Received: "').concat(e1[i], '"')), !1;
                }
                return !0;
            };
            return "object" === n(e1) && ("light" in e1 && "dark" in e1 || "colors" in e1) ? "light" in e1 && "dark" in e1 ? "colors" in e1.light ? "colors" in e1.dark ? r(e1.light.colors) && r(e1.dark.colors) : (console.error('Dark theme is missing "colors" property.', e1), !1) : (console.error('Light theme is missing "colors" property.', e1), !1) : r(e1.colors) : (console.error('Theme must contain either both "light" and "dark" properties, or "colors".', e1), !1);
        },
        help: "unsupported theme configuration. Check error logs for detailed info."
    },
    layoutConfig: {
        validate: function(e1) {
            if ("grid" in e1) {
                var t = e1.grid;
                if ("maxTilesPerPage" in t) {
                    if (!Number.isInteger(t.maxTilesPerPage)) return console.error("grid.maxTilesPerPage should be an integer. You passed ".concat(t.maxTilesPerPage, ".")), !1;
                    if (t.maxTilesPerPage > 49) return console.error("grid.maxTilesPerPage can't be larger than 49 without sacrificing browser performance. Please contact us at https://www.daily.co/contact to talk about your use case."), !1;
                }
                if ("minTilesPerPage" in t) {
                    if (!Number.isInteger(t.minTilesPerPage)) return console.error("grid.minTilesPerPage should be an integer. You passed ".concat(t.minTilesPerPage, ".")), !1;
                    if (t.minTilesPerPage < 1) return console.error("grid.minTilesPerPage can't be lower than 1."), !1;
                    if ("maxTilesPerPage" in t && t.minTilesPerPage > t.maxTilesPerPage) return console.error("grid.minTilesPerPage can't be higher than grid.maxTilesPerPage."), !1;
                }
            }
            return !0;
        },
        help: "unsupported layoutConfig. Check error logs for detailed info."
    },
    receiveSettings: {
        validate: function(e1) {
            return $s(e1, {
                allowAllParticipantsKey: !1
            });
        },
        help: Ys({
            allowAllParticipantsKey: !1
        })
    },
    sendSettings: {
        validate: function(e1, t) {
            return !!function(e1, t) {
                try {
                    return t.validateUpdateSendSettings(e1), !0;
                } catch (e1) {
                    return console.error("Failed to validate send settings", e1), !1;
                }
            }(e1, t) && (t._preloadCache.sendSettings = e1, !0);
        },
        help: "Invalid sendSettings provided. Check error logs for detailed info."
    },
    inputSettings: {
        validate: function(e1, t) {
            var n;
            return !!qs(e1) && (t._inputSettings || (t._inputSettings = {}), zs(e1, null === (n = t.properties) || void 0 === n ? void 0 : n.dailyConfig, t._sharedTracks), t._updatePreloadCacheInputSettings(e1, !0), !0);
        },
        help: Qs()
    },
    layout: {
        validate: function(e1) {
            return "custom-v1" === e1 || "browser" === e1 || "none" === e1;
        },
        help: 'layout may only be set to "custom-v1"',
        queryString: "layout"
    },
    emb: {
        queryString: "emb"
    },
    embHref: {
        queryString: "embHref"
    },
    dailyJsVersion: {
        queryString: "dailyJsVersion"
    },
    proxy: {
        queryString: "proxy"
    },
    strictMode: !0,
    allowMultipleCallInstances: !0
}, As = {
    styles: {
        validate: function(e1) {
            for(var t in e1)if ("cam" !== t && "screen" !== t) return !1;
            if (e1.cam) {
                for(var n in e1.cam)if ("div" !== n && "video" !== n) return !1;
            }
            if (e1.screen) {
                for(var r in e1.screen)if ("div" !== r && "video" !== r) return !1;
            }
            return !0;
        },
        help: "styles format should be a subset of: { cam: {div: {}, video: {}}, screen: {div: {}, video: {}} }"
    },
    setSubscribedTracks: {
        validate: function(e1, t) {
            if (t._preloadCache.subscribeToTracksAutomatically) return !1;
            var n = [
                !0,
                !1,
                "staged"
            ];
            if (n.includes(e1) || !na() && "avatar" === e1) return !0;
            var r = [
                "audio",
                "video",
                "screenAudio",
                "screenVideo",
                "rmpAudio",
                "rmpVideo"
            ];
            return function e1(t) {
                var i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                for(var o in t)if ("custom" === o) {
                    if (!n.includes(t[o]) && !e1(t[o], !0)) return !1;
                } else {
                    var a = !i && !r.includes(o), s = !n.includes(t[o]);
                    if (a || s) return !1;
                }
                return !0;
            }(e1);
        },
        help: "setSubscribedTracks cannot be used when setSubscribeToTracksAutomatically is enabled, and should be of the form: " + "true".concat(na() ? "" : " | 'avatar'", " | false | 'staged' | { [audio: true|false|'staged'], [video: true|false|'staged'], [screenAudio: true|false|'staged'], [screenVideo: true|false|'staged'] }")
    },
    setAudio: !0,
    setVideo: !0,
    setScreenShare: {
        validate: function(e1) {
            return !1 === e1;
        },
        help: "setScreenShare must be false, as it's only meant for stopping remote participants' screen shares"
    },
    eject: !0,
    updatePermissions: {
        validate: function(e1) {
            for(var t = 0, n = Object.entries(e1); t < n.length; t++){
                var r = v(n[t], 2), i = r[0], o = r[1];
                switch(i){
                    case "hasPresence":
                        if ("boolean" != typeof o) return !1;
                        break;
                    case "canSend":
                        if (o instanceof Set || o instanceof Array || Array.isArray(o)) {
                            var a, s = [
                                "video",
                                "audio",
                                "screenVideo",
                                "screenAudio",
                                "customVideo",
                                "customAudio"
                            ], c = gs(o);
                            try {
                                for(c.s(); !(a = c.n()).done;){
                                    var l = a.value;
                                    if (!s.includes(l)) return !1;
                                }
                            } catch (e1) {
                                c.e(e1);
                            } finally{
                                c.f();
                            }
                        } else if ("boolean" != typeof o) return !1;
                        (o instanceof Array || Array.isArray(o)) && (e1.canSend = new Set(o));
                        break;
                    case "canAdmin":
                        if (o instanceof Set || o instanceof Array || Array.isArray(o)) {
                            var u, d = [
                                "participants",
                                "streaming",
                                "transcription"
                            ], p = gs(o);
                            try {
                                for(p.s(); !(u = p.n()).done;){
                                    var h = u.value;
                                    if (!d.includes(h)) return !1;
                                }
                            } catch (e1) {
                                p.e(e1);
                            } finally{
                                p.f();
                            }
                        } else if ("boolean" != typeof o) return !1;
                        (o instanceof Array || Array.isArray(o)) && (e1.canAdmin = new Set(o));
                        break;
                    default:
                        return !1;
                }
            }
            return !0;
        },
        help: "updatePermissions can take hasPresence, canSend, and canAdmin permissions. hasPresence must be a boolean. canSend can be a boolean or an Array or Set of media types (video, audio, screenVideo, screenAudio, customVideo, customAudio). canAdmin can be a boolean or an Array or Set of admin types (participants, streaming, transcription)."
    }
};
Promise.any || (Promise.any = function() {
    var e1 = h(function*(e1) {
        return new Promise(function(t, n) {
            var r = [];
            e1.forEach(function(i) {
                return Promise.resolve(i).then(function(e1) {
                    t(e1);
                }).catch(function(t) {
                    r.push(t), r.length === e1.length && n(r);
                });
            });
        });
    });
    return function(t) {
        return e1.apply(this, arguments);
    };
}());
var js = function() {
    c(ee, m);
    var r, i, s, l, u, p, f, g, y, _, b, w, k, S, M, C, E, T, P, O, A, j, L, x, I, N, F, R, B, U, V, J, $, q, z, W, H, Y, Z = vs(ee);
    function ee(e1) {
        var n, r, i, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (t(this, ee), d(a(r = Z.call(this)), "startListeningForDeviceChanges", function() {
            as(r.handleDeviceChange);
        }), d(a(r), "stopListeningForDeviceChanges", function() {
            ss(r.handleDeviceChange);
        }), d(a(r), "handleDeviceChange", function(e1) {
            e1 = e1.map(function(e1) {
                return JSON.parse(JSON.stringify(e1));
            }), r.emitDailyJSEvent({
                action: "available-devices-updated",
                availableDevices: e1
            });
        }), d(a(r), "handleNativeAppStateChange", function() {
            var e1 = h(function*(e1) {
                if ("destroyed" === e1) return console.warn("App has been destroyed before leaving the meeting. Cleaning up all the resources!"), void (yield r.destroy());
                var t = "active" === e1;
                r.disableReactNativeAutoDeviceManagement("video") || (t ? r.camUnmutedBeforeLosingNativeActiveState && r.setLocalVideo(!0) : (r.camUnmutedBeforeLosingNativeActiveState = r.localVideo(), r.camUnmutedBeforeLosingNativeActiveState && r.setLocalVideo(!1)));
            });
            return function(t) {
                return e1.apply(this, arguments);
            };
        }()), d(a(r), "handleNativeAudioFocusChange", function(e1) {
            r.disableReactNativeAutoDeviceManagement("audio") || (r._hasNativeAudioFocus = e1, r.toggleParticipantAudioBasedOnNativeAudioFocus(), r._hasNativeAudioFocus ? r.micUnmutedBeforeLosingNativeAudioFocus && r.setLocalAudio(!0) : (r.micUnmutedBeforeLosingNativeAudioFocus = r.localAudio(), r.setLocalAudio(!1)));
        }), d(a(r), "handleNativeSystemScreenCaptureStop", function() {
            r.stopScreenShare();
        }), r.strictMode = void 0 === o.strictMode || o.strictMode, r.allowMultipleCallInstances = null !== (n = o.allowMultipleCallInstances) && void 0 !== n && n, Object.keys(ys).length && (r._logDuplicateInstanceAttempt(), !r.allowMultipleCallInstances)) {
            if (r.strictMode) throw new Error("Duplicate DailyIframe instances are not allowed");
            console.warn("Using strictMode: false to allow multiple call instances is now deprecated. Set `allowMultipleCallInstances: true`");
        }
        if (window._daily || (window._daily = {
            pendings: [],
            instances: {}
        }), r.callClientId = Q(), i = a(r), ys[i.callClientId] = i, window._daily.instances[r.callClientId] = {}, r._sharedTracks = {}, window._daily.instances[r.callClientId].tracks = r._sharedTracks, o.dailyJsVersion = ee.version(), r._iframe = e1, r._callObjectMode = "none" === o.layout && !r._iframe, r._preloadCache = {
            subscribeToTracksAutomatically: !0,
            outputDeviceId: null,
            inputSettings: null,
            sendSettings: null,
            videoTrackForNetworkConnectivityTest: null,
            videoTrackForConnectionQualityTest: null
        }, void 0 !== o.showLocalVideo ? r._callObjectMode ? console.error("showLocalVideo is not available in call object mode") : r._showLocalVideo = !!o.showLocalVideo : r._showLocalVideo = !0, void 0 !== o.showParticipantsBar ? r._callObjectMode ? console.error("showParticipantsBar is not available in call object mode") : r._showParticipantsBar = !!o.showParticipantsBar : r._showParticipantsBar = !0, void 0 !== o.customIntegrations ? r._callObjectMode ? console.error("customIntegrations is not available in call object mode") : r._customIntegrations = o.customIntegrations : r._customIntegrations = {}, void 0 !== o.customTrayButtons ? r._callObjectMode ? console.error("customTrayButtons is not available in call object mode") : r._customTrayButtons = o.customTrayButtons : r._customTrayButtons = {}, void 0 !== o.activeSpeakerMode ? r._callObjectMode ? console.error("activeSpeakerMode is not available in call object mode") : r._activeSpeakerMode = !!o.activeSpeakerMode : r._activeSpeakerMode = !1, o.receiveSettings ? r._callObjectMode ? r._receiveSettings = o.receiveSettings : console.error("receiveSettings is only available in call object mode") : r._receiveSettings = {}, r.validateProperties(o), r.properties = fs({}, o), r._inputSettings || (r._inputSettings = {}), r._callObjectLoader = r._callObjectMode ? new Da(r.callClientId) : null, r._callState = Zr, r._isPreparingToJoin = !1, r._accessState = {
            access: pi
        }, r._meetingSessionSummary = {}, r._finalSummaryOfPrevSession = {}, r._meetingSessionState = ic(ws, r._callObjectMode), r._nativeInCallAudioMode = _s, r._participants = {}, r._isScreenSharing = !1, r._participantCounts = ks, r._rmpPlayerState = {}, r._waitingParticipants = {}, r._network = {
            threshold: "good",
            quality: 100
        }, r._activeSpeaker = {}, r._localAudioLevel = 0, r._isLocalAudioLevelObserverRunning = !1, r._remoteParticipantsAudioLevel = {}, r._isRemoteParticipantsAudioLevelObserverRunning = !1, r._maxAppMessageSize = Vo, r._messageChannel = na() ? new Ea : new Sa, r._iframe && (r._iframe.requestFullscreen ? r._iframe.addEventListener("fullscreenchange", function() {
            document.fullscreenElement === r._iframe ? (r.emitDailyJSEvent({
                action: Ao
            }), r.sendMessageToCallMachine({
                action: Ao
            })) : (r.emitDailyJSEvent({
                action: jo
            }), r.sendMessageToCallMachine({
                action: jo
            }));
        }) : r._iframe.webkitRequestFullscreen && r._iframe.addEventListener("webkitfullscreenchange", function() {
            document.webkitFullscreenElement === r._iframe ? (r.emitDailyJSEvent({
                action: Ao
            }), r.sendMessageToCallMachine({
                action: Ao
            })) : (r.emitDailyJSEvent({
                action: jo
            }), r.sendMessageToCallMachine({
                action: jo
            }));
        })), na()) {
            var s = r.nativeUtils();
            s.addAudioFocusChangeListener && s.removeAudioFocusChangeListener && s.addAppStateChangeListener && s.removeAppStateChangeListener && s.addSystemScreenCaptureStopListener && s.removeSystemScreenCaptureStopListener || console.warn("expected (add|remove)(AudioFocusChange|AppActiveStateChange|SystemScreenCaptureStop)Listener to be available in React Native"), r._hasNativeAudioFocus = !0, s.addAudioFocusChangeListener(r.handleNativeAudioFocusChange), s.addAppStateChangeListener(r.handleNativeAppStateChange), s.addSystemScreenCaptureStopListener(r.handleNativeSystemScreenCaptureStop);
        }
        return r._callObjectMode && r.startListeningForDeviceChanges(), r._messageChannel.addListenerForMessagesFromCallMachine(r.handleMessageFromCallMachine, r.callClientId, a(r)), r;
    }
    return o(ee, [
        {
            key: "destroy",
            value: (Y = h(function*() {
                var e1, t;
                try {
                    yield this.leave();
                } catch (e1) {}
                var n = this._iframe;
                if (n) {
                    var r = n.parentElement;
                    r && r.removeChild(n);
                }
                if (this._messageChannel.removeListener(this.handleMessageFromCallMachine), na()) {
                    var i = this.nativeUtils();
                    i.removeAudioFocusChangeListener(this.handleNativeAudioFocusChange), i.removeAppStateChangeListener(this.handleNativeAppStateChange), i.removeSystemScreenCaptureStopListener(this.handleNativeSystemScreenCaptureStop);
                }
                this._callObjectMode && this.stopListeningForDeviceChanges(), this.resetMeetingDependentVars(), this._destroyed = !0, this.emitDailyJSEvent({
                    action: "call-instance-destroyed"
                }), delete ys[this.callClientId], (null === (e1 = window) || void 0 === e1 || null === (t = e1._daily) || void 0 === t ? void 0 : t.instances) && delete window._daily.instances[this.callClientId], this.strictMode && (this.callClientId = void 0);
            }), function() {
                return Y.apply(this, arguments);
            })
        },
        {
            key: "isDestroyed",
            value: function() {
                return !!this._destroyed;
            }
        },
        {
            key: "loadCss",
            value: function(e1) {
                var t = e1.bodyClass, n = e1.cssFile, r = e1.cssText;
                return Us(), this.sendMessageToCallMachine({
                    action: "load-css",
                    cssFile: this.absoluteUrl(n),
                    bodyClass: t,
                    cssText: r
                }), this;
            }
        },
        {
            key: "iframe",
            value: function() {
                return Us(), this._iframe;
            }
        },
        {
            key: "meetingState",
            value: function() {
                return this._callState;
            }
        },
        {
            key: "accessState",
            value: function() {
                return Rs(this._callObjectMode, "accessState()"), this._accessState;
            }
        },
        {
            key: "participants",
            value: function() {
                return this._participants;
            }
        },
        {
            key: "participantCounts",
            value: function() {
                return this._participantCounts;
            }
        },
        {
            key: "waitingParticipants",
            value: function() {
                return Rs(this._callObjectMode, "waitingParticipants()"), this._waitingParticipants;
            }
        },
        {
            key: "validateParticipantProperties",
            value: function(e1, t) {
                for(var n in t){
                    if (!As[n]) throw new Error("unrecognized updateParticipant property ".concat(n));
                    if (As[n].validate && !As[n].validate(t[n], this, this._participants[e1])) throw new Error(As[n].help);
                }
            }
        },
        {
            key: "updateParticipant",
            value: function(e1, t) {
                return this._participants.local && this._participants.local.session_id === e1 && (e1 = "local"), e1 && t && (this.validateParticipantProperties(e1, t), this.sendMessageToCallMachine({
                    action: "update-participant",
                    id: e1,
                    properties: t
                })), this;
            }
        },
        {
            key: "updateParticipants",
            value: function(e1) {
                var t = this._participants.local && this._participants.local.session_id;
                for(var n in e1)n === t && (n = "local"), n && e1[n] && this.validateParticipantProperties(n, e1[n]);
                return this.sendMessageToCallMachine({
                    action: "update-participants",
                    participants: e1
                }), this;
            }
        },
        {
            key: "updateWaitingParticipant",
            value: (H = h(function*() {
                var e1 = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (Rs(this._callObjectMode, "updateWaitingParticipant()"), xs(this._callState, "updateWaitingParticipant()"), "string" != typeof t || "object" !== n(r)) throw new Error("updateWaitingParticipant() must take an id string and a updates object");
                return new Promise(function(n, i) {
                    e1.sendMessageToCallMachine({
                        action: "daily-method-update-waiting-participant",
                        id: t,
                        updates: r
                    }, function(e1) {
                        e1.error && i(e1.error), e1.id || i(new Error("unknown error in updateWaitingParticipant()")), n({
                            id: e1.id
                        });
                    });
                });
            }), function() {
                return H.apply(this, arguments);
            })
        },
        {
            key: "updateWaitingParticipants",
            value: (W = h(function*() {
                var e1 = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                if (Rs(this._callObjectMode, "updateWaitingParticipants()"), xs(this._callState, "updateWaitingParticipants()"), "object" !== n(t)) throw new Error("updateWaitingParticipants() must take a mapping between ids and update objects");
                return new Promise(function(n, r) {
                    e1.sendMessageToCallMachine({
                        action: "daily-method-update-waiting-participants",
                        updatesById: t
                    }, function(e1) {
                        e1.error && r(e1.error), e1.ids || r(new Error("unknown error in updateWaitingParticipants()")), n({
                            ids: e1.ids
                        });
                    });
                });
            }), function() {
                return W.apply(this, arguments);
            })
        },
        {
            key: "requestAccess",
            value: (z = h(function*() {
                var e1 = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = t.access, r = void 0 === n ? {
                    level: hi
                } : n, i = t.name, o = void 0 === i ? "" : i;
                return Rs(this._callObjectMode, "requestAccess()"), xs(this._callState, "requestAccess()"), new Promise(function(t, n) {
                    e1.sendMessageToCallMachine({
                        action: "daily-method-request-access",
                        access: r,
                        name: o
                    }, function(e1) {
                        e1.error && n(e1.error), e1.access || n(new Error("unknown error in requestAccess()")), t({
                            access: e1.access,
                            granted: e1.granted
                        });
                    });
                });
            }), function() {
                return z.apply(this, arguments);
            })
        },
        {
            key: "localAudio",
            value: function() {
                return this._participants.local ? ![
                    "blocked",
                    "off"
                ].includes(this._participants.local.tracks.audio.state) : null;
            }
        },
        {
            key: "localVideo",
            value: function() {
                return this._participants.local ? ![
                    "blocked",
                    "off"
                ].includes(this._participants.local.tracks.video.state) : null;
            }
        },
        {
            key: "setLocalAudio",
            value: function(e1) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return "forceDiscardTrack" in t && (na() ? (console.warn("forceDiscardTrack option not supported in React Native; ignoring"), t = {}) : e1 && (console.warn("forceDiscardTrack option only supported when calling setLocalAudio(false); ignoring"), t = {})), this.sendMessageToCallMachine({
                    action: "local-audio",
                    state: e1,
                    options: t
                }), this;
            }
        },
        {
            key: "localScreenAudio",
            value: function() {
                return this._participants.local ? ![
                    "blocked",
                    "off"
                ].includes(this._participants.local.tracks.screenAudio.state) : null;
            }
        },
        {
            key: "localScreenVideo",
            value: function() {
                return this._participants.local ? ![
                    "blocked",
                    "off"
                ].includes(this._participants.local.tracks.screenVideo.state) : null;
            }
        },
        {
            key: "updateScreenShare",
            value: function(e1) {
                if (this._isScreenSharing) return this.sendMessageToCallMachine({
                    action: "local-screen-update",
                    options: e1
                }), this;
                console.warn("There is no screen share in progress. Try calling startScreenShare first.");
            }
        },
        {
            key: "setLocalVideo",
            value: function(e1) {
                return this.sendMessageToCallMachine({
                    action: "local-video",
                    state: e1
                }), this;
            }
        },
        {
            key: "_setAllowLocalAudio",
            value: function(e1) {
                if (this._preloadCache.allowLocalAudio = e1, this._callMachineInitialized) return this.sendMessageToCallMachine({
                    action: "set-allow-local-audio",
                    state: e1
                }), this;
            }
        },
        {
            key: "_setAllowLocalVideo",
            value: function(e1) {
                if (this._preloadCache.allowLocalVideo = e1, this._callMachineInitialized) return this.sendMessageToCallMachine({
                    action: "set-allow-local-video",
                    state: e1
                }), this;
            }
        },
        {
            key: "getReceiveSettings",
            value: (q = h(function*(e1) {
                var t = this, r = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).showInheritedValues, i = void 0 !== r && r;
                if (Rs(this._callObjectMode, "getReceiveSettings()"), !this._callMachineInitialized) return this._receiveSettings;
                switch(n(e1)){
                    case "string":
                        return new Promise(function(n) {
                            t.sendMessageToCallMachine({
                                action: "get-single-participant-receive-settings",
                                id: e1,
                                showInheritedValues: i
                            }, function(e1) {
                                n(e1.receiveSettings);
                            });
                        });
                    case "undefined":
                        return this._receiveSettings;
                    default:
                        throw new Error('first argument to getReceiveSettings() must be a participant id (or "base"), or there should be no arguments');
                }
            }), function(e1) {
                return q.apply(this, arguments);
            })
        },
        {
            key: "updateReceiveSettings",
            value: ($ = h(function*(e1) {
                var t = this;
                if (Rs(this._callObjectMode, "updateReceiveSettings()"), !$s(e1, {
                    allowAllParticipantsKey: !0
                })) throw new Error(Ys({
                    allowAllParticipantsKey: !0
                }));
                return xs(this._callState, "updateReceiveSettings()", "To specify receive settings earlier, use the receiveSettings config property."), new Promise(function(n) {
                    t.sendMessageToCallMachine({
                        action: "update-receive-settings",
                        receiveSettings: e1
                    }, function(e1) {
                        n({
                            receiveSettings: e1.receiveSettings
                        });
                    });
                });
            }), function(e1) {
                return $.apply(this, arguments);
            })
        },
        {
            key: "_prepInputSettingsForSharing",
            value: function(e1, t) {
                if (e1) {
                    var n = {};
                    if (e1.audio) {
                        var r, i, o, a;
                        e1.audio.settings && (!Object.keys(e1.audio.settings).length && t || (n.audio = {
                            settings: fs({}, e1.audio.settings)
                        })), t && null !== (r = n.audio) && void 0 !== r && null !== (i = r.settings) && void 0 !== i && i.customTrack && (n.audio.settings = {
                            customTrack: this._sharedTracks.audioTrack
                        });
                        var s = "none" === (null === (o = e1.audio.processor) || void 0 === o ? void 0 : o.type) && (null === (a = e1.audio.processor) || void 0 === a ? void 0 : a._isDefaultWhenNone);
                        if (e1.audio.processor && !s) {
                            var c = fs({}, e1.audio.processor);
                            delete c._isDefaultWhenNone, n.audio = fs(fs({}, n.audio), {}, {
                                processor: c
                            });
                        }
                    }
                    if (e1.video) {
                        var l, u, d, p;
                        e1.video.settings && (!Object.keys(e1.video.settings).length && t || (n.video = {
                            settings: fs({}, e1.video.settings)
                        })), t && null !== (l = n.video) && void 0 !== l && null !== (u = l.settings) && void 0 !== u && u.customTrack && (n.video.settings = {
                            customTrack: this._sharedTracks.videoTrack
                        });
                        var h = "none" === (null === (d = e1.video.processor) || void 0 === d ? void 0 : d.type) && (null === (p = e1.video.processor) || void 0 === p ? void 0 : p._isDefaultWhenNone);
                        if (e1.video.processor && !h) {
                            var f = fs({}, e1.video.processor);
                            delete f._isDefaultWhenNone, n.video = fs(fs({}, n.video), {}, {
                                processor: f
                            });
                        }
                    }
                    return n;
                }
            }
        },
        {
            key: "getInputSettings",
            value: function() {
                var e1 = this;
                return Us(), new Promise(function(t) {
                    t(e1._getInputSettings());
                });
            }
        },
        {
            key: "_getInputSettings",
            value: function() {
                var e1, t, n, r, i, o, a, s, c = {
                    processor: {
                        type: "none",
                        _isDefaultWhenNone: !0
                    }
                };
                this._inputSettings ? (e1 = (null === (n = this._inputSettings) || void 0 === n ? void 0 : n.video) || c, t = (null === (r = this._inputSettings) || void 0 === r ? void 0 : r.audio) || c) : (e1 = (null === (i = this._preloadCache) || void 0 === i || null === (o = i.inputSettings) || void 0 === o ? void 0 : o.video) || c, t = (null === (a = this._preloadCache) || void 0 === a || null === (s = a.inputSettings) || void 0 === s ? void 0 : s.audio) || c);
                var l = {
                    audio: t,
                    video: e1
                };
                return this._prepInputSettingsForSharing(l, !0);
            }
        },
        {
            key: "_updatePreloadCacheInputSettings",
            value: function(e1, t) {
                var n = this._inputSettings || {}, r = {};
                if (e1.video) {
                    var i, o, a;
                    if (r.video = {}, e1.video.settings) r.video.settings = {}, t || e1.video.settings.customTrack || null === (a = n.video) || void 0 === a || !a.settings ? r.video.settings = e1.video.settings : r.video.settings = fs(fs({}, n.video.settings), e1.video.settings), Object.keys(r.video.settings).length || delete r.video.settings;
                    else null !== (i = n.video) && void 0 !== i && i.settings && (r.video.settings = n.video.settings);
                    e1.video.processor ? r.video.processor = e1.video.processor : null !== (o = n.video) && void 0 !== o && o.processor && (r.video.processor = n.video.processor);
                } else n.video && (r.video = n.video);
                if (e1.audio) {
                    var s, c, l;
                    if (r.audio = {}, e1.audio.settings) r.audio.settings = {}, t || e1.audio.settings.customTrack || null === (l = n.audio) || void 0 === l || !l.settings ? r.audio.settings = e1.audio.settings : r.audio.settings = fs(fs({}, n.audio.settings), e1.audio.settings), Object.keys(r.audio.settings).length || delete r.audio.settings;
                    else null !== (s = n.audio) && void 0 !== s && s.settings && (r.audio.settings = n.audio.settings);
                    e1.audio.processor ? r.audio.processor = e1.audio.processor : null !== (c = n.audio) && void 0 !== c && c.processor && (r.audio.processor = n.audio.processor);
                } else n.audio && (r.audio = n.audio);
                this._maybeUpdateInputSettings(r);
            }
        },
        {
            key: "_devicesFromInputSettings",
            value: function(e1) {
                var t, n, r, i, o = (null == e1 || null === (t = e1.video) || void 0 === t || null === (n = t.settings) || void 0 === n ? void 0 : n.deviceId) || null, a = (null == e1 || null === (r = e1.audio) || void 0 === r || null === (i = r.settings) || void 0 === i ? void 0 : i.deviceId) || null, s = this._preloadCache.outputDeviceId || null;
                return {
                    camera: o ? {
                        deviceId: o
                    } : {},
                    mic: a ? {
                        deviceId: a
                    } : {},
                    speaker: s ? {
                        deviceId: s
                    } : {}
                };
            }
        },
        {
            key: "updateInputSettings",
            value: (J = h(function*(e1) {
                var t = this;
                return Us(), qs(e1) ? e1.video || e1.audio ? (zs(e1, this.properties.dailyConfig, this._sharedTracks), this._callObjectMode && !this._callMachineInitialized ? (this._updatePreloadCacheInputSettings(e1, !0), this._getInputSettings()) : new Promise(function(n, r) {
                    t.sendMessageToCallMachine({
                        action: "update-input-settings",
                        inputSettings: e1
                    }, function(i) {
                        if (i.error) r(i.error);
                        else {
                            if (i.returnPreloadCache) return t._updatePreloadCacheInputSettings(e1, !0), void n(t._getInputSettings());
                            t._maybeUpdateInputSettings(i.inputSettings), n(t._prepInputSettingsForSharing(i.inputSettings, !0));
                        }
                    });
                })) : this._getInputSettings() : (console.error(Qs()), Promise.reject(Qs()));
            }), function(e1) {
                return J.apply(this, arguments);
            })
        },
        {
            key: "setBandwidth",
            value: function(e1) {
                var t = e1.kbs, n = e1.trackConstraints;
                if (Us(), this._callMachineInitialized) return this.sendMessageToCallMachine({
                    action: "set-bandwidth",
                    kbs: t,
                    trackConstraints: n
                }), this;
            }
        },
        {
            key: "getDailyLang",
            value: function() {
                var e1 = this;
                if (Us(), this._callMachineInitialized) return new Promise(function(t) {
                    e1.sendMessageToCallMachine({
                        action: "get-daily-lang"
                    }, function(e1) {
                        delete e1.action, delete e1.callbackStamp, t(e1);
                    });
                });
            }
        },
        {
            key: "setDailyLang",
            value: function(e1) {
                return Us(), this.sendMessageToCallMachine({
                    action: "set-daily-lang",
                    lang: e1
                }), this;
            }
        },
        {
            key: "setProxyUrl",
            value: function(e1) {
                return this.sendMessageToCallMachine({
                    action: "set-proxy-url",
                    proxyUrl: e1
                }), this;
            }
        },
        {
            key: "setIceConfig",
            value: function(e1) {
                return this.sendMessageToCallMachine({
                    action: "set-ice-config",
                    iceConfig: e1
                }), this;
            }
        },
        {
            key: "meetingSessionSummary",
            value: function() {
                return [
                    ii,
                    oi
                ].includes(this._callState) ? this._finalSummaryOfPrevSession : this._meetingSessionSummary;
            }
        },
        {
            key: "getMeetingSession",
            value: (V = h(function*() {
                var e1 = this;
                return console.warn("getMeetingSession() is deprecated: use meetingSessionSummary(), which will return immediately"), xs(this._callState, "getMeetingSession()"), new Promise(function(t) {
                    e1.sendMessageToCallMachine({
                        action: "get-meeting-session"
                    }, function(e1) {
                        delete e1.action, delete e1.callbackStamp, t(e1);
                    });
                });
            }), function() {
                return V.apply(this, arguments);
            })
        },
        {
            key: "meetingSessionState",
            value: function() {
                return xs(this._callState, "meetingSessionState"), this._meetingSessionState;
            }
        },
        {
            key: "setMeetingSessionData",
            value: function(e1) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "replace";
                Rs(this._callObjectMode, "setMeetingSessionData()"), xs(this._callState, "setMeetingSessionData");
                try {
                    !function(e1, t) {
                        new Aa({
                            data: e1,
                            mergeStrategy: t
                        });
                    }(e1, t);
                } catch (e1) {
                    throw console.error(e1), e1;
                }
                try {
                    this.sendMessageToCallMachine({
                        action: "set-session-data",
                        data: e1,
                        mergeStrategy: t
                    });
                } catch (e1) {
                    throw new Error("Error setting meeting session data: ".concat(e1));
                }
            }
        },
        {
            key: "setUserName",
            value: function(e1, t) {
                var n = this;
                return this.properties.userName = e1, new Promise(function(r) {
                    n.sendMessageToCallMachine({
                        action: "set-user-name",
                        name: null != e1 ? e1 : "",
                        thisMeetingOnly: na() || !!t && !!t.thisMeetingOnly
                    }, function(e1) {
                        delete e1.action, delete e1.callbackStamp, r(e1);
                    });
                });
            }
        },
        {
            key: "setUserData",
            value: (U = h(function*(e1) {
                var t = this;
                try {
                    Js(e1);
                } catch (e1) {
                    throw console.error(e1), e1;
                }
                if (this.properties.userData = e1, this._callMachineInitialized) return new Promise(function(n) {
                    try {
                        t.sendMessageToCallMachine({
                            action: "set-user-data",
                            userData: e1
                        }, function(e1) {
                            delete e1.action, delete e1.callbackStamp, n(e1);
                        });
                    } catch (e1) {
                        throw new Error("Error setting user data: ".concat(e1));
                    }
                });
            }), function(e1) {
                return U.apply(this, arguments);
            })
        },
        {
            key: "validateAudioLevelInterval",
            value: function(e1) {
                if (e1 && (e1 < 100 || "number" != typeof e1)) throw new Error("The interval must be a number greater than or equal to 100 milliseconds.");
            }
        },
        {
            key: "startLocalAudioLevelObserver",
            value: function(e1) {
                var t = this;
                if ("undefined" == typeof AudioWorkletNode && !na()) throw new Error("startLocalAudioLevelObserver() is not supported on this browser");
                if (this.validateAudioLevelInterval(e1), this._callMachineInitialized) return this._isLocalAudioLevelObserverRunning = !0, new Promise(function(n, r) {
                    t.sendMessageToCallMachine({
                        action: "start-local-audio-level-observer",
                        interval: e1
                    }, function(e1) {
                        t._isLocalAudioLevelObserverRunning = !e1.error, e1.error ? r({
                            error: e1.error
                        }) : n();
                    });
                });
                this._preloadCache.localAudioLevelObserver = {
                    enabled: !0,
                    interval: e1
                };
            }
        },
        {
            key: "isLocalAudioLevelObserverRunning",
            value: function() {
                return this._isLocalAudioLevelObserverRunning;
            }
        },
        {
            key: "stopLocalAudioLevelObserver",
            value: function() {
                this._preloadCache.localAudioLevelObserver = null, this._localAudioLevel = 0, this._isLocalAudioLevelObserverRunning = !1, this.sendMessageToCallMachine({
                    action: "stop-local-audio-level-observer"
                });
            }
        },
        {
            key: "startRemoteParticipantsAudioLevelObserver",
            value: function(e1) {
                var t = this;
                if (this.validateAudioLevelInterval(e1), this._callMachineInitialized) return this._isRemoteParticipantsAudioLevelObserverRunning = !0, new Promise(function(n, r) {
                    t.sendMessageToCallMachine({
                        action: "start-remote-participants-audio-level-observer",
                        interval: e1
                    }, function(e1) {
                        t._isRemoteParticipantsAudioLevelObserverRunning = !e1.error, e1.error ? r({
                            error: e1.error
                        }) : n();
                    });
                });
                this._preloadCache.remoteParticipantsAudioLevelObserver = {
                    enabled: !0,
                    interval: e1
                };
            }
        },
        {
            key: "isRemoteParticipantsAudioLevelObserverRunning",
            value: function() {
                return this._isRemoteParticipantsAudioLevelObserverRunning;
            }
        },
        {
            key: "stopRemoteParticipantsAudioLevelObserver",
            value: function() {
                this._preloadCache.remoteParticipantsAudioLevelObserver = null, this._remoteParticipantsAudioLevel = {}, this._isRemoteParticipantsAudioLevelObserverRunning = !1, this.sendMessageToCallMachine({
                    action: "stop-remote-participants-audio-level-observer"
                });
            }
        },
        {
            key: "startCamera",
            value: (B = h(function*() {
                var e1 = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                if (Rs(this._callObjectMode, "startCamera()"), Ds(this._callState, this._isPreparingToJoin, "startCamera()", "Did you mean to use setLocalAudio() and/or setLocalVideo() instead?"), this.needsLoad()) try {
                    yield this.load(t);
                } catch (e1) {
                    return Promise.reject(e1);
                }
                else {
                    if (this._didPreAuth) {
                        if (t.url && t.url !== this.properties.url) return console.error("url in startCamera() is different than the one used in preAuth()"), Promise.reject();
                        if (t.token && t.token !== this.properties.token) return console.error("token in startCamera() is different than the one used in preAuth()"), Promise.reject();
                    }
                    this.validateProperties(t), this.properties = fs(fs({}, this.properties), t);
                }
                return new Promise(function(t) {
                    e1._preloadCache.inputSettings = e1._prepInputSettingsForSharing(e1._inputSettings, !1), e1.sendMessageToCallMachine({
                        action: "start-camera",
                        properties: Ls(e1.properties, e1.callClientId),
                        preloadCache: Ls(e1._preloadCache, e1.callClientId)
                    }, function(e1) {
                        t({
                            camera: e1.camera,
                            mic: e1.mic,
                            speaker: e1.speaker
                        });
                    });
                });
            }), function() {
                return B.apply(this, arguments);
            })
        },
        {
            key: "validateCustomTrack",
            value: function(e1, t, n) {
                if (n && n.length > 50) throw new Error("Custom track `trackName` must not be more than 50 characters");
                if (t && "music" !== t && "speech" !== t && !(t instanceof Object)) throw new Error("Custom track `mode` must be either `music` | `speech` | `DailyMicAudioModeSettings` or `undefined`");
                if (!!n && [
                    "cam-audio",
                    "cam-video",
                    "screen-video",
                    "screen-audio",
                    "rmpAudio",
                    "rmpVideo",
                    "customVideoDefaults"
                ].includes(n)) throw new Error("Custom track `trackName` must not match a track name already used by daily: cam-audio, cam-video, customVideoDefaults, screen-video, screen-audio, rmpAudio, rmpVideo");
                if (!(e1 instanceof MediaStreamTrack)) throw new Error("Custom tracks provided must be instances of MediaStreamTrack");
            }
        },
        {
            key: "startCustomTrack",
            value: function() {
                var e1 = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                    track: track,
                    mode: mode,
                    trackName: trackName
                };
                return Us(), xs(this._callState, "startCustomTrack()"), this.validateCustomTrack(t.track, t.mode, t.trackName), new Promise(function(n, r) {
                    e1._sharedTracks.customTrack = t.track, t.track = Ho, e1.sendMessageToCallMachine({
                        action: "start-custom-track",
                        properties: t
                    }, function(e1) {
                        e1.error ? r({
                            error: e1.error
                        }) : n(e1.mediaTag);
                    });
                });
            }
        },
        {
            key: "stopCustomTrack",
            value: function(e1) {
                var t = this;
                return Us(), xs(this._callState, "stopCustomTrack()"), new Promise(function(n) {
                    t.sendMessageToCallMachine({
                        action: "stop-custom-track",
                        mediaTag: e1
                    }, function(e1) {
                        n(e1.mediaTag);
                    });
                });
            }
        },
        {
            key: "setCamera",
            value: function(e1) {
                var t = this;
                return Vs(), Ns(this._callMachineInitialized, "setCamera()"), new Promise(function(n) {
                    t.sendMessageToCallMachine({
                        action: "set-camera",
                        cameraDeviceId: e1
                    }, function(e1) {
                        n({
                            device: e1.device
                        });
                    });
                });
            }
        },
        {
            key: "setAudioDevice",
            value: (R = h(function*(e1) {
                return Vs(), this.nativeUtils().setAudioDevice(e1), {
                    deviceId: yield this.nativeUtils().getAudioDevice()
                };
            }), function(e1) {
                return R.apply(this, arguments);
            })
        },
        {
            key: "cycleCamera",
            value: function() {
                var e1 = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return new Promise(function(n) {
                    e1.sendMessageToCallMachine({
                        action: "cycle-camera",
                        properties: t
                    }, function(e1) {
                        n({
                            device: e1.device
                        });
                    });
                });
            }
        },
        {
            key: "cycleMic",
            value: function() {
                var e1 = this;
                return Us(), new Promise(function(t) {
                    e1.sendMessageToCallMachine({
                        action: "cycle-mic"
                    }, function(e1) {
                        t({
                            device: e1.device
                        });
                    });
                });
            }
        },
        {
            key: "getCameraFacingMode",
            value: function() {
                var e1 = this;
                return Vs(), new Promise(function(t) {
                    e1.sendMessageToCallMachine({
                        action: "get-camera-facing-mode"
                    }, function(e1) {
                        t(e1.facingMode);
                    });
                });
            }
        },
        {
            key: "setInputDevicesAsync",
            value: (F = h(function*(e1) {
                var t = this, n = e1.audioDeviceId, r = e1.videoDeviceId, i = e1.audioSource, o = e1.videoSource;
                if (Us(), void 0 !== i && (n = i), void 0 !== o && (r = o), "boolean" == typeof n && (this._setAllowLocalAudio(n), n = void 0), "boolean" == typeof r && (this._setAllowLocalVideo(r), r = void 0), !n && !r) return yield this.getInputDevices();
                var a = {};
                return n && (n instanceof MediaStreamTrack ? (this._sharedTracks.audioTrack = n, n = Ho, a.audio = {
                    settings: {
                        customTrack: n
                    }
                }) : (delete this._sharedTracks.audioTrack, a.audio = {
                    settings: {
                        deviceId: n
                    }
                })), r && (r instanceof MediaStreamTrack ? (this._sharedTracks.videoTrack = r, r = Ho, a.video = {
                    settings: {
                        customTrack: r
                    }
                }) : (delete this._sharedTracks.videoTrack, a.video = {
                    settings: {
                        deviceId: r
                    }
                })), this._callObjectMode && this.needsLoad() ? (this._updatePreloadCacheInputSettings(a, !1), this._devicesFromInputSettings(this._inputSettings)) : new Promise(function(e1) {
                    t.sendMessageToCallMachine({
                        action: "set-input-devices",
                        audioDeviceId: n,
                        videoDeviceId: r
                    }, function(n) {
                        if (delete n.action, delete n.callbackStamp, n.returnPreloadCache) return t._updatePreloadCacheInputSettings(a, !1), void e1(t._devicesFromInputSettings(t._inputSettings));
                        e1(n);
                    });
                });
            }), function(e1) {
                return F.apply(this, arguments);
            })
        },
        {
            key: "setOutputDeviceAsync",
            value: (N = h(function*(e1) {
                var t = this, n = e1.outputDeviceId;
                return Us(), n && (this._preloadCache.outputDeviceId = n), this._callObjectMode && this.needsLoad() ? this._devicesFromInputSettings(this._inputSettings) : new Promise(function(e1) {
                    t.sendMessageToCallMachine({
                        action: "set-output-device",
                        outputDeviceId: n
                    }, function(n) {
                        delete n.action, delete n.callbackStamp, n.returnPreloadCache ? e1(t._devicesFromInputSettings(t._inputSettings)) : e1(n);
                    });
                });
            }), function(e1) {
                return N.apply(this, arguments);
            })
        },
        {
            key: "getInputDevices",
            value: (I = h(function*() {
                var e1 = this;
                return this._callObjectMode && this.needsLoad() ? this._devicesFromInputSettings(this._inputSettings) : new Promise(function(t) {
                    e1.sendMessageToCallMachine({
                        action: "get-input-devices"
                    }, function(n) {
                        n.returnPreloadCache ? t(e1._devicesFromInputSettings(e1._inputSettings)) : t({
                            camera: n.camera,
                            mic: n.mic,
                            speaker: n.speaker
                        });
                    });
                });
            }), function() {
                return I.apply(this, arguments);
            })
        },
        {
            key: "nativeInCallAudioMode",
            value: function() {
                return Vs(), this._nativeInCallAudioMode;
            }
        },
        {
            key: "setNativeInCallAudioMode",
            value: function(e1) {
                if (Vs(), [
                    _s,
                    bs
                ].includes(e1)) {
                    if (e1 !== this._nativeInCallAudioMode) return this._nativeInCallAudioMode = e1, !this.disableReactNativeAutoDeviceManagement("audio") && Is(this._callState, this._isPreparingToJoin) && this.nativeUtils().setAudioMode(this._nativeInCallAudioMode), this;
                } else console.error("invalid in-call audio mode specified: ", e1);
            }
        },
        {
            key: "preAuth",
            value: (x = h(function*() {
                var e1 = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                if (Rs(this._callObjectMode, "preAuth()"), Ds(this._callState, this._isPreparingToJoin, "preAuth()"), this.needsLoad() && (yield this.load(t)), !t.url) throw new Error("preAuth() requires at least a url to be provided");
                return this.validateProperties(t), this.properties = fs(fs({}, this.properties), t), new Promise(function(t, n) {
                    e1._preloadCache.inputSettings = e1._prepInputSettingsForSharing(e1._inputSettings, !1), e1.sendMessageToCallMachine({
                        action: "daily-method-preauth",
                        properties: Ls(e1.properties, e1.callClientId),
                        preloadCache: Ls(e1._preloadCache, e1.callClientId)
                    }, function(r) {
                        return r.error ? n(r.error) : r.access ? (e1._didPreAuth = !0, void t({
                            access: r.access
                        })) : n(new Error("unknown error in preAuth()"));
                    });
                });
            }), function() {
                return x.apply(this, arguments);
            })
        },
        {
            key: "load",
            value: (L = h(function*(e1) {
                var t = this;
                if (this.needsLoad()) {
                    if (this._destroyed && (this._logUseAfterDestroy(), this.strictMode)) throw new Error("Use after destroy");
                    if (e1 && (this.validateProperties(e1), this.properties = fs(fs({}, this.properties), e1)), !this._callObjectMode && !this.properties.url) throw new Error("can't load iframe meeting because url property isn't set");
                    return this._updateCallState(ei), this.emitDailyJSEvent({
                        action: Bi
                    }), this._callObjectMode ? new Promise(function(e1, n) {
                        t._callObjectLoader.cancel();
                        var r = Date.now();
                        t._callObjectLoader.load(t.properties.dailyConfig, function(n) {
                            t._bundleLoadTime = n ? "no-op" : Date.now() - r, t._updateCallState(ti), n && t.emitDailyJSEvent({
                                action: Vi
                            }), e1();
                        }, function(e1, r) {
                            if (t.emitDailyJSEvent({
                                action: Ui
                            }), !r) {
                                t._updateCallState(oi), t.resetMeetingDependentVars();
                                var i = {
                                    action: Uo,
                                    errorMsg: e1.msg,
                                    error: {
                                        type: "connection-error",
                                        msg: "Failed to load call object bundle.",
                                        details: {
                                            on: "load",
                                            sourceError: e1,
                                            bundleUrl: X(t.properties.dailyConfig)
                                        }
                                    }
                                };
                                t._maybeSendToSentry(i), t.emitDailyJSEvent(i), n(e1.msg);
                            }
                        });
                    }) : (this._iframe.src = K(this.assembleMeetingUrl(), this.properties.dailyConfig), new Promise(function(e1, n) {
                        t._loadedCallback = function(r) {
                            t._callState !== oi ? (t._updateCallState(ti), (t.properties.cssFile || t.properties.cssText) && t.loadCss(t.properties), e1()) : n(r);
                        };
                    }));
                }
            }), function(e1) {
                return L.apply(this, arguments);
            })
        },
        {
            key: "join",
            value: (j = h(function*() {
                var e1 = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                this._testCallInProgress && this.stopTestCallQuality();
                var n = !1;
                if (this.needsLoad()) {
                    this.updateIsPreparingToJoin(!0);
                    try {
                        yield this.load(t);
                    } catch (e1) {
                        return this.updateIsPreparingToJoin(!1), Promise.reject(e1);
                    }
                } else {
                    if (n = !(!this.properties.cssFile && !this.properties.cssText), this._didPreAuth) {
                        if (t.url && t.url !== this.properties.url) return console.error("url in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(!1), Promise.reject();
                        if (t.token && t.token !== this.properties.token) return console.error("token in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(!1), Promise.reject();
                    }
                    if (t.url && !this._callObjectMode && t.url && t.url !== this.properties.url) return console.error("url in join() is different than the one used in load() (".concat(this.properties.url, " -> ").concat(t.url, ")")), this.updateIsPreparingToJoin(!1), Promise.reject();
                    this.validateProperties(t), this.properties = fs(fs({}, this.properties), t);
                }
                return void 0 !== t.showLocalVideo && (this._callObjectMode ? console.error("showLocalVideo is not available in callObject mode") : this._showLocalVideo = !!t.showLocalVideo), void 0 !== t.showParticipantsBar && (this._callObjectMode ? console.error("showParticipantsBar is not available in callObject mode") : this._showParticipantsBar = !!t.showParticipantsBar), this._callState === ri || this._callState === ni ? (console.warn("already joined meeting, call leave() before joining again"), void this.updateIsPreparingToJoin(!1)) : (this._updateCallState(ni, !1), this.emitDailyJSEvent({
                    action: qi
                }), this._preloadCache.inputSettings = this._prepInputSettingsForSharing(this._inputSettings || {}, !1), this.sendMessageToCallMachine({
                    action: "join-meeting",
                    properties: Ls(this.properties, this.callClientId),
                    preloadCache: Ls(this._preloadCache, this.callClientId)
                }), new Promise(function(t, r) {
                    e1._joinedCallback = function(i, o) {
                        if (e1._callState !== oi) {
                            if (e1._updateCallState(ri), i) for(var a in i){
                                if (e1._callObjectMode) {
                                    var s = e1._callMachine().store;
                                    Ga(i[a], s), Qa(i[a], s), Ka(i[a], e1._participants[a], s);
                                }
                                e1._participants[a] = fs({}, i[a]), e1.toggleParticipantAudioBasedOnNativeAudioFocus();
                            }
                            n && e1.loadCss(e1.properties), t(i);
                        } else r(o);
                    };
                }));
            }), function() {
                return j.apply(this, arguments);
            })
        },
        {
            key: "leave",
            value: (A = h(function*() {
                var e1 = this;
                return this._testCallInProgress && this.stopTestCallQuality(), new Promise(function(t) {
                    e1._callState === ii || e1._callState === oi ? t() : e1._callObjectLoader && !e1._callObjectLoader.loaded ? (e1._callObjectLoader.cancel(), e1._updateCallState(ii), e1.resetMeetingDependentVars(), e1.emitDailyJSEvent({
                        action: ii
                    }), t()) : (e1._resolveLeave = t, e1.sendMessageToCallMachine({
                        action: "leave-meeting"
                    }));
                });
            }), function() {
                return A.apply(this, arguments);
            })
        },
        {
            key: "startScreenShare",
            value: (O = h(function*() {
                var e1 = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                if (Ns(this._callMachineInitialized, "startScreenShare()"), t.screenVideoSendSettings && this._validateVideoSendSettings("screenVideo", t.screenVideoSendSettings), t.mediaStream && (this._sharedTracks.screenMediaStream = t.mediaStream, t.mediaStream = Ho), "undefined" != typeof DailyNativeUtils && void 0 !== DailyNativeUtils.isIOS && DailyNativeUtils.isIOS) {
                    var n = this.nativeUtils();
                    if (yield n.isScreenBeingCaptured()) return void this.emitDailyJSEvent({
                        action: Bo,
                        type: "screen-share-error",
                        errorMsg: "Could not start the screen sharing. The screen is already been captured!"
                    });
                    n.setSystemScreenCaptureStartCallback(function() {
                        n.setSystemScreenCaptureStartCallback(null), e1.sendMessageToCallMachine({
                            action: qo,
                            captureOptions: t
                        });
                    }), n.presentSystemScreenCapturePrompt();
                } else this.sendMessageToCallMachine({
                    action: qo,
                    captureOptions: t
                });
            }), function() {
                return O.apply(this, arguments);
            })
        },
        {
            key: "stopScreenShare",
            value: function() {
                Ns(this._callMachineInitialized, "stopScreenShare()"), this.sendMessageToCallMachine({
                    action: "local-screen-stop"
                });
            }
        },
        {
            key: "startRecording",
            value: function() {
                var e1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = e1.type;
                if (t && "cloud" !== t && "raw-tracks" !== t && "local" !== t) throw new Error("invalid type: ".concat(t, ", allowed values 'cloud', 'raw-tracks', or 'local'"));
                this.sendMessageToCallMachine(fs({
                    action: "local-recording-start"
                }, e1));
            }
        },
        {
            key: "updateRecording",
            value: function(e1) {
                var t = e1.layout, n = void 0 === t ? {
                    preset: "default"
                } : t, r = e1.instanceId;
                this.sendMessageToCallMachine({
                    action: "daily-method-update-recording",
                    layout: n,
                    instanceId: r
                });
            }
        },
        {
            key: "stopRecording",
            value: function() {
                var e1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                this.sendMessageToCallMachine(fs({
                    action: "local-recording-stop"
                }, e1));
            }
        },
        {
            key: "startLiveStreaming",
            value: function() {
                var e1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                this.sendMessageToCallMachine(fs({
                    action: "daily-method-start-live-streaming"
                }, e1));
            }
        },
        {
            key: "updateLiveStreaming",
            value: function(e1) {
                var t = e1.layout, n = void 0 === t ? {
                    preset: "default"
                } : t, r = e1.instanceId;
                this.sendMessageToCallMachine({
                    action: "daily-method-update-live-streaming",
                    layout: n,
                    instanceId: r
                });
            }
        },
        {
            key: "addLiveStreamingEndpoints",
            value: function(e1) {
                var t = e1.endpoints, n = e1.instanceId;
                this.sendMessageToCallMachine({
                    action: zo,
                    endpointsOp: Xo,
                    endpoints: t,
                    instanceId: n
                });
            }
        },
        {
            key: "removeLiveStreamingEndpoints",
            value: function(e1) {
                var t = e1.endpoints, n = e1.instanceId;
                this.sendMessageToCallMachine({
                    action: zo,
                    endpointsOp: Zo,
                    endpoints: t,
                    instanceId: n
                });
            }
        },
        {
            key: "stopLiveStreaming",
            value: function() {
                var e1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                this.sendMessageToCallMachine(fs({
                    action: "daily-method-stop-live-streaming"
                }, e1));
            }
        },
        {
            key: "validateDailyConfig",
            value: function(e1) {
                e1.camSimulcastEncodings && (console.warn("camSimulcastEncodings is deprecated. Use sendSettings, found in DailyCallOptions, to provide camera simulcast settings."), this.validateSimulcastEncodings(e1.camSimulcastEncodings)), e1.screenSimulcastEncodings && console.warn("screenSimulcastEncodings is deprecated. Use sendSettings, found in DailyCallOptions, to provide screen simulcast settings."), ua() && e1.noAutoDefaultDeviceChange && console.warn("noAutoDefaultDeviceChange is not supported on Android, and will be ignored.");
            }
        },
        {
            key: "validateSimulcastEncodings",
            value: function(e1) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                if (e1) {
                    if (!(e1 instanceof Array || Array.isArray(e1))) throw new Error("encodings must be an Array");
                    if (!rc(e1.length, 1, 3)) throw new Error("encodings must be an Array with between 1 to ".concat(3, " layers"));
                    for(var r = 0; r < e1.length; r++){
                        var i = e1[r];
                        for(var o in this._validateEncodingLayerHasValidProperties(i), i)if (Ms.includes(o)) {
                            if ("number" != typeof i[o]) throw new Error("".concat(o, " must be a number"));
                            if (t) {
                                var a = t[o], s = a.min, c = a.max;
                                if (!rc(i[o], s, c)) throw new Error("".concat(o, " value not in range. valid range: ").concat(s, " to ").concat(c));
                            }
                        } else if (![
                            "active",
                            "scalabilityMode"
                        ].includes(o)) throw new Error("Invalid key ".concat(o, ", valid keys are:") + Object.values(Ms));
                        if (n && !i.hasOwnProperty("maxBitrate")) throw new Error("maxBitrate is not specified");
                    }
                }
            }
        },
        {
            key: "startRemoteMediaPlayer",
            value: (P = h(function*(e1) {
                var t = this, n = e1.url, r = e1.settings, i = void 0 === r ? {
                    state: Yo.PLAY
                } : r;
                try {
                    !function(e1) {
                        if ("string" != typeof e1) throw new Error('url parameter must be "string" type');
                    }(n), nc(i), function(e1) {
                        for(var t in e1)if (!Cs.includes(t)) throw new Error("Invalid key ".concat(t, ", valid keys are: ").concat(Cs));
                        e1.simulcastEncodings && this.validateSimulcastEncodings(e1.simulcastEncodings, Ss, !0);
                    }(i);
                } catch (e1) {
                    throw console.error("invalid argument Error: ".concat(e1)), console.error('startRemoteMediaPlayer arguments must be of the form:\n  { url: "playback url",\n  settings?:\n  {state: "play"|"pause", simulcastEncodings?: [{}] } }'), e1;
                }
                return new Promise(function(e1, r) {
                    t.sendMessageToCallMachine({
                        action: "daily-method-start-remote-media-player",
                        url: n,
                        settings: i
                    }, function(t) {
                        t.error ? r({
                            error: t.error,
                            errorMsg: t.errorMsg
                        }) : e1({
                            session_id: t.session_id,
                            remoteMediaPlayerState: {
                                state: t.state,
                                settings: t.settings
                            }
                        });
                    });
                });
            }), function(e1) {
                return P.apply(this, arguments);
            })
        },
        {
            key: "stopRemoteMediaPlayer",
            value: (T = h(function*(e1) {
                var t = this;
                if ("string" != typeof e1) throw new Error(" remotePlayerID must be of type string");
                return new Promise(function(n, r) {
                    t.sendMessageToCallMachine({
                        action: "daily-method-stop-remote-media-player",
                        session_id: e1
                    }, function(e1) {
                        e1.error ? r({
                            error: e1.error,
                            errorMsg: e1.errorMsg
                        }) : n();
                    });
                });
            }), function(e1) {
                return T.apply(this, arguments);
            })
        },
        {
            key: "updateRemoteMediaPlayer",
            value: (E = h(function*(e1) {
                var t = this, n = e1.session_id, r = e1.settings;
                try {
                    nc(r);
                } catch (e1) {
                    throw console.error("invalid argument Error: ".concat(e1)), console.error('updateRemoteMediaPlayer arguments must be of the form:\n  session_id: "participant session",\n  { settings?: {state: "play"|"pause"} }'), e1;
                }
                return new Promise(function(e1, i) {
                    t.sendMessageToCallMachine({
                        action: "daily-method-update-remote-media-player",
                        session_id: n,
                        settings: r
                    }, function(t) {
                        t.error ? i({
                            error: t.error,
                            errorMsg: t.errorMsg
                        }) : e1({
                            session_id: t.session_id,
                            remoteMediaPlayerState: {
                                state: t.state,
                                settings: t.settings
                            }
                        });
                    });
                });
            }), function(e1) {
                return E.apply(this, arguments);
            })
        },
        {
            key: "startTranscription",
            value: function(e1) {
                xs(this._callState, "startTranscription()"), this.sendMessageToCallMachine(fs({
                    action: "daily-method-start-transcription"
                }, e1));
            }
        },
        {
            key: "updateTranscription",
            value: function(e1) {
                if (xs(this._callState, "updateTranscription()"), !e1) throw new Error("updateTranscription Error: options is mandatory");
                if ("object" !== n(e1)) throw new Error("updateTranscription Error: options must be object type");
                if (e1.participants && !Array.isArray(e1.participants)) throw new Error("updateTranscription Error: participants must be an array");
                this.sendMessageToCallMachine(fs({
                    action: "daily-method-update-transcription"
                }, e1));
            }
        },
        {
            key: "stopTranscription",
            value: function(e1) {
                if (xs(this._callState, "stopTranscription()"), e1 && "object" !== n(e1)) throw new Error("stopTranscription Error: options must be object type");
                if (e1 && !e1.instanceId) throw new Error('"instanceId" not provided');
                this.sendMessageToCallMachine(fs({
                    action: "daily-method-stop-transcription"
                }, e1));
            }
        },
        {
            key: "startDialOut",
            value: (C = h(function*(e1) {
                var t = this;
                xs(this._callState, "startDialOut()");
                var n = function(e1) {
                    if (e1) {
                        if (!Array.isArray(e1)) throw new Error("Error starting dial out: audio codec must be an array");
                        if (e1.length <= 0) throw new Error("Error starting dial out: audio codec array specified but empty");
                        e1.forEach(function(e1) {
                            if ("string" != typeof e1) throw new Error("Error starting dial out: audio codec must be a string");
                            if ("OPUS" !== e1 && "PCMU" !== e1 && "PCMA" !== e1 && "G722" !== e1) throw new Error("Error starting dial out: audio codec must be one of OPUS, PCMU, PCMA, G722");
                        });
                    }
                };
                if (!e1.sipUri && !e1.phoneNumber) throw new Error("Error starting dial out: either a sip uri or phone number must be provided");
                if (e1.sipUri && e1.phoneNumber) throw new Error("Error starting dial out: only one of sip uri or phone number must be provided");
                if (e1.sipUri) {
                    if ("string" != typeof e1.sipUri) throw new Error("Error starting dial out: sipUri must be a string");
                    if (!e1.sipUri.startsWith("sip:")) throw new Error("Error starting dial out: Invalid SIP URI, must start with 'sip:'");
                    if (e1.video && "boolean" != typeof e1.video) throw new Error("Error starting dial out: video must be a boolean value");
                    !function(e1) {
                        if (e1 && (n(e1.audio), e1.video)) {
                            if (!Array.isArray(e1.video)) throw new Error("Error starting dial out: video codec must be an array");
                            if (e1.video.length <= 0) throw new Error("Error starting dial out: video codec array specified but empty");
                            e1.video.forEach(function(e1) {
                                if ("string" != typeof e1) throw new Error("Error starting dial out: video codec must be a string");
                                if ("H264" !== e1 && "VP8" !== e1) throw new Error("Error starting dial out: video codec must be H264 or VP8");
                            });
                        }
                    }(e1.codecs);
                }
                if (e1.phoneNumber) {
                    if ("string" != typeof e1.phoneNumber) throw new Error("Error starting dial out: phoneNumber must be a string");
                    if (!/^\+\d{1,}$/.test(e1.phoneNumber)) throw new Error("Error starting dial out: Invalid phone number, must be valid phone number as per E.164");
                    e1.codecs && n(e1.codecs.audio);
                }
                if (e1.callerId) {
                    if ("string" != typeof e1.callerId) throw new Error("Error starting dial out: callerId must be a string");
                    if (e1.sipUri) throw new Error("Error starting dial out: callerId not allowed with sipUri");
                }
                if (e1.displayName) {
                    if ("string" != typeof e1.displayName) throw new Error("Error starting dial out: displayName must be a string");
                    if (e1.displayName.length >= 200) throw new Error("Error starting dial out: displayName length must be less than 200");
                }
                if (e1.userId) {
                    if ("string" != typeof e1.userId) throw new Error("Error starting dial out: userId must be a string");
                    if (e1.userId.length > 36) throw new Error("Error starting dial out: userId length must be less than or equal to 36");
                }
                return new Promise(function(n, r) {
                    t.sendMessageToCallMachine(fs({
                        action: "dialout-start"
                    }, e1), function(e1) {
                        e1.error ? r(e1.error) : n(e1);
                    });
                });
            }), function(e1) {
                return C.apply(this, arguments);
            })
        },
        {
            key: "stopDialOut",
            value: function(e1) {
                var t = this;
                return xs(this._callState, "stopDialOut()"), new Promise(function(n, r) {
                    t.sendMessageToCallMachine(fs({
                        action: "dialout-stop"
                    }, e1), function(e1) {
                        e1.error ? r(e1.error) : n(e1);
                    });
                });
            }
        },
        {
            key: "sipCallTransfer",
            value: (M = h(function*(e1) {
                var t = this;
                if (xs(this._callState, "sipCallTransfer()"), !e1) throw new Error("sipCallTransfer() requires a sessionId and toEndPoint");
                return e1.useSipRefer = !1, tc(e1, "sipCallTransfer"), new Promise(function(n, r) {
                    t.sendMessageToCallMachine(fs({
                        action: ea
                    }, e1), function(e1) {
                        e1.error ? r(e1.error) : n(e1);
                    });
                });
            }), function(e1) {
                return M.apply(this, arguments);
            })
        },
        {
            key: "sipRefer",
            value: (S = h(function*(e1) {
                var t = this;
                if (xs(this._callState, "sipRefer()"), !e1) throw new Error("sessionId and toEndPoint are mandatory parameter");
                return e1.useSipRefer = !0, tc(e1, "sipRefer"), new Promise(function(n, r) {
                    t.sendMessageToCallMachine(fs({
                        action: ea
                    }, e1), function(e1) {
                        e1.error ? r(e1.error) : n(e1);
                    });
                });
            }), function(e1) {
                return S.apply(this, arguments);
            })
        },
        {
            key: "sendDTMF",
            value: (k = h(function*(e1) {
                var t = this;
                return xs(this._callState, "sendDTMF()"), function(e1) {
                    var t = e1.sessionId, n = e1.tones;
                    if (!t || !n) throw new Error("sessionId and tones are mandatory parameter");
                    if ("string" != typeof t || "string" != typeof n) throw new Error("sessionId and tones should be of string type");
                    if (n.length > 20) throw new Error("tones string must be upto 20 characters");
                    var r = /[^0-9A-D*#]/g, i = n.match(r);
                    if (i && i[0]) throw new Error("".concat(i[0], " is not valid DTMF tone"));
                }(e1), new Promise(function(n, r) {
                    t.sendMessageToCallMachine(fs({
                        action: "send-dtmf"
                    }, e1), function(e1) {
                        e1.error ? r(e1.error) : n(e1);
                    });
                });
            }), function(e1) {
                return k.apply(this, arguments);
            })
        },
        {
            key: "getNetworkStats",
            value: function() {
                var e1 = this;
                if (this._callState !== ri) {
                    return {
                        stats: {
                            latest: {}
                        }
                    };
                }
                return new Promise(function(t) {
                    e1.sendMessageToCallMachine({
                        action: "get-calc-stats"
                    }, function(n) {
                        t(fs({
                            stats: n.stats
                        }, e1._network));
                    });
                });
            }
        },
        {
            key: "testWebsocketConnectivity",
            value: (w = h(function*() {
                var e1 = this;
                if (Fs(this._testCallInProgress, "testWebsocketConnectivity()"), this.needsLoad()) try {
                    yield this.load();
                } catch (e1) {
                    return Promise.reject(e1);
                }
                return new Promise(function(t, n) {
                    e1.sendMessageToCallMachine({
                        action: "test-websocket-connectivity"
                    }, function(e1) {
                        e1.error ? n(e1.error) : t(e1.results);
                    });
                });
            }), function() {
                return w.apply(this, arguments);
            })
        },
        {
            key: "abortTestWebsocketConnectivity",
            value: function() {
                this.sendMessageToCallMachine({
                    action: "abort-test-websocket-connectivity"
                });
            }
        },
        {
            key: "_validateVideoTrackForNetworkTests",
            value: function(e1) {
                return e1 ? e1 instanceof MediaStreamTrack ? !!us(e1, {
                    isLocalScreenVideo: !1
                }) || (console.error("Video track is not playable. This test needs a live video track."), !1) : (console.error("Video track needs to be of type `MediaStreamTrack`."), !1) : (console.error("Missing video track. You must provide a video track in order to run this test."), !1);
            }
        },
        {
            key: "testCallQuality",
            value: (b = h(function*() {
                var t = this;
                Us(), Rs(this._callObjectMode, "testCallQuality()"), Ns(this._callMachineInitialized, "testCallQuality()", null, !0), Ds(this._callState, this._isPreparingToJoin, "testCallQuality()");
                var n = this._testCallAlreadyInProgress, r = function(e1) {
                    n || (t._testCallInProgress = e1);
                };
                if (r(!0), this.needsLoad()) try {
                    var i = this._callState;
                    yield this.load(), this._callState = i;
                } catch (e1) {
                    return r(!1), Promise.reject(e1);
                }
                return new Promise(function(n) {
                    t.sendMessageToCallMachine({
                        action: "test-call-quality",
                        dailyJsVersion: t.properties.dailyJsVersion
                    }, function(i) {
                        var o = i.results, a = o.result, s = e1(o, ds);
                        if ("failed" === a) {
                            var c, l = fs({}, s);
                            null !== (c = s.error) && void 0 !== c && c.details ? (s.error.details = JSON.parse(s.error.details), l.error = fs(fs({}, l.error), {}, {
                                details: fs({}, l.error.details)
                            }), l.error.details.duringTest = "testCallQuality") : (l.error = l.error ? fs({}, l.error) : {}, l.error.details = {
                                duringTest: "testCallQuality"
                            }), t._maybeSendToSentry(l);
                        }
                        r(!1), n(fs({
                            result: a
                        }, s));
                    });
                });
            }), function() {
                return b.apply(this, arguments);
            })
        },
        {
            key: "stopTestCallQuality",
            value: function() {
                this.sendMessageToCallMachine({
                    action: "stop-test-call-quality"
                });
            }
        },
        {
            key: "testConnectionQuality",
            value: (_ = h(function*(e1) {
                var t;
                na() ? (console.warn("testConnectionQuality() is deprecated: use testPeerToPeerCallQuality() instead"), t = yield this.testPeerToPeerCallQuality(e1)) : (console.warn("testConnectionQuality() is deprecated: use testCallQuality() instead"), t = yield this.testCallQuality());
                var n = {
                    result: t.result,
                    secondsElapsed: t.secondsElapsed
                };
                return t.data && (n.data = {
                    maxRTT: t.data.maxRoundTripTime,
                    packetLoss: t.data.avgRecvPacketLoss
                }), n;
            }), function(e1) {
                return _.apply(this, arguments);
            })
        },
        {
            key: "testPeerToPeerCallQuality",
            value: (y = h(function*(e1) {
                var t = this;
                if (Fs(this._testCallInProgress, "testPeerToPeerCallQuality()"), this.needsLoad()) try {
                    yield this.load();
                } catch (e1) {
                    return Promise.reject(e1);
                }
                var n = e1.videoTrack, r = e1.duration;
                if (!this._validateVideoTrackForNetworkTests(n)) throw new Error("Video track error");
                return this._sharedTracks.videoTrackForConnectionQualityTest = n, new Promise(function(e1, n) {
                    t.sendMessageToCallMachine({
                        action: "test-p2p-call-quality",
                        duration: r
                    }, function(t) {
                        t.error ? n(t.error) : e1(t.results);
                    });
                });
            }), function(e1) {
                return y.apply(this, arguments);
            })
        },
        {
            key: "stopTestConnectionQuality",
            value: function() {
                na() ? (console.warn("stopTestConnectionQuality() is deprecated: use testPeerToPeerCallQuality() and stopTestPeerToPeerCallQuality() instead"), this.stopTestPeerToPeerCallQuality()) : (console.warn("stopTestConnectionQuality() is deprecated: use testCallQuality() and stopTestCallQuality() instead"), this.stopTestCallQuality());
            }
        },
        {
            key: "stopTestPeerToPeerCallQuality",
            value: function() {
                this.sendMessageToCallMachine({
                    action: "stop-test-p2p-call-quality"
                });
            }
        },
        {
            key: "testNetworkConnectivity",
            value: (g = h(function*(e1) {
                var t = this;
                if (Fs(this._testCallInProgress, "testNetworkConnectivity()"), this.needsLoad()) try {
                    yield this.load();
                } catch (e1) {
                    return Promise.reject(e1);
                }
                if (!this._validateVideoTrackForNetworkTests(e1)) throw new Error("Video track error");
                return this._sharedTracks.videoTrackForNetworkConnectivityTest = e1, new Promise(function(e1, n) {
                    t.sendMessageToCallMachine({
                        action: "test-network-connectivity"
                    }, function(t) {
                        t.error ? n(t.error) : e1(t.results);
                    });
                });
            }), function(e1) {
                return g.apply(this, arguments);
            })
        },
        {
            key: "abortTestNetworkConnectivity",
            value: function() {
                this.sendMessageToCallMachine({
                    action: "abort-test-network-connectivity"
                });
            }
        },
        {
            key: "getCpuLoadStats",
            value: function() {
                var e1 = this;
                return new Promise(function(t) {
                    if (e1._callState === ri) {
                        e1.sendMessageToCallMachine({
                            action: "get-cpu-load-stats"
                        }, function(e1) {
                            t(e1.cpuStats);
                        });
                    } else t({
                        cpuLoadState: void 0,
                        cpuLoadStateReason: void 0,
                        stats: {}
                    });
                });
            }
        },
        {
            key: "_validateEncodingLayerHasValidProperties",
            value: function(e1) {
                var t;
                if (!((null === (t = Object.keys(e1)) || void 0 === t ? void 0 : t.length) > 0)) throw new Error("Empty encoding is not allowed. At least one of these valid keys should be specified:" + Object.values(Ms));
            }
        },
        {
            key: "_validateVideoSendSettings",
            value: function(e1, t) {
                var r = "screenVideo" === e1 ? [
                    "default-screen-video",
                    "detail-optimized",
                    "motion-optimized",
                    "motion-and-detail-balanced"
                ] : [
                    "default-video",
                    "bandwidth-optimized",
                    "bandwidth-and-quality-balanced",
                    "quality-optimized",
                    "adaptive-2-layers",
                    "adaptive-3-layers"
                ], i = "Video send settings should be either an object or one of the supported presets: ".concat(r.join());
                if ("string" == typeof t) {
                    if (!r.includes(t)) throw new Error(i);
                } else {
                    if ("object" !== n(t)) throw new Error(i);
                    if (!t.maxQuality && !t.encodings && void 0 === t.allowAdaptiveLayers) throw new Error("Video send settings must contain at least maxQuality, allowAdaptiveLayers or encodings attribute");
                    if (t.maxQuality && -1 === [
                        "low",
                        "medium",
                        "high"
                    ].indexOf(t.maxQuality)) throw new Error("maxQuality must be either low, medium or high");
                    if (t.encodings) {
                        var o = !1;
                        switch(Object.keys(t.encodings).length){
                            case 1:
                                o = !t.encodings.low;
                                break;
                            case 2:
                                o = !t.encodings.low || !t.encodings.medium;
                                break;
                            case 3:
                                o = !t.encodings.low || !t.encodings.medium || !t.encodings.high;
                                break;
                            default:
                                o = !0;
                        }
                        if (o) throw new Error("Encodings must be defined as: low, low and medium, or low, medium and high.");
                        t.encodings.low && this._validateEncodingLayerHasValidProperties(t.encodings.low), t.encodings.medium && this._validateEncodingLayerHasValidProperties(t.encodings.medium), t.encodings.high && this._validateEncodingLayerHasValidProperties(t.encodings.high);
                    }
                }
            }
        },
        {
            key: "validateUpdateSendSettings",
            value: function(e1) {
                var t = this;
                if (!e1 || 0 === Object.keys(e1).length) throw new Error("Send settings must contain at least information for one track!");
                Object.entries(e1).forEach(function(e1) {
                    var n = v(e1, 2), r = n[0], i = n[1];
                    t._validateVideoSendSettings(r, i);
                });
            }
        },
        {
            key: "updateSendSettings",
            value: function(e1) {
                var t = this;
                return this.validateUpdateSendSettings(e1), this.needsLoad() ? (this._preloadCache.sendSettings = e1, {
                    sendSettings: this._preloadCache.sendSettings
                }) : new Promise(function(n, r) {
                    t.sendMessageToCallMachine({
                        action: "update-send-settings",
                        sendSettings: e1
                    }, function(e1) {
                        e1.error ? r(e1.error) : n(e1.sendSettings);
                    });
                });
            }
        },
        {
            key: "getSendSettings",
            value: function() {
                return this._sendSettings || this._preloadCache.sendSettings;
            }
        },
        {
            key: "getLocalAudioLevel",
            value: function() {
                return this._localAudioLevel;
            }
        },
        {
            key: "getRemoteParticipantsAudioLevel",
            value: function() {
                return this._remoteParticipantsAudioLevel;
            }
        },
        {
            key: "getActiveSpeaker",
            value: function() {
                return Us(), this._activeSpeaker;
            }
        },
        {
            key: "setActiveSpeakerMode",
            value: function(e1) {
                return Us(), this.sendMessageToCallMachine({
                    action: "set-active-speaker-mode",
                    enabled: e1
                }), this;
            }
        },
        {
            key: "activeSpeakerMode",
            value: function() {
                return Us(), this._activeSpeakerMode;
            }
        },
        {
            key: "subscribeToTracksAutomatically",
            value: function() {
                return this._preloadCache.subscribeToTracksAutomatically;
            }
        },
        {
            key: "setSubscribeToTracksAutomatically",
            value: function(e1) {
                return xs(this._callState, "setSubscribeToTracksAutomatically()", "Use the subscribeToTracksAutomatically configuration property."), this._preloadCache.subscribeToTracksAutomatically = e1, this.sendMessageToCallMachine({
                    action: "daily-method-subscribe-to-tracks-automatically",
                    enabled: e1
                }), this;
            }
        },
        {
            key: "enumerateDevices",
            value: (f = h(function*() {
                var e1 = this;
                if (this._callObjectMode) {
                    var t = yield navigator.mediaDevices.enumerateDevices();
                    return "Firefox" === pa() && ha().major > 115 && ha().major < 123 && (t = t.filter(function(e1) {
                        return "audiooutput" !== e1.kind;
                    })), {
                        devices: t.map(function(e1) {
                            var t = JSON.parse(JSON.stringify(e1));
                            if (!na() && "videoinput" === e1.kind && e1.getCapabilities) {
                                var n, r = e1.getCapabilities();
                                t.facing = (null == r || null === (n = r.facingMode) || void 0 === n ? void 0 : n.length) >= 1 ? r.facingMode[0] : void 0;
                            }
                            return t;
                        })
                    };
                }
                return new Promise(function(t) {
                    e1.sendMessageToCallMachine({
                        action: "enumerate-devices"
                    }, function(e1) {
                        t({
                            devices: e1.devices
                        });
                    });
                });
            }), function() {
                return f.apply(this, arguments);
            })
        },
        {
            key: "sendAppMessage",
            value: function(e1) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "*";
                if (xs(this._callState, "sendAppMessage()"), JSON.stringify(e1).length > this._maxAppMessageSize) throw new Error("Message data too large. Max size is " + this._maxAppMessageSize);
                return this.sendMessageToCallMachine({
                    action: "app-msg",
                    data: e1,
                    to: t
                }), this;
            }
        },
        {
            key: "addFakeParticipant",
            value: function(e1) {
                return Us(), xs(this._callState, "addFakeParticipant()"), this.sendMessageToCallMachine(fs({
                    action: "add-fake-participant"
                }, e1)), this;
            }
        },
        {
            key: "setShowNamesMode",
            value: function(e1) {
                return Bs(this._callObjectMode, "setShowNamesMode()"), Us(), e1 && "always" !== e1 && "never" !== e1 ? (console.error('setShowNamesMode argument should be "always", "never", or false'), this) : (this.sendMessageToCallMachine({
                    action: "set-show-names",
                    mode: e1
                }), this);
            }
        },
        {
            key: "setShowLocalVideo",
            value: function() {
                var e1 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                return Bs(this._callObjectMode, "setShowLocalVideo()"), Us(), xs(this._callState, "setShowLocalVideo()"), "boolean" != typeof e1 ? (console.error("setShowLocalVideo only accepts a boolean value"), this) : (this.sendMessageToCallMachine({
                    action: "set-show-local-video",
                    show: e1
                }), this._showLocalVideo = e1, this);
            }
        },
        {
            key: "showLocalVideo",
            value: function() {
                return Bs(this._callObjectMode, "showLocalVideo()"), Us(), this._showLocalVideo;
            }
        },
        {
            key: "setShowParticipantsBar",
            value: function() {
                var e1 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                return Bs(this._callObjectMode, "setShowParticipantsBar()"), Us(), xs(this._callState, "setShowParticipantsBar()"), "boolean" != typeof e1 ? (console.error("setShowParticipantsBar only accepts a boolean value"), this) : (this.sendMessageToCallMachine({
                    action: "set-show-participants-bar",
                    show: e1
                }), this._showParticipantsBar = e1, this);
            }
        },
        {
            key: "showParticipantsBar",
            value: function() {
                return Bs(this._callObjectMode, "showParticipantsBar()"), Us(), this._showParticipantsBar;
            }
        },
        {
            key: "customIntegrations",
            value: function() {
                return Us(), Bs(this._callObjectMode, "customIntegrations()"), this._customIntegrations;
            }
        },
        {
            key: "setCustomIntegrations",
            value: function(e1) {
                return Us(), Bs(this._callObjectMode, "setCustomIntegrations()"), xs(this._callState, "setCustomIntegrations()"), Zs(e1) ? (this.sendMessageToCallMachine({
                    action: "set-custom-integrations",
                    integrations: e1
                }), this._customIntegrations = e1, this) : this;
            }
        },
        {
            key: "startCustomIntegrations",
            value: function(e1) {
                var t = this;
                if (Us(), Bs(this._callObjectMode, "startCustomIntegrations()"), xs(this._callState, "startCustomIntegrations()"), Array.isArray(e1) && e1.some(function(e1) {
                    return "string" != typeof e1;
                }) || !Array.isArray(e1) && "string" != typeof e1) return console.error("startCustomIntegrations() only accepts string | string[]"), this;
                var n = "string" == typeof e1 ? [
                    e1
                ] : e1, r = n.filter(function(e1) {
                    return !(e1 in t._customIntegrations);
                });
                return r.length ? (console.error("Can't find custom integration(s): \"".concat(r.join(", "), '"')), this) : (this.sendMessageToCallMachine({
                    action: "start-custom-integrations",
                    ids: n
                }), this);
            }
        },
        {
            key: "stopCustomIntegrations",
            value: function(e1) {
                var t = this;
                if (Us(), Bs(this._callObjectMode, "stopCustomIntegrations()"), xs(this._callState, "stopCustomIntegrations()"), Array.isArray(e1) && e1.some(function(e1) {
                    return "string" != typeof e1;
                }) || !Array.isArray(e1) && "string" != typeof e1) return console.error("stopCustomIntegrations() only accepts string | string[]"), this;
                var n = "string" == typeof e1 ? [
                    e1
                ] : e1, r = n.filter(function(e1) {
                    return !(e1 in t._customIntegrations);
                });
                return r.length ? (console.error("Can't find custom integration(s): \"".concat(r.join(", "), '"')), this) : (this.sendMessageToCallMachine({
                    action: "stop-custom-integrations",
                    ids: n
                }), this);
            }
        },
        {
            key: "customTrayButtons",
            value: function() {
                return Bs(this._callObjectMode, "customTrayButtons()"), Us(), this._customTrayButtons;
            }
        },
        {
            key: "updateCustomTrayButtons",
            value: function(e1) {
                return Bs(this._callObjectMode, "updateCustomTrayButtons()"), Us(), xs(this._callState, "updateCustomTrayButtons()"), Xs(e1) ? (this.sendMessageToCallMachine({
                    action: "update-custom-tray-buttons",
                    btns: e1
                }), this._customTrayButtons = e1, this) : (console.error("updateCustomTrayButtons only accepts a dictionary of the type ".concat(JSON.stringify(Ts))), this);
            }
        },
        {
            key: "theme",
            value: function() {
                return Bs(this._callObjectMode, "theme()"), this.properties.theme;
            }
        },
        {
            key: "setTheme",
            value: function(e1) {
                var t = this;
                return Bs(this._callObjectMode, "setTheme()"), new Promise(function(n, r) {
                    try {
                        t.validateProperties({
                            theme: e1
                        }), t.properties.theme = fs({}, e1), t.sendMessageToCallMachine({
                            action: "set-theme",
                            theme: t.properties.theme
                        });
                        try {
                            t.emitDailyJSEvent({
                                action: Ri,
                                theme: t.properties.theme
                            });
                        } catch (e1) {
                            console.log("could not emit 'theme-updated'", e1);
                        }
                        n(t.properties.theme);
                    } catch (e1) {
                        r(e1);
                    }
                });
            }
        },
        {
            key: "requestFullscreen",
            value: (p = h(function*() {
                if (Us(), this._iframe && !document.fullscreenElement && oa()) try {
                    (yield this._iframe.requestFullscreen) ? this._iframe.requestFullscreen() : this._iframe.webkitRequestFullscreen();
                } catch (e1) {
                    console.log("could not make video call fullscreen", e1);
                }
            }), function() {
                return p.apply(this, arguments);
            })
        },
        {
            key: "exitFullscreen",
            value: function() {
                Us(), document.fullscreenElement ? document.exitFullscreen() : document.webkitFullscreenElement && document.webkitExitFullscreen();
            }
        },
        {
            key: "getSidebarView",
            value: (u = h(function*() {
                var e1 = this;
                return this._callObjectMode ? (console.error("getSidebarView is not available in callObject mode"), Promise.resolve(null)) : new Promise(function(t) {
                    e1.sendMessageToCallMachine({
                        action: "get-sidebar-view"
                    }, function(e1) {
                        t(e1.view);
                    });
                });
            }), function() {
                return u.apply(this, arguments);
            })
        },
        {
            key: "setSidebarView",
            value: function(e1) {
                return this._callObjectMode ? (console.error("setSidebarView is not available in callObject mode"), this) : (this.sendMessageToCallMachine({
                    action: "set-sidebar-view",
                    view: e1
                }), this);
            }
        },
        {
            key: "room",
            value: (l = h(function*() {
                var e1 = this, t = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).includeRoomConfigDefaults, n = void 0 === t || t;
                return this._accessState.access === pi || this.needsLoad() ? this.properties.url ? {
                    roomUrlPendingJoin: this.properties.url
                } : null : new Promise(function(t) {
                    e1.sendMessageToCallMachine({
                        action: "lib-room-info",
                        includeRoomConfigDefaults: n
                    }, function(e1) {
                        delete e1.action, delete e1.callbackStamp, t(e1);
                    });
                });
            }), function() {
                return l.apply(this, arguments);
            })
        },
        {
            key: "geo",
            value: (s = h(function*() {
                try {
                    var e1 = yield fetch("https://gs.daily.co/_ks_/x-swsl/:");
                    return {
                        current: (yield e1.json()).geo
                    };
                } catch (e1) {
                    return console.error("geo lookup failed", e1), {
                        current: ""
                    };
                }
            }), function() {
                return s.apply(this, arguments);
            })
        },
        {
            key: "setNetworkTopology",
            value: (i = h(function*(e1) {
                var t = this;
                return Us(), xs(this._callState, "setNetworkTopology()"), new Promise(function(n, r) {
                    t.sendMessageToCallMachine({
                        action: "set-network-topology",
                        opts: e1
                    }, function(e1) {
                        e1.error ? r({
                            error: e1.error
                        }) : n({
                            workerId: e1.workerId
                        });
                    });
                });
            }), function(e1) {
                return i.apply(this, arguments);
            })
        },
        {
            key: "getNetworkTopology",
            value: (r = h(function*() {
                var e1 = this;
                return new Promise(function(t, n) {
                    e1.needsLoad() && t({
                        topology: "none"
                    }), e1.sendMessageToCallMachine({
                        action: "get-network-topology"
                    }, function(e1) {
                        e1.error ? n({
                            error: e1.error
                        }) : t({
                            topology: e1.topology
                        });
                    });
                });
            }), function() {
                return r.apply(this, arguments);
            })
        },
        {
            key: "setPlayNewParticipantSound",
            value: function(e1) {
                if (Us(), "number" != typeof e1 && !0 !== e1 && !1 !== e1) throw new Error("argument to setShouldPlayNewParticipantSound should be true, false, or a number, but is ".concat(e1));
                this.sendMessageToCallMachine({
                    action: "daily-method-set-play-ding",
                    arg: e1
                });
            }
        },
        {
            key: "on",
            value: function(e1, t) {
                return m.prototype.on.call(this, e1, t);
            }
        },
        {
            key: "once",
            value: function(e1, t) {
                return m.prototype.once.call(this, e1, t);
            }
        },
        {
            key: "off",
            value: function(e1, t) {
                return m.prototype.off.call(this, e1, t);
            }
        },
        {
            key: "validateProperties",
            value: function(e1) {
                var t, n;
                if (null != e1 && null !== (t = e1.dailyConfig) && void 0 !== t && t.userMediaAudioConstraints) {
                    var r, i, o;
                    na() || console.warn("userMediaAudioConstraints is deprecated. You can override constraints with inputSettings.audio.settings, found in DailyCallOptions.");
                    var a = e1.inputSettings || {};
                    a.audio = (null === (r = e1.inputSettings) || void 0 === r ? void 0 : r.audio) || {}, a.audio.settings = (null === (i = e1.inputSettings) || void 0 === i || null === (o = i.audio) || void 0 === o ? void 0 : o.settings) || {}, a.audio.settings = fs(fs({}, a.audio.settings), e1.dailyConfig.userMediaAudioConstraints), e1.inputSettings = a, delete e1.dailyConfig.userMediaAudioConstraints;
                }
                if (null != e1 && null !== (n = e1.dailyConfig) && void 0 !== n && n.userMediaVideoConstraints) {
                    var s, c, l;
                    na() || console.warn("userMediaVideoConstraints is deprecated. You can override constraints with inputSettings.video.settings, found in DailyCallOptions.");
                    var u = e1.inputSettings || {};
                    u.video = (null === (s = e1.inputSettings) || void 0 === s ? void 0 : s.video) || {}, u.video.settings = (null === (c = e1.inputSettings) || void 0 === c || null === (l = c.video) || void 0 === l ? void 0 : l.settings) || {}, u.video.settings = fs(fs({}, u.video.settings), e1.dailyConfig.userMediaVideoConstraints), e1.inputSettings = u, delete e1.dailyConfig.userMediaVideoConstraints;
                }
                for(var d in e1){
                    if (!Os[d]) throw new Error("unrecognized property '".concat(d, "'"));
                    if (Os[d].validate && !Os[d].validate(e1[d], this)) throw new Error("property '".concat(d, "': ").concat(Os[d].help));
                }
            }
        },
        {
            key: "assembleMeetingUrl",
            value: function() {
                var e1, t, n = fs(fs({}, this.properties), {}, {
                    emb: this.callClientId,
                    embHref: encodeURIComponent(window.location.href),
                    proxy: null !== (e1 = this.properties.dailyConfig) && void 0 !== e1 && e1.proxyUrl ? encodeURIComponent(null === (t = this.properties.dailyConfig) || void 0 === t ? void 0 : t.proxyUrl) : void 0
                }), r = n.url.match(/\?/) ? "&" : "?";
                return n.url + r + Object.keys(Os).filter(function(e1) {
                    return Os[e1].queryString && void 0 !== n[e1];
                }).map(function(e1) {
                    return "".concat(Os[e1].queryString, "=").concat(n[e1]);
                }).join("&");
            }
        },
        {
            key: "needsLoad",
            value: function() {
                return [
                    Zr,
                    ei,
                    ii,
                    oi
                ].includes(this._callState);
            }
        },
        {
            key: "sendMessageToCallMachine",
            value: function(e1, t) {
                if (this._destroyed && (this._logUseAfterDestroy(), this.strictMode)) throw new Error("Use after destroy");
                this._messageChannel.sendMessageToCallMachine(e1, t, this.callClientId, this._iframe);
            }
        },
        {
            key: "forwardPackagedMessageToCallMachine",
            value: function(e1) {
                this._messageChannel.forwardPackagedMessageToCallMachine(e1, this._iframe, this.callClientId);
            }
        },
        {
            key: "addListenerForPackagedMessagesFromCallMachine",
            value: function(e1) {
                return this._messageChannel.addListenerForPackagedMessagesFromCallMachine(e1, this.callClientId);
            }
        },
        {
            key: "removeListenerForPackagedMessagesFromCallMachine",
            value: function(e1) {
                this._messageChannel.removeListenerForPackagedMessagesFromCallMachine(e1);
            }
        },
        {
            key: "handleMessageFromCallMachine",
            value: function(t) {
                switch(t.action){
                    case Ni:
                        this.sendMessageToCallMachine(fs({
                            action: Fi
                        }, this.properties));
                        break;
                    case "call-machine-initialized":
                        this._callMachineInitialized = !0;
                        var n = {
                            action: Wo,
                            level: "log",
                            code: 1011,
                            stats: {
                                event: "bundle load",
                                time: "no-op" === this._bundleLoadTime ? 0 : this._bundleLoadTime,
                                preLoaded: "no-op" === this._bundleLoadTime,
                                url: X(this.properties.dailyConfig)
                            }
                        };
                        this.sendMessageToCallMachine(n), this._delayDuplicateInstanceLog && this._logDuplicateInstanceAttempt();
                        break;
                    case Vi:
                        this._loadedCallback && (this._loadedCallback(), this._loadedCallback = null), this.emitDailyJSEvent(t);
                        break;
                    case zi:
                        var r, i = fs({}, t);
                        delete i.internal, this._maxAppMessageSize = (null === (r = t.internal) || void 0 === r ? void 0 : r._maxAppMessageSize) || Vo, this._joinedCallback && (this._joinedCallback(t.participants), this._joinedCallback = null), this.emitDailyJSEvent(i);
                        break;
                    case Hi:
                    case Gi:
                        if (this._callState === ii) return;
                        if (t.participant && t.participant.session_id) {
                            var o = t.participant.local ? "local" : t.participant.session_id;
                            if (this._callObjectMode) {
                                var a = this._callMachine().store;
                                Ga(t.participant, a), Qa(t.participant, a), Ka(t.participant, this._participants[o], a);
                            }
                            try {
                                this.maybeParticipantTracksStopped(this._participants[o], t.participant), this.maybeParticipantTracksStarted(this._participants[o], t.participant), this.maybeEventRecordingStopped(this._participants[o], t.participant), this.maybeEventRecordingStarted(this._participants[o], t.participant);
                            } catch (e1) {
                                console.error("track events error", e1);
                            }
                            this.compareEqualForParticipantUpdateEvent(t.participant, this._participants[o]) || (this._participants[o] = fs({}, t.participant), this.toggleParticipantAudioBasedOnNativeAudioFocus(), this.emitDailyJSEvent(t));
                        }
                        break;
                    case Qi:
                        if (t.participant && t.participant.session_id) {
                            var s = this._participants[t.participant.session_id];
                            s && this.maybeParticipantTracksStopped(s, null), delete this._participants[t.participant.session_id], this.emitDailyJSEvent(t);
                        }
                        break;
                    case Yi:
                        D(this._participantCounts, t.participantCounts) || (this._participantCounts = t.participantCounts, this.emitDailyJSEvent(t));
                        break;
                    case Ki:
                        var c = {
                            access: t.access
                        };
                        t.awaitingAccess && (c.awaitingAccess = t.awaitingAccess), D(this._accessState, c) || (this._accessState = c, this.emitDailyJSEvent(t));
                        break;
                    case Xi:
                        if (t.meetingSession) {
                            this._meetingSessionSummary = t.meetingSession, this.emitDailyJSEvent(t);
                            var l = fs(fs({}, t), {}, {
                                action: "meeting-session-updated"
                            });
                            this.emitDailyJSEvent(l);
                        }
                        break;
                    case Uo:
                        var u;
                        this._iframe && !t.preserveIframe && (this._iframe.src = ""), this._updateCallState(oi), this.resetMeetingDependentVars(), this._loadedCallback && (this._loadedCallback(t.errorMsg), this._loadedCallback = null), t.preserveIframe;
                        var d = e1(t, ps);
                        null != d && null !== (u = d.error) && void 0 !== u && u.details && (d.error.details = JSON.parse(d.error.details)), this._maybeSendToSentry(t), this._joinedCallback && (this._joinedCallback(null, d), this._joinedCallback = null), this.emitDailyJSEvent(d);
                        break;
                    case Wi:
                        this._callState !== oi && this._updateCallState(ii), this.resetMeetingDependentVars(), this._resolveLeave && (this._resolveLeave(), this._resolveLeave = null), this.emitDailyJSEvent(t);
                        break;
                    case "selected-devices-updated":
                        t.devices && this.emitDailyJSEvent(t);
                        break;
                    case Eo:
                        var p = t.threshold, h = t.quality;
                        p === this._network.threshold && h === this._network.quality || (this._network.quality = h, this._network.threshold = p, this.emitDailyJSEvent(t));
                        break;
                    case Po:
                        t && t.cpuLoadState && this.emitDailyJSEvent(t);
                        break;
                    case Oo:
                        t && void 0 !== t.faceCounts && this.emitDailyJSEvent(t);
                        break;
                    case Mo:
                        var f = t.activeSpeaker;
                        this._activeSpeaker.peerId !== f.peerId && (this._activeSpeaker.peerId = f.peerId, this.emitDailyJSEvent({
                            action: t.action,
                            activeSpeaker: this._activeSpeaker
                        }));
                        break;
                    case "show-local-video-changed":
                        if (this._callObjectMode) return;
                        var v = t.show;
                        this._showLocalVideo = v, this.emitDailyJSEvent({
                            action: t.action,
                            show: v
                        });
                        break;
                    case Co:
                        var g = t.enabled;
                        this._activeSpeakerMode !== g && (this._activeSpeakerMode = g, this.emitDailyJSEvent({
                            action: t.action,
                            enabled: this._activeSpeakerMode
                        }));
                        break;
                    case to:
                    case no:
                    case ro:
                        this._waitingParticipants = t.allWaitingParticipants, this.emitDailyJSEvent({
                            action: t.action,
                            participant: t.participant
                        });
                        break;
                    case Fo:
                        D(this._receiveSettings, t.receiveSettings) || (this._receiveSettings = t.receiveSettings, this.emitDailyJSEvent({
                            action: t.action,
                            receiveSettings: t.receiveSettings
                        }));
                        break;
                    case Ro:
                        this._maybeUpdateInputSettings(t.inputSettings);
                        break;
                    case "send-settings-updated":
                        D(this._sendSettings, t.sendSettings) || (this._sendSettings = t.sendSettings, this._preloadCache.sendSettings = null, this.emitDailyJSEvent({
                            action: t.action,
                            sendSettings: t.sendSettings
                        }));
                        break;
                    case "local-audio-level":
                        this._localAudioLevel = t.audioLevel, this._preloadCache.localAudioLevelObserver = null, this.emitDailyJSEvent(t);
                        break;
                    case "remote-participants-audio-level":
                        this._remoteParticipantsAudioLevel = t.participantsAudioLevel, this._preloadCache.remoteParticipantsAudioLevelObserver = null, this.emitDailyJSEvent(t);
                        break;
                    case yo:
                        var m = t.session_id;
                        this._rmpPlayerState[m] = t.playerState, this.emitDailyJSEvent(t);
                        break;
                    case bo:
                        delete this._rmpPlayerState[t.session_id], this.emitDailyJSEvent(t);
                        break;
                    case _o:
                        var y = t.session_id, _ = this._rmpPlayerState[y];
                        _ && this.compareEqualForRMPUpdateEvent(_, t.remoteMediaPlayerState) || (this._rmpPlayerState[y] = t.remoteMediaPlayerState, this.emitDailyJSEvent(t));
                        break;
                    case "custom-button-click":
                    case "sidebar-view-changed":
                        this.emitDailyJSEvent(t);
                        break;
                    case Zi:
                        var b = this._meetingSessionState.topology !== (t.meetingSessionState && t.meetingSessionState.topology);
                        this._meetingSessionState = ic(t.meetingSessionState, this._callObjectMode), (this._callObjectMode || b) && this.emitDailyJSEvent(t);
                        break;
                    case wo:
                        this._isScreenSharing = !0, this.emitDailyJSEvent(t);
                        break;
                    case ko:
                    case So:
                        this._isScreenSharing = !1, this.emitDailyJSEvent(t);
                        break;
                    case lo:
                    case uo:
                    case po:
                    case ho:
                    case fo:
                    case ao:
                    case so:
                    case co:
                    case Ji:
                    case $i:
                    case go:
                    case mo:
                    case "test-completed":
                    case To:
                    case vo:
                    case Lo:
                    case xo:
                    case Io:
                    case Do:
                    case Bo:
                    case No:
                    case "dialin-ready":
                    case "dialin-connected":
                    case "dialin-error":
                    case "dialin-stopped":
                    case "dialin-warning":
                    case "dialout-connected":
                    case "dialout-answered":
                    case "dialout-error":
                    case "dialout-stopped":
                    case "dialout-warning":
                        this.emitDailyJSEvent(t);
                        break;
                    case "request-fullscreen":
                        this.requestFullscreen();
                        break;
                    case "request-exit-fullscreen":
                        this.exitFullscreen();
                }
            }
        },
        {
            key: "maybeEventRecordingStopped",
            value: function(e1, t) {
                var n = "record";
                e1 && (t.local || !1 !== t[n] || e1[n] === t[n] || this.emitDailyJSEvent({
                    action: uo
                }));
            }
        },
        {
            key: "maybeEventRecordingStarted",
            value: function(e1, t) {
                var n = "record";
                e1 && (t.local || !0 !== t[n] || e1[n] === t[n] || this.emitDailyJSEvent({
                    action: lo
                }));
            }
        },
        {
            key: "_trackStatePlayable",
            value: function(e1) {
                return !(!e1 || e1.state !== di);
            }
        },
        {
            key: "_trackChanged",
            value: function(e1, t) {
                return !((null == e1 ? void 0 : e1.id) === (null == t ? void 0 : t.id));
            }
        },
        {
            key: "maybeEventTrackStopped",
            value: function(e1, t, n) {
                var r, i, o = null !== (r = null == t ? void 0 : t.tracks[e1]) && void 0 !== r ? r : null, a = null !== (i = null == n ? void 0 : n.tracks[e1]) && void 0 !== i ? i : null, s = null == o ? void 0 : o.track;
                if (s) {
                    var c = this._trackStatePlayable(o), l = this._trackStatePlayable(a), u = this._trackChanged(s, null == a ? void 0 : a.track);
                    c && (l && !u || this.emitDailyJSEvent({
                        action: oo,
                        track: s,
                        participant: null != n ? n : t,
                        type: e1
                    }));
                }
            }
        },
        {
            key: "maybeEventTrackStarted",
            value: function(e1, t, n) {
                var r, i, o = null !== (r = null == t ? void 0 : t.tracks[e1]) && void 0 !== r ? r : null, a = null !== (i = null == n ? void 0 : n.tracks[e1]) && void 0 !== i ? i : null, s = null == a ? void 0 : a.track;
                if (s) {
                    var c = this._trackStatePlayable(o), l = this._trackStatePlayable(a), u = this._trackChanged(null == o ? void 0 : o.track, s);
                    l && (c && !u || this.emitDailyJSEvent({
                        action: io,
                        track: s,
                        participant: n,
                        type: e1
                    }));
                }
            }
        },
        {
            key: "maybeParticipantTracksStopped",
            value: function(e1, t) {
                if (e1) for(var n in e1.tracks)this.maybeEventTrackStopped(n, e1, t);
            }
        },
        {
            key: "maybeParticipantTracksStarted",
            value: function(e1, t) {
                if (t) for(var n in t.tracks)this.maybeEventTrackStarted(n, e1, t);
            }
        },
        {
            key: "compareEqualForRMPUpdateEvent",
            value: function(e1, t) {
                var n, r;
                return e1.state === t.state && (null === (n = e1.settings) || void 0 === n ? void 0 : n.volume) === (null === (r = t.settings) || void 0 === r ? void 0 : r.volume);
            }
        },
        {
            key: "emitDailyJSEvent",
            value: function(e1) {
                try {
                    e1.callClientId = this.callClientId, this.emit(e1.action, e1);
                } catch (t) {
                    console.log("could not emit", e1, t);
                }
            }
        },
        {
            key: "compareEqualForParticipantUpdateEvent",
            value: function(e1, t) {
                return !!D(e1, t) && (!e1.videoTrack || !t.videoTrack || e1.videoTrack.id === t.videoTrack.id && e1.videoTrack.muted === t.videoTrack.muted && e1.videoTrack.enabled === t.videoTrack.enabled) && (!e1.audioTrack || !t.audioTrack || e1.audioTrack.id === t.audioTrack.id && e1.audioTrack.muted === t.audioTrack.muted && e1.audioTrack.enabled === t.audioTrack.enabled);
            }
        },
        {
            key: "nativeUtils",
            value: function() {
                return na() ? "undefined" == typeof DailyNativeUtils ? (console.warn("in React Native, DailyNativeUtils is expected to be available"), null) : DailyNativeUtils : null;
            }
        },
        {
            key: "updateIsPreparingToJoin",
            value: function(e1) {
                this._updateCallState(this._callState, e1);
            }
        },
        {
            key: "_updateCallState",
            value: function(e1) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._isPreparingToJoin;
                if (e1 !== this._callState || t !== this._isPreparingToJoin) {
                    var n = this._callState, r = this._isPreparingToJoin;
                    this._callState = e1, this._isPreparingToJoin = t;
                    var i = this._callState === ri;
                    this.updateShowAndroidOngoingMeetingNotification(i);
                    var o = Is(n, r), a = Is(this._callState, this._isPreparingToJoin);
                    o !== a && (this.updateKeepDeviceAwake(a), this.updateDeviceAudioMode(a), this.updateNoOpRecordingEnsuringBackgroundContinuity(a));
                }
            }
        },
        {
            key: "resetMeetingDependentVars",
            value: function() {
                this._participants = {}, this._participantCounts = ks, this._waitingParticipants = {}, this._activeSpeaker = {}, this._activeSpeakerMode = !1, this._didPreAuth = !1, this._accessState = {
                    access: pi
                }, this._finalSummaryOfPrevSession = this._meetingSessionSummary, this._meetingSessionSummary = {}, this._meetingSessionState = ic(ws, this._callObjectMode), this._isScreenSharing = !1, this._receiveSettings = {}, this._inputSettings = void 0, this._sendSettings = {}, this._localAudioLevel = 0, this._isLocalAudioLevelObserverRunning = !1, this._remoteParticipantsAudioLevel = {}, this._isRemoteParticipantsAudioLevelObserverRunning = !1, this._maxAppMessageSize = Vo, this._callMachineInitialized = !1, this._bundleLoadTime = void 0, this._preloadCache;
            }
        },
        {
            key: "updateKeepDeviceAwake",
            value: function(e1) {
                na() && this.nativeUtils().setKeepDeviceAwake(e1, this.callClientId);
            }
        },
        {
            key: "updateDeviceAudioMode",
            value: function(e1) {
                if (na() && !this.disableReactNativeAutoDeviceManagement("audio")) {
                    var t = e1 ? this._nativeInCallAudioMode : "idle";
                    this.nativeUtils().setAudioMode(t);
                }
            }
        },
        {
            key: "updateShowAndroidOngoingMeetingNotification",
            value: function(e1) {
                if (na() && this.nativeUtils().setShowOngoingMeetingNotification) {
                    var t, n, r, i;
                    if (this.properties.reactNativeConfig && this.properties.reactNativeConfig.androidInCallNotification) {
                        var o = this.properties.reactNativeConfig.androidInCallNotification;
                        t = o.title, n = o.subtitle, r = o.iconName, i = o.disableForCustomOverride;
                    }
                    i && (e1 = !1), this.nativeUtils().setShowOngoingMeetingNotification(e1, t, n, r, this.callClientId);
                }
            }
        },
        {
            key: "updateNoOpRecordingEnsuringBackgroundContinuity",
            value: function(e1) {
                na() && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity(e1);
            }
        },
        {
            key: "toggleParticipantAudioBasedOnNativeAudioFocus",
            value: function() {
                var e1, t;
                if (na()) {
                    var n = null === (e1 = this._callMachine()) || void 0 === e1 || null === (t = e1.store) || void 0 === t ? void 0 : t.getState();
                    for(var r in null == n ? void 0 : n.streams){
                        var i = n.streams[r];
                        i && i.pendingTrack && "audio" === i.pendingTrack.kind && (i.pendingTrack.enabled = this._hasNativeAudioFocus);
                    }
                }
            }
        },
        {
            key: "disableReactNativeAutoDeviceManagement",
            value: function(e1) {
                return this.properties.reactNativeConfig && this.properties.reactNativeConfig.disableAutoDeviceManagement && this.properties.reactNativeConfig.disableAutoDeviceManagement[e1];
            }
        },
        {
            key: "absoluteUrl",
            value: function(e1) {
                if (void 0 !== e1) {
                    var t = document.createElement("a");
                    return t.href = e1, t.href;
                }
            }
        },
        {
            key: "sayHello",
            value: function() {
                var e1 = "hello, world.";
                return console.log(e1), e1;
            }
        },
        {
            key: "_logUseAfterDestroy",
            value: function() {
                var e1 = Object.values(ys)[0];
                if (this.needsLoad()) {
                    if (e1 && !e1.needsLoad()) {
                        var t = {
                            action: Wo,
                            level: "error",
                            code: this.strictMode ? 9995 : 9997
                        };
                        e1.sendMessageToCallMachine(t);
                    } else if (!this.strictMode) {
                        console.error("You are are attempting to use a call instance that was previously destroyed, which is unsupported. Please remove `strictMode: false` from your constructor properties to enable strict mode to track down and fix this unsupported usage.");
                    }
                } else {
                    var n = {
                        action: Wo,
                        level: "error",
                        code: this.strictMode ? 9995 : 9997
                    };
                    this._messageChannel.sendMessageToCallMachine(n, null, this.callClientId, this._iframe);
                }
            }
        },
        {
            key: "_logDuplicateInstanceAttempt",
            value: function() {
                for(var e1 = 0, t = Object.values(ys); e1 < t.length; e1++){
                    var n = t[e1];
                    n._callMachineInitialized ? (n.sendMessageToCallMachine({
                        action: Wo,
                        level: "warn",
                        code: this.allowMultipleCallInstances ? 9993 : 9992
                    }), n._delayDuplicateInstanceLog = !1) : n._delayDuplicateInstanceLog = !0;
                }
            }
        },
        {
            key: "_maybeSendToSentry",
            value: function(e1) {
                var t, n, r, i, o, a;
                if (null !== (t = e1.error) && void 0 !== t && t.type) {
                    if (![
                        Ti,
                        Ci,
                        Si
                    ].includes(e1.error.type)) return;
                    if (e1.error.type === Si && e1.error.msg.includes("deleted")) return;
                }
                var s = null !== (n = this.properties) && void 0 !== n && n.url ? new URL(this.properties.url) : void 0, c = "production";
                s && s.host.includes(".staging.daily") && (c = "staging");
                var l, u, d, p, h, f = [
                    Kn(),
                    Qn(),
                    $r(),
                    Vr(),
                    Gr(),
                    Xr(),
                    Zn(),
                    Kr()
                ].filter(function(e1) {
                    return ![
                        "BrowserApiErrors",
                        "Breadcrumbs",
                        "GlobalHandlers"
                    ].includes(e1.name);
                }), v = new mr({
                    dsn: "https://f10f1c81e5d44a4098416c0867a8b740@o77906.ingest.sentry.io/168844",
                    transport: jr,
                    stackParser: Rr,
                    integrations: f,
                    environment: c
                }), g = new on;
                if (g.setClient(v), v.init(), this.session_id && g.setExtra("sessionId", this.session_id), this.properties) {
                    var m = fs({}, this.properties);
                    m.userName = m.userName ? "[Filtered]" : void 0, m.userData = m.userData ? "[Filtered]" : void 0, m.token = m.token ? "[Filtered]" : void 0, g.setExtra("properties", m);
                }
                if (s) {
                    var y = s.searchParams.get("domain");
                    if (!y) {
                        var _ = s.host.match(/(.*?)\./);
                        y = _ && _[1] || "";
                    }
                    y && g.setTag("domain", y);
                }
                e1.error && (g.setTag("fatalErrorType", e1.error.type), g.setExtra("errorDetails", e1.error.details), (null === (l = e1.error.details) || void 0 === l ? void 0 : l.uri) && g.setTag("serverAddress", e1.error.details.uri), (null === (u = e1.error.details) || void 0 === u ? void 0 : u.workerGroup) && g.setTag("workerGroup", e1.error.details.workerGroup), (null === (d = e1.error.details) || void 0 === d ? void 0 : d.geoGroup) && g.setTag("geoGroup", e1.error.details.geoGroup), (null === (p = e1.error.details) || void 0 === p ? void 0 : p.on) && g.setTag("connectionAttempt", e1.error.details.on), null !== (h = e1.error.details) && void 0 !== h && h.bundleUrl && (g.setTag("bundleUrl", e1.error.details.bundleUrl), g.setTag("bundleError", e1.error.details.sourceError.type)));
                g.setTags({
                    callMode: this._callObjectMode ? na() ? "reactNative" : null !== (r = this.properties) && void 0 !== r && null !== (i = r.dailyConfig) && void 0 !== i && null !== (o = i.callMode) && void 0 !== o && o.includes("prebuilt") ? this.properties.dailyConfig.callMode : "custom" : "prebuilt-frame",
                    version: ee.version()
                });
                var b = (null === (a = e1.error) || void 0 === a ? void 0 : a.msg) || e1.errorMsg;
                g.captureException(new Error(b));
            }
        },
        {
            key: "_callMachine",
            value: function() {
                var e1, t, n;
                return null === (e1 = window._daily) || void 0 === e1 || null === (t = e1.instances) || void 0 === t || null === (n = t[this.callClientId]) || void 0 === n ? void 0 : n.callMachine;
            }
        },
        {
            key: "_maybeUpdateInputSettings",
            value: function(e1) {
                if (!D(this._inputSettings, e1)) {
                    var t = this._getInputSettings();
                    this._inputSettings = e1;
                    var n = this._getInputSettings();
                    D(t, n) || this.emitDailyJSEvent({
                        action: Ro,
                        inputSettings: n
                    });
                }
            }
        }
    ], [
        {
            key: "supportedBrowser",
            value: function() {
                if (na()) return {
                    supported: !0,
                    mobile: !0,
                    name: "React Native",
                    version: null,
                    supportsScreenShare: !0,
                    supportsSfu: !0,
                    supportsVideoProcessing: !1,
                    supportsAudioProcessing: !1
                };
                var e1 = G.getParser(ta());
                return {
                    supported: !!la(),
                    mobile: "mobile" === e1.getPlatformType(),
                    name: e1.getBrowserName(),
                    version: e1.getBrowserVersion(),
                    supportsFullscreen: !!oa(),
                    supportsScreenShare: !!ia(),
                    supportsSfu: !!la(),
                    supportsVideoProcessing: sa(),
                    supportsAudioProcessing: ca()
                };
            }
        },
        {
            key: "version",
            value: function() {
                return "0.75.2";
            }
        },
        {
            key: "createCallObject",
            value: function() {
                var e1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return e1.layout = "none", new ee(null, e1);
            }
        },
        {
            key: "wrap",
            value: function(e1) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (Us(), !e1 || !e1.contentWindow || "string" != typeof e1.src) throw new Error("DailyIframe::Wrap needs an iframe-like first argument");
                return t.layout || (t.customLayout ? t.layout = "custom-v1" : t.layout = "browser"), new ee(e1, t);
            }
        },
        {
            key: "createFrame",
            value: function(e1, t) {
                var n, r;
                Us(), e1 && t ? (n = e1, r = t) : e1 && e1.append ? (n = e1, r = {}) : (n = document.body, r = e1 || {});
                var i = r.iframeStyle;
                i || (i = n === document.body ? {
                    position: "fixed",
                    border: "1px solid black",
                    backgroundColor: "white",
                    width: "375px",
                    height: "450px",
                    right: "1em",
                    bottom: "1em"
                } : {
                    border: 0,
                    width: "100%",
                    height: "100%"
                });
                var o = document.createElement("iframe");
                window.navigator && window.navigator.userAgent.match(/Chrome\/61\./) ? o.allow = "microphone, camera" : o.allow = "microphone; camera; autoplay; display-capture; screen-wake-lock", o.style.visibility = "hidden", n.appendChild(o), o.style.visibility = null, Object.keys(i).forEach(function(e1) {
                    return o.style[e1] = i[e1];
                }), r.layout || (r.customLayout ? r.layout = "custom-v1" : r.layout = "browser");
                try {
                    return new ee(o, r);
                } catch (e1) {
                    throw n.removeChild(o), e1;
                }
            }
        },
        {
            key: "createTransparentFrame",
            value: function() {
                var e1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                Us();
                var t = document.createElement("iframe");
                return t.allow = "microphone; camera; autoplay", t.style.cssText = "\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      border: 0;\n      pointer-events: none;\n    ", document.body.appendChild(t), e1.layout || (e1.layout = "custom-v1"), ee.wrap(t, e1);
            }
        },
        {
            key: "getCallInstance",
            value: function() {
                var e1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
                return e1 ? ys[e1] : Object.values(ys)[0];
            }
        }
    ]), ee;
}();
function Ls(e1, t) {
    var n = {};
    for(var r in e1)if (e1[r] instanceof MediaStreamTrack) console.warn("MediaStreamTrack found in props or cache.", r), n[r] = Ho;
    else if ("dailyConfig" === r) {
        if (e1[r].modifyLocalSdpHook) {
            var i = window._daily.instances[t].customCallbacks || {};
            i.modifyLocalSdpHook = e1[r].modifyLocalSdpHook, window._daily.instances[t].customCallbacks = i, delete e1[r].modifyLocalSdpHook;
        }
        if (e1[r].modifyRemoteSdpHook) {
            var o = window._daily.instances[t].customCallbacks || {};
            o.modifyRemoteSdpHook = e1[r].modifyRemoteSdpHook, window._daily.instances[t].customCallbacks = o, delete e1[r].modifyRemoteSdpHook;
        }
        n[r] = e1[r];
    } else n[r] = e1[r];
    return n;
}
function xs(e1) {
    var t = arguments.length > 2 ? arguments[2] : void 0;
    if (e1 !== ri) {
        var n = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " only supported after join.");
        throw t && (n += " ".concat(t)), console.error(n), new Error(n);
    }
}
function Is(e1, t) {
    return [
        ni,
        ri
    ].includes(e1) || t;
}
function Ds(e1, t) {
    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "This daily-js method", r = arguments.length > 3 ? arguments[3] : void 0;
    if (Is(e1, t)) {
        var i = "".concat(n, " not supported after joining a meeting.");
        throw r && (i += " ".concat(r)), console.error(i), new Error(i);
    }
}
function Ns(e1) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", n = arguments.length > 2 ? arguments[2] : void 0;
    if (!e1) {
        var r = "".concat(t, arguments.length > 3 && void 0 !== arguments[3] && arguments[3] ? " requires preAuth() or startCamera() to initialize call state." : " requires preAuth(), startCamera(), or join() to initialize call state.");
        throw n && (r += " ".concat(n)), console.error(r), new Error(r);
    }
}
function Fs(e1) {
    if (e1) {
        var t = "A pre-call quality test is in progress. Please try ".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " again once testing has completed. Use stopTestCallQuality() to end it early.");
        throw console.error(t), new Error(t);
    }
}
function Rs(e1) {
    if (!e1) {
        var t = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " is only supported on custom callObject instances");
        throw console.error(t), new Error(t);
    }
}
function Bs(e1) {
    if (e1) {
        var t = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " is only supported as part of Daily's Prebuilt");
        throw console.error(t), new Error(t);
    }
}
function Us() {
    if (na()) throw new Error("This daily-js method is not currently supported in React Native");
}
function Vs() {
    if (!na()) throw new Error("This daily-js method is only supported in React Native");
}
function Js(e1) {
    if (void 0 === e1) return !0;
    var t;
    if ("string" == typeof e1) t = e1;
    else try {
        t = JSON.stringify(e1), D(JSON.parse(t), e1) || console.warn("The userData provided will be modified when serialized.");
    } catch (e1) {
        throw Error("userData must be serializable to JSON: ".concat(e1));
    }
    if (t.length > 4096) throw Error("userData is too large (".concat(t.length, " characters). Maximum size suppported is ").concat(4096, "."));
    return !0;
}
function $s(e1, t) {
    for(var n = t.allowAllParticipantsKey, r = function(e1) {
        var t = [
            "local"
        ];
        return n || t.push("*"), e1 && !t.includes(e1);
    }, i = function(e1) {
        return !!(void 0 === e1.layer || Number.isInteger(e1.layer) && e1.layer >= 0 || "inherit" === e1.layer);
    }, o = function(e1) {
        return !!e1 && !(e1.video && !i(e1.video)) && !(e1.screenVideo && !i(e1.screenVideo));
    }, a = 0, s = Object.entries(e1); a < s.length; a++){
        var c = v(s[a], 2), l = c[0], u = c[1];
        if (!r(l) || !o(u)) return !1;
    }
    return !0;
}
function qs(e1) {
    if ("object" !== n(e1)) return !1;
    for(var t = 0, r = Object.entries(e1); t < r.length; t++){
        var i = v(r[t], 2), o = i[0], a = i[1];
        switch(o){
            case "video":
                if ("object" !== n(a)) return !1;
                for(var s = 0, c = Object.entries(a); s < c.length; s++){
                    var l = v(c[s], 2), u = l[0], d = l[1];
                    switch(u){
                        case "processor":
                            if (!Hs(d)) return !1;
                            break;
                        case "settings":
                            if (!Gs(d)) return !1;
                            break;
                        default:
                            return !1;
                    }
                }
                break;
            case "audio":
                if ("object" !== n(a)) return !1;
                for(var p = 0, h = Object.entries(a); p < h.length; p++){
                    var f = v(h[p], 2), g = f[0], m = f[1];
                    switch(g){
                        case "processor":
                            if (!Ws(m)) return !1;
                            break;
                        case "settings":
                            if (!Gs(m)) return !1;
                            break;
                        default:
                            return !1;
                    }
                }
                break;
            default:
                return !1;
        }
    }
    return !0;
}
function zs(e1, t, n) {
    var r, i = [];
    e1.video && e1.video.processor && (sa(null !== (r = null == t ? void 0 : t.useLegacyVideoProcessor) && void 0 !== r && r) || (e1.video.settings ? delete e1.video.processor : delete e1.video, i.push("video")));
    e1.audio && e1.audio.processor && (ca() || (e1.audio.settings ? delete e1.audio.processor : delete e1.audio, i.push("audio"))), i.length > 0 && console.error("Ignoring settings for browser- or platform-unsupported input processor(s): ".concat(i.join(", "))), e1.audio && e1.audio.settings && (e1.audio.settings.customTrack ? (n.audioTrack = e1.audio.settings.customTrack, e1.audio.settings = {
        customTrack: Ho
    }) : delete n.audioTrack), e1.video && e1.video.settings && (e1.video.settings.customTrack ? (n.videoTrack = e1.video.settings.customTrack, e1.video.settings = {
        customTrack: Ho
    }) : delete n.videoTrack);
}
function Ws(e1) {
    if (na()) return console.warn("Video processing is not yet supported in React Native"), !1;
    var t = [
        "type"
    ];
    return !!e1 && "object" === n(e1) && (Object.keys(e1).filter(function(e1) {
        return !t.includes(e1);
    }).forEach(function(t) {
        console.warn("invalid key inputSettings -> audio -> processor : ".concat(t)), delete e1[t];
    }), !!function(e1) {
        if ("string" != typeof e1) return !1;
        if (!Object.values(Qo).includes(e1)) return console.error("inputSettings audio processor type invalid"), !1;
        return !0;
    }(e1.type));
}
function Hs(e1) {
    if (na()) return console.warn("Video processing is not yet supported in React Native"), !1;
    var t = [
        "type",
        "config"
    ];
    if (!e1) return !1;
    if ("object" !== n(e1)) return !1;
    if (!function(e1) {
        if ("string" != typeof e1) return !1;
        if (!Object.values(Go).includes(e1)) return console.error("inputSettings video processor type invalid"), !1;
        return !0;
    }(e1.type)) return !1;
    if (e1.config) {
        if ("object" !== n(e1.config)) return !1;
        if (!function(e1, t) {
            var n = Object.keys(t);
            if (0 === n.length) return !0;
            var r = "invalid object in inputSettings -> video -> processor -> config";
            switch(e1){
                case Go.BGBLUR:
                    return n.length > 1 || "strength" !== n[0] ? (console.error(r), !1) : !("number" != typeof t.strength || t.strength <= 0 || t.strength > 1 || isNaN(t.strength)) || (console.error("".concat(r, "; expected: {0 < strength <= 1}, got: ").concat(t.strength)), !1);
                case Go.BGIMAGE:
                    return !(void 0 !== t.source && !function(e1) {
                        if ("default" === e1.source) return e1.type = "default", !0;
                        if (e1.source instanceof ArrayBuffer) return !0;
                        if (Z(e1.source)) return e1.type = "url", !!function(e1) {
                            var t = new URL(e1), n = t.pathname;
                            if ("data:" === t.protocol) try {
                                var r = n.substring(n.indexOf(":") + 1, n.indexOf(";")).split("/")[1];
                                return Ko.includes(r);
                            } catch (e1) {
                                return console.error("failed to deduce blob content type", e1), !1;
                            }
                            var i = n.split(".").at(-1).toLowerCase().trim();
                            return Ko.includes(i);
                        }(e1.source) || (console.error("invalid image type; supported types: [".concat(Ko.join(", "), "]")), !1);
                        return t = e1.source, n = Number(t), isNaN(n) || !Number.isInteger(n) || n <= 0 || n > 10 ? (console.error("invalid image selection; must be an int, > 0, <= ".concat(10)), !1) : (e1.type = "daily-preselect", !0);
                        "TURBOPACK unreachable";
                        var t, n;
                    }(t));
                default:
                    return !0;
            }
        }(e1.type, e1.config)) return !1;
    }
    return Object.keys(e1).filter(function(e1) {
        return !t.includes(e1);
    }).forEach(function(t) {
        console.warn("invalid key inputSettings -> video -> processor : ".concat(t)), delete e1[t];
    }), !0;
}
function Gs(e1) {
    return "object" === n(e1) && (!e1.customTrack || e1.customTrack instanceof MediaStreamTrack);
}
function Qs() {
    var e1 = Object.values(Go).join(" | "), t = Object.values(Qo).join(" | ");
    return "inputSettings must be of the form: { video?: { processor?: { type: [ ".concat(e1, " ], config?: {} } }, audio?: { processor: {type: [ ").concat(t, " ] } } }");
}
function Ys(e1) {
    var t = e1.allowAllParticipantsKey;
    return "receiveSettings must be of the form { [<remote participant id> | ".concat(gi).concat(t ? ' | "'.concat("*", '"') : "", "]: ") + '{ [video: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]], [screenVideo: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]] }}}';
}
function Ks() {
    return "customIntegrations should be an object of type ".concat(JSON.stringify(Ps), ".");
}
function Xs(e1) {
    if (e1 && "object" !== n(e1) || Array.isArray(e1)) return console.error("customTrayButtons should be an Object of the type ".concat(JSON.stringify(Ts), ".")), !1;
    if (e1) for(var t = 0, r = Object.entries(e1); t < r.length; t++)for(var i = v(r[t], 1)[0], o = 0, a = Object.entries(e1[i]); o < a.length; o++){
        var s = v(a[o], 2), c = s[0], l = s[1], u = Ts.id[c];
        if (!u) return console.error("customTrayButton does not support key ".concat(c)), !1;
        switch(c){
            case "iconPath":
            case "iconPathDarkMode":
                if (!Z(l)) return console.error("customTrayButton ".concat(c, " should be a url.")), !1;
                break;
            case "visualState":
                if (![
                    "default",
                    "sidebar-open",
                    "active"
                ].includes(l)) return console.error("customTrayButton ".concat(c, " should be ").concat(u, ". Got: ").concat(l)), !1;
                break;
            default:
                if (n(l) !== u) return console.error("customTrayButton ".concat(c, " should be a ").concat(u, ".")), !1;
        }
    }
    return !0;
}
function Zs(e1) {
    if (!e1 || e1 && "object" !== n(e1) || Array.isArray(e1)) return console.error(Ks()), !1;
    for(var t = function(e1) {
        return "".concat(e1, " should be ").concat(Ps.id[e1]);
    }, r = function(e1, t) {
        return console.error("customIntegration ".concat(e1, ": ").concat(t));
    }, i = 0, o = Object.entries(e1); i < o.length; i++){
        var a = v(o[i], 1)[0];
        if (!("label" in e1[a])) return r(a, "label is required"), !1;
        if (!("location" in e1[a])) return r(a, "location is required"), !1;
        if (!("src" in e1[a]) && !("srcdoc" in e1[a])) return r(a, "src or srcdoc is required"), !1;
        for(var s = 0, c = Object.entries(e1[a]); s < c.length; s++){
            var l = v(c[s], 2), u = l[0], d = l[1];
            switch(u){
                case "allow":
                case "csp":
                case "name":
                case "referrerPolicy":
                case "sandbox":
                    if ("string" != typeof d) return r(a, t(u)), !1;
                    break;
                case "iconURL":
                    if (!Z(d)) return r(a, "".concat(u, " should be a url")), !1;
                    break;
                case "src":
                    if ("srcdoc" in e1[a]) return r(a, "cannot have both src and srcdoc"), !1;
                    if (!Z(d)) return r(a, 'src "'.concat(d, '" is not a valid URL')), !1;
                    break;
                case "srcdoc":
                    if ("src" in e1[a]) return r(a, "cannot have both src and srcdoc"), !1;
                    if ("string" != typeof d) return r(a, t(u)), !1;
                    break;
                case "location":
                    if (![
                        "main",
                        "sidebar"
                    ].includes(d)) return r(a, t(u)), !1;
                    break;
                case "controlledBy":
                    if ("*" !== d && "owners" !== d && (!Array.isArray(d) || d.some(function(e1) {
                        return "string" != typeof e1;
                    }))) return r(a, t(u)), !1;
                    break;
                case "shared":
                    if ((!Array.isArray(d) || d.some(function(e1) {
                        return "string" != typeof e1;
                    })) && "owners" !== d && "boolean" != typeof d) return r(a, t(u)), !1;
                    break;
                default:
                    if (!Ps.id[u]) return console.error("customIntegration does not support key ".concat(u)), !1;
            }
        }
    }
    return !0;
}
function ec(e1, t) {
    if (void 0 === t) return !1;
    switch(n(t)){
        case "string":
            return n(e1) === t;
        case "object":
            if ("object" !== n(e1)) return !1;
            for(var r in e1)if (!ec(e1[r], t[r])) return !1;
            return !0;
        default:
            return !1;
    }
}
function tc(e1, t) {
    var n = e1.sessionId, r = e1.toEndPoint, i = e1.useSipRefer;
    if (!n || !r) throw new Error("".concat(t, "() requires a sessionId and toEndPoint"));
    if ("string" != typeof n || "string" != typeof r) throw new Error("Invalid paramater: sessionId and toEndPoint must be of type string");
    if (i && !r.startsWith("sip:")) throw new Error('"toEndPoint" must be a "sip" address');
    if (!r.startsWith("sip:") && !r.startsWith("+")) throw new Error("toEndPoint: ".concat(r, ' must starts with either "sip:" or "+"'));
}
function nc(e1) {
    if ("object" !== n(e1)) throw new Error('RemoteMediaPlayerSettings: must be "object" type');
    if (e1.state && !Object.values(Yo).includes(e1.state)) throw new Error("Invalid value for RemoteMediaPlayerSettings.state, valid values are: " + JSON.stringify(Yo));
    if (e1.volume) {
        if ("number" != typeof e1.volume) throw new Error('RemoteMediaPlayerSettings.volume: must be "number" type');
        if (e1.volume < 0 || e1.volume > 2) throw new Error("RemoteMediaPlayerSettings.volume: must be between 0.0 - 2.0");
    }
}
function rc(e1, t, n) {
    return !("number" != typeof e1 || e1 < t || e1 > n);
}
function ic(e1, t) {
    return e1 && !t && delete e1.data, e1;
}
;
}}),
"[project]/node_modules/@vapi-ai/web/dist/api.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* eslint-disable */ /* tslint:disable */ /*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Api = exports.HttpClient = exports.ContentType = void 0;
var ContentType;
(function(ContentType) {
    ContentType["Json"] = "application/json";
    ContentType["FormData"] = "multipart/form-data";
    ContentType["UrlEncoded"] = "application/x-www-form-urlencoded";
    ContentType["Text"] = "text/plain";
})(ContentType || (exports.ContentType = ContentType = {}));
class HttpClient {
    baseUrl = 'https://api.vapi.ai';
    securityData = null;
    securityWorker;
    abortControllers = new Map();
    customFetch = (...fetchParams)=>fetch(...fetchParams);
    baseApiParams = {
        credentials: 'same-origin',
        headers: {},
        redirect: 'follow',
        referrerPolicy: 'no-referrer'
    };
    constructor(apiConfig = {}){
        Object.assign(this, apiConfig);
    }
    setSecurityData = (data)=>{
        this.securityData = data;
    };
    encodeQueryParam(key, value) {
        const encodedKey = encodeURIComponent(key);
        return `${encodedKey}=${encodeURIComponent(typeof value === 'number' ? value : `${value}`)}`;
    }
    addQueryParam(query, key) {
        return this.encodeQueryParam(key, query[key]);
    }
    addArrayQueryParam(query, key) {
        const value = query[key];
        return value.map((v)=>this.encodeQueryParam(key, v)).join('&');
    }
    toQueryString(rawQuery) {
        const query = rawQuery || {};
        const keys = Object.keys(query).filter((key)=>'undefined' !== typeof query[key]);
        return keys.map((key)=>Array.isArray(query[key]) ? this.addArrayQueryParam(query, key) : this.addQueryParam(query, key)).join('&');
    }
    addQueryParams(rawQuery) {
        const queryString = this.toQueryString(rawQuery);
        return queryString ? `?${queryString}` : '';
    }
    contentFormatters = {
        [ContentType.Json]: (input)=>input !== null && (typeof input === 'object' || typeof input === 'string') ? JSON.stringify(input) : input,
        [ContentType.Text]: (input)=>input !== null && typeof input !== 'string' ? JSON.stringify(input) : input,
        [ContentType.FormData]: (input)=>Object.keys(input || {}).reduce((formData, key)=>{
                const property = input[key];
                formData.append(key, property instanceof Blob ? property : typeof property === 'object' && property !== null ? JSON.stringify(property) : `${property}`);
                return formData;
            }, new FormData()),
        [ContentType.UrlEncoded]: (input)=>this.toQueryString(input)
    };
    mergeRequestParams(params1, params2) {
        return {
            ...this.baseApiParams,
            ...params1,
            ...params2 || {},
            headers: {
                ...this.baseApiParams.headers || {},
                ...params1.headers || {},
                ...params2 && params2.headers || {}
            }
        };
    }
    createAbortSignal = (cancelToken)=>{
        if (this.abortControllers.has(cancelToken)) {
            const abortController = this.abortControllers.get(cancelToken);
            if (abortController) {
                return abortController.signal;
            }
            return void 0;
        }
        const abortController = new AbortController();
        this.abortControllers.set(cancelToken, abortController);
        return abortController.signal;
    };
    abortRequest = (cancelToken)=>{
        const abortController = this.abortControllers.get(cancelToken);
        if (abortController) {
            abortController.abort();
            this.abortControllers.delete(cancelToken);
        }
    };
    request = async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params })=>{
        const secureParams = (typeof secure === 'boolean' ? secure : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {};
        const requestParams = this.mergeRequestParams(params, secureParams);
        const queryString = query && this.toQueryString(query);
        const payloadFormatter = this.contentFormatters[type || ContentType.Json];
        const responseFormat = format || requestParams.format;
        return this.customFetch(`${baseUrl || this.baseUrl || ''}${path}${queryString ? `?${queryString}` : ''}`, {
            ...requestParams,
            headers: {
                ...requestParams.headers || {},
                ...type && type !== ContentType.FormData ? {
                    'Content-Type': type
                } : {}
            },
            signal: (cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal) || null,
            body: typeof body === 'undefined' || body === null ? null : payloadFormatter(body)
        }).then(async (response)=>{
            const r = response;
            r.data = null;
            r.error = null;
            const data = !responseFormat ? r : await response[responseFormat]().then((data)=>{
                if (r.ok) {
                    r.data = data;
                } else {
                    r.error = data;
                }
                return r;
            }).catch((e)=>{
                r.error = e;
                return r;
            });
            if (cancelToken) {
                this.abortControllers.delete(cancelToken);
            }
            if (!response.ok) throw data;
            return data;
        });
    };
}
exports.HttpClient = HttpClient;
/**
 * @title Vapi API
 * @version 1.0
 * @baseUrl https://api.vapi.ai
 * @contact
 *
 * Voice AI for developers.
 */ class Api extends HttpClient {
    call = {
        /**
         * No description
         *
         * @tags Calls
         * @name CallControllerCreate
         * @summary Create Call
         * @request POST:/call
         * @secure
         */ callControllerCreate: (data, params = {})=>this.request({
                path: `/call`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Calls
         * @name CallControllerFindAll
         * @summary List Calls
         * @request GET:/call
         * @secure
         */ callControllerFindAll: (query, params = {})=>this.request({
                path: `/call`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Calls
         * @name CallControllerFindOne
         * @summary Get Call
         * @request GET:/call/{id}
         * @secure
         */ callControllerFindOne: (id, params = {})=>this.request({
                path: `/call/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Calls
         * @name CallControllerUpdate
         * @summary Update Call
         * @request PATCH:/call/{id}
         * @secure
         */ callControllerUpdate: (id, data, params = {})=>this.request({
                path: `/call/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Calls
         * @name CallControllerDeleteCallData
         * @summary Delete Call Data
         * @request DELETE:/call/{id}
         * @secure
         */ callControllerDeleteCallData: (id, params = {})=>this.request({
                path: `/call/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Calls
         * @name CallControllerCreatePhoneCall
         * @summary Create Phone Call
         * @request POST:/call/phone
         * @deprecated
         * @secure
         */ callControllerCreatePhoneCall: (data, params = {})=>this.request({
                path: `/call/phone`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Calls
         * @name CallControllerCreateWebCall
         * @summary Create Web Call
         * @request POST:/call/web
         * @secure
         */ callControllerCreateWebCall: (data, params = {})=>this.request({
                path: `/call/web`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            })
    };
    v2 = {
        /**
         * No description
         *
         * @tags Calls
         * @name CallControllerFindAllPaginated
         * @summary List Calls
         * @request GET:/v2/call
         * @secure
         */ callControllerFindAllPaginated: (query, params = {})=>this.request({
                path: `/v2/call`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Calls
         * @name CallControllerFindAllMetadataPaginated
         * @summary List Call Metadata
         * @request GET:/v2/call/metadata
         * @secure
         */ callControllerFindAllMetadataPaginated: (query, params = {})=>this.request({
                path: `/v2/call/metadata`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Assistants
         * @name AssistantControllerFindAllPaginated
         * @summary List Assistants with pagination
         * @request GET:/v2/assistant
         * @secure
         */ assistantControllerFindAllPaginated: (query, params = {})=>this.request({
                path: `/v2/assistant`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Phone Numbers
         * @name PhoneNumberControllerFindAllPaginated
         * @summary List Phone Numbers
         * @request GET:/v2/phone-number
         * @secure
         */ phoneNumberControllerFindAllPaginated: (query, params = {})=>this.request({
                path: `/v2/phone-number`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            })
    };
    chat = {
        /**
         * No description
         *
         * @tags Chat
         * @name ChatController
         * @summary Chat with Assistant
         * @request POST:/chat
         * @deprecated
         * @secure
         */ chatController: (params = {})=>this.request({
                path: `/chat`,
                method: 'POST',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Chat
         * @name ChatControllerChatCompletions
         * @summary Chat with a Workflow
         * @request POST:/chat/completions
         * @secure
         */ chatControllerChatCompletions: (data, params = {})=>this.request({
                path: `/chat/completions`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            })
    };
    assistant = {
        /**
         * No description
         *
         * @tags Assistants
         * @name AssistantControllerCreate
         * @summary Create Assistant
         * @request POST:/assistant
         * @secure
         */ assistantControllerCreate: (data, params = {})=>this.request({
                path: `/assistant`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Assistants
         * @name AssistantControllerFindAll
         * @summary List Assistants
         * @request GET:/assistant
         * @secure
         */ assistantControllerFindAll: (query, params = {})=>this.request({
                path: `/assistant`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Assistants
         * @name AssistantControllerFindOne
         * @summary Get Assistant
         * @request GET:/assistant/{id}
         * @secure
         */ assistantControllerFindOne: (id, params = {})=>this.request({
                path: `/assistant/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Assistants
         * @name AssistantControllerUpdate
         * @summary Update Assistant
         * @request PATCH:/assistant/{id}
         * @secure
         */ assistantControllerUpdate: (id, data, params = {})=>this.request({
                path: `/assistant/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Assistants
         * @name AssistantControllerReplace
         * @summary Replace Assistant
         * @request PUT:/assistant/{id}
         * @secure
         */ assistantControllerReplace: (id, data, params = {})=>this.request({
                path: `/assistant/${id}`,
                method: 'PUT',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Assistants
         * @name AssistantControllerRemove
         * @summary Delete Assistant
         * @request DELETE:/assistant/{id}
         * @secure
         */ assistantControllerRemove: (id, params = {})=>this.request({
                path: `/assistant/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            })
    };
    phoneNumber = {
        /**
         * @description Use POST /phone-number instead.
         *
         * @tags Phone Numbers
         * @name PhoneNumberControllerImportTwilio
         * @summary Import Twilio Number
         * @request POST:/phone-number/import/twilio
         * @deprecated
         * @secure
         */ phoneNumberControllerImportTwilio: (data, params = {})=>this.request({
                path: `/phone-number/import/twilio`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * @description Use POST /phone-number instead.
         *
         * @tags Phone Numbers
         * @name PhoneNumberControllerImportVonage
         * @summary Import Vonage Number
         * @request POST:/phone-number/import/vonage
         * @deprecated
         * @secure
         */ phoneNumberControllerImportVonage: (data, params = {})=>this.request({
                path: `/phone-number/import/vonage`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Phone Numbers
         * @name PhoneNumberControllerCreate
         * @summary Create Phone Number
         * @request POST:/phone-number
         * @secure
         */ phoneNumberControllerCreate: (data, params = {})=>this.request({
                path: `/phone-number`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Phone Numbers
         * @name PhoneNumberControllerFindAll
         * @summary List Phone Numbers
         * @request GET:/phone-number
         * @secure
         */ phoneNumberControllerFindAll: (query, params = {})=>this.request({
                path: `/phone-number`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Phone Numbers
         * @name PhoneNumberControllerFindOne
         * @summary Get Phone Number
         * @request GET:/phone-number/{id}
         * @secure
         */ phoneNumberControllerFindOne: (id, params = {})=>this.request({
                path: `/phone-number/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Phone Numbers
         * @name PhoneNumberControllerUpdate
         * @summary Update Phone Number
         * @request PATCH:/phone-number/{id}
         * @secure
         */ phoneNumberControllerUpdate: (id, data, params = {})=>this.request({
                path: `/phone-number/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Phone Numbers
         * @name PhoneNumberControllerRemove
         * @summary Delete Phone Number
         * @request DELETE:/phone-number/{id}
         * @secure
         */ phoneNumberControllerRemove: (id, params = {})=>this.request({
                path: `/phone-number/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            })
    };
    tool = {
        /**
         * No description
         *
         * @tags Tools
         * @name ToolControllerCreate
         * @summary Create Tool
         * @request POST:/tool
         * @secure
         */ toolControllerCreate: (data, params = {})=>this.request({
                path: `/tool`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Tools
         * @name ToolControllerFindAll
         * @summary List Tools
         * @request GET:/tool
         * @secure
         */ toolControllerFindAll: (query, params = {})=>this.request({
                path: `/tool`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Tools
         * @name ToolControllerFindOne
         * @summary Get Tool
         * @request GET:/tool/{id}
         * @secure
         */ toolControllerFindOne: (id, params = {})=>this.request({
                path: `/tool/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Tools
         * @name ToolControllerUpdate
         * @summary Update Tool
         * @request PATCH:/tool/{id}
         * @secure
         */ toolControllerUpdate: (id, data, params = {})=>this.request({
                path: `/tool/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Tools
         * @name ToolControllerRemove
         * @summary Delete Tool
         * @request DELETE:/tool/{id}
         * @secure
         */ toolControllerRemove: (id, params = {})=>this.request({
                path: `/tool/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            })
    };
    file = {
        /**
         * @description Use POST /file instead.
         *
         * @tags Files
         * @name FileControllerCreateDeprecated
         * @summary Upload File
         * @request POST:/file/upload
         * @deprecated
         * @secure
         */ fileControllerCreateDeprecated: (data, params = {})=>this.request({
                path: `/file/upload`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.FormData,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Files
         * @name FileControllerCreate
         * @summary Upload File
         * @request POST:/file
         * @secure
         */ fileControllerCreate: (data, params = {})=>this.request({
                path: `/file`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.FormData,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Files
         * @name FileControllerFindAll
         * @summary List Files
         * @request GET:/file
         * @secure
         */ fileControllerFindAll: (params = {})=>this.request({
                path: `/file`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Files
         * @name FileControllerFindOne
         * @summary Get File
         * @request GET:/file/{id}
         * @secure
         */ fileControllerFindOne: (id, params = {})=>this.request({
                path: `/file/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Files
         * @name FileControllerUpdate
         * @summary Update File
         * @request PATCH:/file/{id}
         * @secure
         */ fileControllerUpdate: (id, data, params = {})=>this.request({
                path: `/file/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Files
         * @name FileControllerRemove
         * @summary Delete File
         * @request DELETE:/file/{id}
         * @secure
         */ fileControllerRemove: (id, params = {})=>this.request({
                path: `/file/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            })
    };
    knowledgeBase = {
        /**
         * No description
         *
         * @tags Knowledge Base
         * @name KnowledgeBaseControllerCreate
         * @summary Create Knowledge Base
         * @request POST:/knowledge-base
         * @secure
         */ knowledgeBaseControllerCreate: (data, params = {})=>this.request({
                path: `/knowledge-base`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Knowledge Base
         * @name KnowledgeBaseControllerFindAll
         * @summary List Knowledge Bases
         * @request GET:/knowledge-base
         * @secure
         */ knowledgeBaseControllerFindAll: (query, params = {})=>this.request({
                path: `/knowledge-base`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Knowledge Base
         * @name KnowledgeBaseControllerFindOne
         * @summary Get Knowledge Base
         * @request GET:/knowledge-base/{id}
         * @secure
         */ knowledgeBaseControllerFindOne: (id, params = {})=>this.request({
                path: `/knowledge-base/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Knowledge Base
         * @name KnowledgeBaseControllerUpdate
         * @summary Update Knowledge Base
         * @request PATCH:/knowledge-base/{id}
         * @secure
         */ knowledgeBaseControllerUpdate: (id, data, params = {})=>this.request({
                path: `/knowledge-base/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Knowledge Base
         * @name KnowledgeBaseControllerRemove
         * @summary Delete Knowledge Base
         * @request DELETE:/knowledge-base/{id}
         * @secure
         */ knowledgeBaseControllerRemove: (id, params = {})=>this.request({
                path: `/knowledge-base/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            })
    };
    workflow = {
        /**
         * No description
         *
         * @tags Workflow
         * @name WorkflowControllerFindAll
         * @summary Get Workflows
         * @request GET:/workflow
         * @secure
         */ workflowControllerFindAll: (params = {})=>this.request({
                path: `/workflow`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Workflow
         * @name WorkflowControllerCreate
         * @summary Create Workflow
         * @request POST:/workflow
         * @secure
         */ workflowControllerCreate: (data, params = {})=>this.request({
                path: `/workflow`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Workflow
         * @name WorkflowControllerFindOne
         * @summary Get Workflow
         * @request GET:/workflow/{id}
         * @secure
         */ workflowControllerFindOne: (id, params = {})=>this.request({
                path: `/workflow/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Workflow
         * @name WorkflowControllerDelete
         * @summary Delete Workflow
         * @request DELETE:/workflow/{id}
         * @secure
         */ workflowControllerDelete: (id, params = {})=>this.request({
                path: `/workflow/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Workflow
         * @name WorkflowControllerUpdate
         * @summary Update Workflow
         * @request PATCH:/workflow/{id}
         * @secure
         */ workflowControllerUpdate: (id, data, params = {})=>this.request({
                path: `/workflow/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            })
    };
    squad = {
        /**
         * No description
         *
         * @tags Squads
         * @name SquadControllerCreate
         * @summary Create Squad
         * @request POST:/squad
         * @secure
         */ squadControllerCreate: (data, params = {})=>this.request({
                path: `/squad`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Squads
         * @name SquadControllerFindAll
         * @summary List Squads
         * @request GET:/squad
         * @secure
         */ squadControllerFindAll: (query, params = {})=>this.request({
                path: `/squad`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Squads
         * @name SquadControllerFindOne
         * @summary Get Squad
         * @request GET:/squad/{id}
         * @secure
         */ squadControllerFindOne: (id, params = {})=>this.request({
                path: `/squad/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Squads
         * @name SquadControllerUpdate
         * @summary Update Squad
         * @request PATCH:/squad/{id}
         * @secure
         */ squadControllerUpdate: (id, data, params = {})=>this.request({
                path: `/squad/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Squads
         * @name SquadControllerRemove
         * @summary Delete Squad
         * @request DELETE:/squad/{id}
         * @secure
         */ squadControllerRemove: (id, params = {})=>this.request({
                path: `/squad/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            })
    };
    testSuite = {
        /**
         * No description
         *
         * @tags Test Suites
         * @name TestSuiteControllerFindAllPaginated
         * @summary List Test Suites
         * @request GET:/test-suite
         * @secure
         */ testSuiteControllerFindAllPaginated: (query, params = {})=>this.request({
                path: `/test-suite`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suites
         * @name TestSuiteControllerCreate
         * @summary Create Test Suite
         * @request POST:/test-suite
         * @secure
         */ testSuiteControllerCreate: (data, params = {})=>this.request({
                path: `/test-suite`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suites
         * @name TestSuiteControllerFindOne
         * @summary Get Test Suite
         * @request GET:/test-suite/{id}
         * @secure
         */ testSuiteControllerFindOne: (id, params = {})=>this.request({
                path: `/test-suite/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suites
         * @name TestSuiteControllerUpdate
         * @summary Update Test Suite
         * @request PATCH:/test-suite/{id}
         * @secure
         */ testSuiteControllerUpdate: (id, data, params = {})=>this.request({
                path: `/test-suite/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suites
         * @name TestSuiteControllerRemove
         * @summary Delete Test Suite
         * @request DELETE:/test-suite/{id}
         * @secure
         */ testSuiteControllerRemove: (id, params = {})=>this.request({
                path: `/test-suite/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suite Tests
         * @name TestSuiteTestControllerFindAllPaginated
         * @summary List Tests
         * @request GET:/test-suite/{testSuiteId}/test
         * @secure
         */ testSuiteTestControllerFindAllPaginated: (testSuiteId, query, params = {})=>this.request({
                path: `/test-suite/${testSuiteId}/test`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suite Tests
         * @name TestSuiteTestControllerCreate
         * @summary Create Test
         * @request POST:/test-suite/{testSuiteId}/test
         * @secure
         */ testSuiteTestControllerCreate: (testSuiteId, data, params = {})=>this.request({
                path: `/test-suite/${testSuiteId}/test`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suite Tests
         * @name TestSuiteTestControllerFindOne
         * @summary Get Test
         * @request GET:/test-suite/{testSuiteId}/test/{id}
         * @secure
         */ testSuiteTestControllerFindOne: (testSuiteId, id, params = {})=>this.request({
                path: `/test-suite/${testSuiteId}/test/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suite Tests
         * @name TestSuiteTestControllerUpdate
         * @summary Update Test
         * @request PATCH:/test-suite/{testSuiteId}/test/{id}
         * @secure
         */ testSuiteTestControllerUpdate: (testSuiteId, id, data, params = {})=>this.request({
                path: `/test-suite/${testSuiteId}/test/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suite Tests
         * @name TestSuiteTestControllerRemove
         * @summary Delete Test
         * @request DELETE:/test-suite/{testSuiteId}/test/{id}
         * @secure
         */ testSuiteTestControllerRemove: (testSuiteId, id, params = {})=>this.request({
                path: `/test-suite/${testSuiteId}/test/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suite Runs
         * @name TestSuiteRunControllerFindAllPaginated
         * @summary List Test Suite Runs
         * @request GET:/test-suite/{testSuiteId}/run
         * @secure
         */ testSuiteRunControllerFindAllPaginated: (testSuiteId, query, params = {})=>this.request({
                path: `/test-suite/${testSuiteId}/run`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suite Runs
         * @name TestSuiteRunControllerCreate
         * @summary Create Test Suite Run
         * @request POST:/test-suite/{testSuiteId}/run
         * @secure
         */ testSuiteRunControllerCreate: (testSuiteId, data, params = {})=>this.request({
                path: `/test-suite/${testSuiteId}/run`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suite Runs
         * @name TestSuiteRunControllerFindOne
         * @summary Get Test Suite Run
         * @request GET:/test-suite/{testSuiteId}/run/{id}
         * @secure
         */ testSuiteRunControllerFindOne: (testSuiteId, id, params = {})=>this.request({
                path: `/test-suite/${testSuiteId}/run/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suite Runs
         * @name TestSuiteRunControllerUpdate
         * @summary Update Test Suite Run
         * @request PATCH:/test-suite/{testSuiteId}/run/{id}
         * @secure
         */ testSuiteRunControllerUpdate: (testSuiteId, id, data, params = {})=>this.request({
                path: `/test-suite/${testSuiteId}/run/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Test Suite Runs
         * @name TestSuiteRunControllerRemove
         * @summary Delete Test Suite Run
         * @request DELETE:/test-suite/{testSuiteId}/run/{id}
         * @secure
         */ testSuiteRunControllerRemove: (testSuiteId, id, params = {})=>this.request({
                path: `/test-suite/${testSuiteId}/run/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            })
    };
    metrics = {
        /**
         * @description Use GET /metric instead
         *
         * @tags Analytics
         * @name AnalyticsControllerFindAllDeprecated
         * @summary List Billing Metrics
         * @request GET:/metrics
         * @deprecated
         * @secure
         */ analyticsControllerFindAllDeprecated: (query, params = {})=>this.request({
                path: `/metrics`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            })
    };
    analytics = {
        /**
         * No description
         *
         * @tags Analytics
         * @name AnalyticsControllerQuery
         * @summary Create Analytics Queries
         * @request POST:/analytics
         * @secure
         */ analyticsControllerQuery: (data, params = {})=>this.request({
                path: `/analytics`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            })
    };
    log = {
        /**
         * No description
         *
         * @tags Logs
         * @name LoggingControllerCallLogsQuery
         * @summary Get Call Logs
         * @request GET:/log
         * @secure
         */ loggingControllerCallLogsQuery: (query, params = {})=>this.request({
                path: `/log`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Logs
         * @name LoggingControllerCallLogsDeleteQuery
         * @summary Delete Call Logs
         * @request DELETE:/log
         * @secure
         */ loggingControllerCallLogsDeleteQuery: (query, params = {})=>this.request({
                path: `/log`,
                method: 'DELETE',
                query: query,
                secure: true,
                ...params
            })
    };
    logs = {
        /**
         * No description
         *
         * @tags Logs
         * @name LoggingControllerLogsQuery
         * @summary Get Logs
         * @request GET:/logs
         * @deprecated
         * @secure
         */ loggingControllerLogsQuery: (query, params = {})=>this.request({
                path: `/logs`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Logs
         * @name LoggingControllerLogsDeleteQuery
         * @summary Delete Logs
         * @request DELETE:/logs
         * @deprecated
         * @secure
         */ loggingControllerLogsDeleteQuery: (query, params = {})=>this.request({
                path: `/logs`,
                method: 'DELETE',
                query: query,
                secure: true,
                ...params
            })
    };
    org = {
        /**
         * No description
         *
         * @tags Orgs
         * @name OrgControllerCreate
         * @summary Create Org
         * @request POST:/org
         * @secure
         */ orgControllerCreate: (data, params = {})=>this.request({
                path: `/org`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Orgs
         * @name OrgControllerFindAll
         * @summary List Orgs
         * @request GET:/org
         * @secure
         */ orgControllerFindAll: (params = {})=>this.request({
                path: `/org`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Orgs
         * @name OrgControllerFindOne
         * @summary Get Org
         * @request GET:/org/{id}
         * @secure
         */ orgControllerFindOne: (id, params = {})=>this.request({
                path: `/org/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Orgs
         * @name OrgControllerUpdate
         * @summary Update Org
         * @request PATCH:/org/{id}
         * @secure
         */ orgControllerUpdate: (id, data, params = {})=>this.request({
                path: `/org/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Orgs
         * @name OrgControllerDeleteOrg
         * @summary Delete Org
         * @request DELETE:/org/{id}
         * @secure
         */ orgControllerDeleteOrg: (id, params = {})=>this.request({
                path: `/org/${id}`,
                method: 'DELETE',
                secure: true,
                ...params
            }),
        /**
         * No description
         *
         * @tags Orgs
         * @name OrgControllerFindAllUsers
         * @summary List Users
         * @request GET:/org/{id}/user
         * @secure
         */ orgControllerFindAllUsers: (id, params = {})=>this.request({
                path: `/org/${id}/user`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Orgs
         * @name OrgControllerOrgLeave
         * @summary Leave Org
         * @request DELETE:/org/{id}/leave
         * @secure
         */ orgControllerOrgLeave: (id, params = {})=>this.request({
                path: `/org/${id}/leave`,
                method: 'DELETE',
                secure: true,
                ...params
            }),
        /**
         * No description
         *
         * @tags Orgs
         * @name OrgControllerOrgRemoveUser
         * @summary Remove Org Member
         * @request DELETE:/org/{id}/member/{memberId}/leave
         * @secure
         */ orgControllerOrgRemoveUser: (id, memberId, params = {})=>this.request({
                path: `/org/${id}/member/${memberId}/leave`,
                method: 'DELETE',
                secure: true,
                ...params
            }),
        /**
         * No description
         *
         * @tags Orgs
         * @name OrgControllerUsersInvite
         * @summary Invite User
         * @request POST:/org/{id}/invite
         * @secure
         */ orgControllerUsersInvite: (id, data, params = {})=>this.request({
                path: `/org/${id}/invite`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                ...params
            }),
        /**
         * No description
         *
         * @tags Orgs
         * @name OrgControllerUserUpdate
         * @summary Update User Role
         * @request PATCH:/org/{id}/role
         * @secure
         */ orgControllerUserUpdate: (id, data, params = {})=>this.request({
                path: `/org/${id}/role`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                ...params
            })
    };
    token = {
        /**
         * No description
         *
         * @tags Tokens
         * @name TokenControllerCreate
         * @summary Create Token
         * @request POST:/token
         * @secure
         */ tokenControllerCreate: (data, params = {})=>this.request({
                path: `/token`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Tokens
         * @name TokenControllerFindAll
         * @summary List Tokens
         * @request GET:/token
         * @secure
         */ tokenControllerFindAll: (query, params = {})=>this.request({
                path: `/token`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Tokens
         * @name TokenControllerFindOne
         * @summary Get Token
         * @request GET:/token/{id}
         * @secure
         */ tokenControllerFindOne: (id, params = {})=>this.request({
                path: `/token/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Tokens
         * @name TokenControllerUpdate
         * @summary Update Token
         * @request PATCH:/token/{id}
         * @secure
         */ tokenControllerUpdate: (id, data, params = {})=>this.request({
                path: `/token/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Tokens
         * @name TokenControllerRemove
         * @summary Delete Token
         * @request DELETE:/token/{id}
         * @secure
         */ tokenControllerRemove: (id, params = {})=>this.request({
                path: `/token/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            })
    };
    credential = {
        /**
         * No description
         *
         * @tags Credentials
         * @name CredentialControllerCreate
         * @summary Create Credential
         * @request POST:/credential
         * @secure
         */ credentialControllerCreate: (data, params = {})=>this.request({
                path: `/credential`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Credentials
         * @name CredentialControllerFindAll
         * @summary List Credentials
         * @request GET:/credential
         * @secure
         */ credentialControllerFindAll: (query, params = {})=>this.request({
                path: `/credential`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Credentials
         * @name CredentialControllerFindOne
         * @summary Get Credential
         * @request GET:/credential/{id}
         * @secure
         */ credentialControllerFindOne: (id, params = {})=>this.request({
                path: `/credential/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Credentials
         * @name CredentialControllerUpdate
         * @summary Update Credential
         * @request PATCH:/credential/{id}
         * @secure
         */ credentialControllerUpdate: (id, data, params = {})=>this.request({
                path: `/credential/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Credentials
         * @name CredentialControllerRemove
         * @summary Delete Credential
         * @request DELETE:/credential/{id}
         * @secure
         */ credentialControllerRemove: (id, params = {})=>this.request({
                path: `/credential/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            })
    };
    template = {
        /**
         * No description
         *
         * @tags Templates
         * @name TemplateControllerCreate
         * @summary Create Template
         * @request POST:/template
         * @secure
         */ templateControllerCreate: (data, params = {})=>this.request({
                path: `/template`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Templates
         * @name TemplateControllerFindAll
         * @summary List Templates
         * @request GET:/template
         * @secure
         */ templateControllerFindAll: (query, params = {})=>this.request({
                path: `/template`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Templates
         * @name TemplateControllerFindAllPinned
         * @summary List Templates
         * @request GET:/template/pinned
         * @secure
         */ templateControllerFindAllPinned: (params = {})=>this.request({
                path: `/template/pinned`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Templates
         * @name TemplateControllerFindOne
         * @summary Get Template
         * @request GET:/template/{id}
         * @secure
         */ templateControllerFindOne: (id, params = {})=>this.request({
                path: `/template/${id}`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Templates
         * @name TemplateControllerUpdate
         * @summary Update Template
         * @request PATCH:/template/{id}
         * @secure
         */ templateControllerUpdate: (id, data, params = {})=>this.request({
                path: `/template/${id}`,
                method: 'PATCH',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Templates
         * @name TemplateControllerRemove
         * @summary Delete Template
         * @request DELETE:/template/{id}
         * @secure
         */ templateControllerRemove: (id, params = {})=>this.request({
                path: `/template/${id}`,
                method: 'DELETE',
                secure: true,
                format: 'json',
                ...params
            })
    };
    voiceLibrary = {
        /**
         * No description
         *
         * @tags Voice Library
         * @name VoiceLibraryControllerVoiceGetByProvider
         * @summary Get voices in Voice Library by Provider
         * @request GET:/voice-library/{provider}
         * @secure
         */ voiceLibraryControllerVoiceGetByProvider: (provider, query, params = {})=>this.request({
                path: `/voice-library/${provider}`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Voice Library
         * @name VoiceLibraryControllerVoiceGetAccentsByProvider
         * @summary Get accents in Voice Library by Provider
         * @request GET:/voice-library/{provider}/accents
         * @secure
         */ voiceLibraryControllerVoiceGetAccentsByProvider: (provider, params = {})=>this.request({
                path: `/voice-library/${provider}/accents`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Voice Library
         * @name VoiceLibraryControllerVoiceLibrarySyncByProvider
         * @summary Sync Private voices in Voice Library by Provider
         * @request POST:/voice-library/sync/{provider}
         * @secure
         */ voiceLibraryControllerVoiceLibrarySyncByProvider: (provider, params = {})=>this.request({
                path: `/voice-library/sync/${provider}`,
                method: 'POST',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Voice Library
         * @name VoiceLibraryControllerVoiceLibrarySyncDefaultVoices
         * @summary Sync Default voices in Voice Library by Providers
         * @request POST:/voice-library/sync
         * @secure
         */ voiceLibraryControllerVoiceLibrarySyncDefaultVoices: (data, params = {})=>this.request({
                path: `/voice-library/sync`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            })
    };
    provider = {
        /**
         * No description
         *
         * @tags Providers
         * @name ProviderControllerGetWorkflows
         * @request GET:/{provider}/workflows
         * @secure
         */ providerControllerGetWorkflows: (provider, query, params = {})=>this.request({
                path: `/${provider}/workflows`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Providers
         * @name ProviderControllerGetWorkflowTriggerHook
         * @request GET:/{provider}/workflows/{workflowId}/hooks
         * @secure
         */ providerControllerGetWorkflowTriggerHook: (provider, workflowId, params = {})=>this.request({
                path: `/${provider}/workflows/${workflowId}/hooks`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Providers
         * @name ProviderControllerGetLocations
         * @request GET:/{provider}/locations
         * @secure
         */ providerControllerGetLocations: (provider, params = {})=>this.request({
                path: `/${provider}/locations`,
                method: 'GET',
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Providers
         * @name VoiceProviderControllerSearchVoices
         * @summary Search Voice from Provider Voice Library.
         * @request GET:/{provider}/voices/search
         * @deprecated
         * @secure
         */ voiceProviderControllerSearchVoices: (provider, query, params = {})=>this.request({
                path: `/${provider}/voices/search`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Providers
         * @name VoiceProviderControllerSearchVoice
         * @summary Search Voice from Provider Voice Library.
         * @request GET:/{provider}/voice/search
         * @secure
         */ voiceProviderControllerSearchVoice: (provider, query, params = {})=>this.request({
                path: `/${provider}/voice/search`,
                method: 'GET',
                query: query,
                secure: true,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Providers
         * @name VoiceProviderControllerAddVoices
         * @summary Add Shared Voice to your Provider Account.
         * @request POST:/{provider}/voices/add
         * @deprecated
         * @secure
         */ voiceProviderControllerAddVoices: (provider, data, params = {})=>this.request({
                path: `/${provider}/voices/add`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            }),
        /**
         * No description
         *
         * @tags Providers
         * @name VoiceProviderControllerAddVoice
         * @summary Add Shared Voice to your Provider Account.
         * @request POST:/{provider}/voice/add
         * @secure
         */ voiceProviderControllerAddVoice: (provider, data, params = {})=>this.request({
                path: `/${provider}/voice/add`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.Json,
                format: 'json',
                ...params
            })
    };
    v11Labs = {
        /**
         * No description
         *
         * @tags Providers
         * @name VoiceProviderControllerCloneVoices
         * @summary Clone a voice to the provider account and add to Vapi Voice Library.
         * @request POST:/11labs/voice/clone
         * @secure
         */ voiceProviderControllerCloneVoices: (data, params = {})=>this.request({
                path: `/11labs/voice/clone`,
                method: 'POST',
                body: data,
                secure: true,
                type: ContentType.FormData,
                ...params
            })
    };
}
exports.Api = Api;
}}),
"[project]/node_modules/@vapi-ai/web/dist/client.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.client = void 0;
const api_1 = __turbopack_context__.r("[project]/node_modules/@vapi-ai/web/dist/api.js [app-ssr] (ecmascript)");
const api = new api_1.Api({
    baseUrl: "https://api.vapi.ai",
    baseApiParams: {
        secure: true
    },
    securityWorker: async (securityData)=>{
        if (securityData) {
            return {
                headers: {
                    Authorization: `Bearer ${securityData}`
                }
            };
        }
    }
});
exports.client = api;
}}),
"[project]/node_modules/@vapi-ai/web/dist/vapi.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const daily_js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@daily-co/daily-js/dist/daily-esm.js [app-ssr] (ecmascript)"));
const events_1 = __importDefault(__turbopack_context__.r("[externals]/events [external] (events, cjs)"));
const client_1 = __turbopack_context__.r("[project]/node_modules/@vapi-ai/web/dist/client.js [app-ssr] (ecmascript)");
async function startAudioPlayer(player, track) {
    player.muted = false;
    player.autoplay = true;
    if (track != null) {
        player.srcObject = new MediaStream([
            track
        ]);
        await player.play();
    }
}
async function buildAudioPlayer(track, participantId) {
    const player = document.createElement('audio');
    player.dataset.participantId = participantId;
    document.body.appendChild(player);
    await startAudioPlayer(player, track);
    return player;
}
function destroyAudioPlayer(participantId) {
    const player = document.querySelector(`audio[data-participant-id="${participantId}"]`);
    player?.remove();
}
function subscribeToTracks(e, call, isVideoRecordingEnabled, isVideoEnabled) {
    if (e.participant.local) return;
    call.updateParticipant(e.participant.session_id, {
        setSubscribedTracks: {
            audio: true,
            video: isVideoRecordingEnabled || isVideoEnabled
        }
    });
}
class VapiEventEmitter extends events_1.default {
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    once(event, listener) {
        super.once(event, listener);
        return this;
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    removeListener(event, listener) {
        super.removeListener(event, listener);
        return this;
    }
    removeAllListeners(event) {
        super.removeAllListeners(event);
        return this;
    }
}
class Vapi extends VapiEventEmitter {
    started = false;
    call = null;
    speakingTimeout = null;
    dailyCallConfig = {};
    dailyCallObject = {};
    hasEmittedCallEndedStatus = false;
    constructor(apiToken, apiBaseUrl, dailyCallConfig, dailyCallObject){
        super();
        client_1.client.baseUrl = apiBaseUrl ?? 'https://api.vapi.ai';
        client_1.client.setSecurityData(apiToken);
        this.dailyCallConfig = dailyCallConfig ?? {};
        this.dailyCallObject = dailyCallObject ?? {};
    }
    cleanup() {
        this.started = false;
        this.hasEmittedCallEndedStatus = false;
        this.call?.destroy();
        this.call = null;
        this.speakingTimeout = null;
    }
    isMobileDevice() {
        if (typeof navigator === 'undefined') {
            return false;
        }
        const userAgent = navigator.userAgent;
        return /android|iphone|ipad|ipod|iemobile|blackberry|bada/i.test(userAgent.toLowerCase());
    }
    async sleep(ms) {
        return new Promise((resolve)=>setTimeout(resolve, ms));
    }
    async start(assistant, assistantOverrides, squad) {
        if (!assistant && !squad) {
            throw new Error('Assistant or Squad must be provided.');
        }
        if (this.started) {
            return null;
        }
        this.started = true;
        try {
            const webCall = (await client_1.client.call.callControllerCreateWebCall({
                assistant: typeof assistant === 'string' ? undefined : assistant,
                assistantId: typeof assistant === 'string' ? assistant : undefined,
                assistantOverrides,
                squad: typeof squad === 'string' ? undefined : squad,
                squadId: typeof squad === 'string' ? squad : undefined
            })).data;
            if (this.call) {
                this.cleanup();
            }
            const isVideoRecordingEnabled = webCall?.artifactPlan?.videoRecordingEnabled ?? false;
            const isVideoEnabled = webCall.transport?.assistantVideoEnabled ?? false;
            this.call = daily_js_1.default.createCallObject({
                audioSource: this.dailyCallObject.audioSource ?? true,
                videoSource: this.dailyCallObject.videoSource ?? isVideoRecordingEnabled,
                dailyConfig: this.dailyCallConfig
            });
            this.call.iframe()?.style.setProperty('display', 'none');
            this.call.on('left-meeting', ()=>{
                this.emit('call-end');
                if (!this.hasEmittedCallEndedStatus) {
                    this.emit('message', {
                        type: 'status-update',
                        status: 'ended',
                        'endedReason': 'customer-ended-call'
                    });
                    this.hasEmittedCallEndedStatus = true;
                }
                if (isVideoRecordingEnabled) {
                    this.call?.stopRecording();
                }
                this.cleanup();
            });
            this.call.on('error', (error)=>{
                this.emit('error', error);
                if (isVideoRecordingEnabled) {
                    this.call?.stopRecording();
                }
            });
            this.call.on('camera-error', (error)=>{
                this.emit('error', error);
            });
            this.call.on('track-started', async (e)=>{
                if (!e || !e.participant) {
                    return;
                }
                if (e.participant?.local) {
                    return;
                }
                if (e.participant?.user_name !== 'Vapi Speaker') {
                    return;
                }
                if (e.track.kind === 'video') {
                    this.emit('video', e.track);
                }
                if (e.track.kind === 'audio') {
                    await buildAudioPlayer(e.track, e.participant.session_id);
                }
                this.call?.sendAppMessage('playable');
            });
            this.call.on('participant-joined', (e)=>{
                if (!e || !this.call) return;
                subscribeToTracks(e, this.call, isVideoRecordingEnabled, isVideoEnabled);
            });
            this.call.on('participant-updated', (e)=>{
                if (!e) {
                    return;
                }
                this.emit('daily-participant-updated', e.participant);
            });
            this.call.on('participant-left', (e)=>{
                if (!e) {
                    return;
                }
                destroyAudioPlayer(e.participant.session_id);
            });
            // Allow mobile devices to finish processing the microphone permissions
            // request before joining the call and playing the assistant's audio
            if (this.isMobileDevice()) {
                await this.sleep(1000);
            }
            await this.call.join({
                // @ts-expect-error This exists
                url: webCall.webCallUrl,
                subscribeToTracksAutomatically: false
            });
            if (isVideoRecordingEnabled) {
                const recordingRequestedTime = new Date().getTime();
                this.call.startRecording({
                    width: 1280,
                    height: 720,
                    backgroundColor: '#FF1F2D3D',
                    layout: {
                        preset: 'default'
                    }
                });
                this.call.on('recording-started', ()=>{
                    this.send({
                        type: 'control',
                        control: 'say-first-message',
                        videoRecordingStartDelaySeconds: (new Date().getTime() - recordingRequestedTime) / 1000
                    });
                });
            }
            this.call.startRemoteParticipantsAudioLevelObserver(100);
            this.call.on('remote-participants-audio-level', (e)=>{
                if (e) this.handleRemoteParticipantsAudioLevel(e);
            });
            this.call.on('app-message', (e)=>this.onAppMessage(e));
            this.call.on('nonfatal-error', (e)=>{
                // https://docs.daily.co/reference/daily-js/events/meeting-events#type-audio-processor-error
                if (e?.type === 'audio-processor-error') {
                    this.call?.updateInputSettings({
                        audio: {
                            processor: {
                                type: 'none'
                            }
                        }
                    }).then(()=>{
                        this.call?.setLocalAudio(true);
                    });
                }
            });
            this.call.updateInputSettings({
                audio: {
                    processor: {
                        type: 'noise-cancellation'
                    }
                }
            });
            return webCall;
        } catch (e) {
            console.error(e);
            this.emit('error', e);
            this.cleanup();
            return null;
        }
    }
    onAppMessage(e) {
        if (!e) {
            return;
        }
        try {
            if (e.data === 'listening') {
                return this.emit('call-start');
            } else {
                try {
                    const parsedMessage = JSON.parse(e.data);
                    this.emit('message', parsedMessage);
                    if (parsedMessage && 'type' in parsedMessage && 'status' in parsedMessage && parsedMessage.type === 'status-update' && parsedMessage.status === 'ended') {
                        this.hasEmittedCallEndedStatus = true;
                    }
                } catch (parseError) {
                    console.log('Error parsing message data: ', parseError);
                }
            }
        } catch (e) {
            console.error(e);
        }
    }
    handleRemoteParticipantsAudioLevel(e) {
        const speechLevel = Object.values(e.participantsAudioLevel).reduce((a, b)=>a + b, 0);
        this.emit('volume-level', Math.min(1, speechLevel / 0.15));
        const isSpeaking = speechLevel > 0.01;
        if (!isSpeaking) {
            return;
        }
        if (this.speakingTimeout) {
            clearTimeout(this.speakingTimeout);
            this.speakingTimeout = null;
        } else {
            this.emit('speech-start');
        }
        this.speakingTimeout = setTimeout(()=>{
            this.emit('speech-end');
            this.speakingTimeout = null;
        }, 1000);
    }
    stop() {
        this.started = false;
        this.call?.destroy();
        this.call = null;
    }
    send(message) {
        this.call?.sendAppMessage(JSON.stringify(message));
    }
    setMuted(mute) {
        if (!this.call) {
            throw new Error('Call object is not available.');
        }
        this.call.setLocalAudio(!mute);
    }
    isMuted() {
        if (!this.call) {
            return false;
        }
        return this.call.localAudio() === false;
    }
    say(message, endCallAfterSpoken) {
        this.send({
            type: 'say',
            message,
            endCallAfterSpoken
        });
    }
    setInputDevicesAsync(options) {
        this.call?.setInputDevicesAsync(options);
    }
    async increaseMicLevel(gain) {
        if (!this.call) {
            throw new Error('Call object is not available.');
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: true
            });
            const audioContext = new AudioContext();
            const source = audioContext.createMediaStreamSource(stream);
            const gainNode = audioContext.createGain();
            gainNode.gain.value = gain;
            source.connect(gainNode);
            const destination = audioContext.createMediaStreamDestination();
            gainNode.connect(destination);
            const [boostedTrack] = destination.stream.getAudioTracks();
            await this.call.setInputDevicesAsync({
                audioSource: boostedTrack
            });
        } catch (error) {
            console.error("Error adjusting microphone level:", error);
        }
    }
    setOutputDeviceAsync(options) {
        this.call?.setOutputDeviceAsync(options);
    }
    getDailyCallObject() {
        return this.call;
    }
    startScreenSharing(displayMediaOptions, screenVideoSendSettings) {
        this.call?.startScreenShare({
            displayMediaOptions,
            screenVideoSendSettings
        });
    }
    stopScreenSharing() {
        this.call?.stopScreenShare();
    }
}
exports.default = Vapi;
}}),
"[project]/node_modules/next/dist/build/webpack/loaders/next-flight-loader/action-client-wrapper.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// This file must be bundled in the app's client layer, it shouldn't be directly
// imported by the server.
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    callServer: null,
    createServerReference: null,
    findSourceMapURL: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    callServer: function() {
        return _appcallserver.callServer;
    },
    createServerReference: function() {
        return createServerReference;
    },
    findSourceMapURL: function() {
        return _appfindsourcemapurl.findSourceMapURL;
    }
});
const _appcallserver = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-call-server.js [app-ssr] (ecmascript)");
const _appfindsourcemapurl = __turbopack_context__.r("[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-ssr] (ecmascript)");
const createServerReference = (("TURBOPACK compile-time truthy", 1) ? __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-server-dom-turbopack-client-edge.js [app-ssr] (ecmascript)") : ("TURBOPACK unreachable", undefined)).createServerReference; //# sourceMappingURL=action-client-wrapper.js.map
}}),

};

//# sourceMappingURL=node_modules_2b655a85._.js.map